{"version":3,"sources":["examples/hacks_ddrop/hacks_ddrop.js","examples/hacks_ddrop/node_modules/browserify/node_modules/browser-pack/_prelude.js","examples/hacks_ddrop/app/examples/hacks_ddrop/hacks_ddrop.js","examples/hacks_ddrop/app/modules/controls/OrbitControls2D.js","examples/hacks_ddrop/app/modules/core/Intersections.js","examples/hacks_ddrop/app/modules/geometries/geometries.slice.js","examples/hacks_ddrop/app/modules/helpers/helpers.series.js","examples/hacks_ddrop/app/modules/loaders/loaders.dicom.js","examples/hacks_ddrop/app/modules/models/models.frame.js","examples/hacks_ddrop/app/modules/models/models.series.js","examples/hacks_ddrop/app/modules/models/models.stack.js","examples/hacks_ddrop/app/modules/parsers/parsers.dicom.js","examples/hacks_ddrop/app/modules/shaders/shaders.data.js","examples/hacks_ddrop/node_modules/dicom-parser/dist/dicomParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","init","animate","controls","update","renderer","render","scene","camera","statsyay","requestAnimationFrame","threeD","document","getElementById","THREE","WebGLRenderer","antialias","setSize","offsetWidth","offsetHeight","setClearColor","maxTextureSize","context","getParameter","MAX_TEXTURE_SIZE","window","console","log","appendChild","domElement","Stats","Scene","PerspectiveCamera","position","x","y","z","lookAt","vjsOrbitControl2D","vjsLoaderDicom","onload","readMultipleFiles","evt","target","files","FileReader","arrayBuffer","result","loader","myHelper","parse","seriesHelper","push","mergedHelpers","k","j","merge","prepare","add","stack","_series","_stack","gui","dat","GUI","autoPlace","customContainer","stackFolder","addFolder","windowWidthUpdate","_minMax","step","onChange","value","windowLevel","_windowLevel","_uniforms","uWindowLevel","windowCenterUpdate","invertUpdate","uInvert","frameIndex","_dimensions","updateSliceGeometry","updateBorderGeometry","open","readAsArrayBuffer","addEventListener","../../modules/controls/OrbitControls2D","../../modules/loaders/loaders.dicom",2,"OrbitControls2D","object","getAutoRotationAngle","Math","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","event","enabled","preventDefault","button","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","set","clientX","clientY","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","onMouseMove","onMouseUp","dispatchEvent","startEvent","element","body","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","removeEventListener","endEvent","onMouseWheel","stopPropagation","delta","undefined","wheelDelta","detail","onKeyDown","noKeys","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","touchend","this","Vector3","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MOUSE","MIDDLE","theta","phi","EPS","Vector2","panOffset","offset","phiDelta","thetaDelta","scale","lastPosition","lastQuaternion","Quaternion","target0","clone","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","angle","panLeft","te","matrix","elements","multiplyScalar","panUp","deltaX","deltaY","fov","sub","targetDistance","tan","top","right","left","zoom","bottom","warn","dollyScale","updateProjectionMatrix","applyQuaternion","atan2","max","min","radius","sin","cos","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","prototype","Object","create","EventDispatcher","constructor",3,"VJS","intersections","obbPlane","obb","plane","t1","direction","applyMatrix4","toOBBSpace","t0","planeOBB","normalize","bboxMin","halfDimensions","bboxMax","ray","orientation","intersection","rayPlane","toOBBSpaceInvert",4,"vjsIntersections","geometries","slice","Matrix4","centerOfMass","orderedIntersections","orderIntersections","formatIntersections","formatIntersectionsXY","point","xy","sliceShape","Shape","moveTo","lineTo","ShapeGeometry","vertices","verticesNeedUpdate","points","divideScalar","reference","a0","b0","c0","x0","y0","z0","l0","origin","base","crossVectors","orderedpoints","a1","b1","c1","x1","y1","z1","l1","thetaAngle","sort","b","../core/Intersections",5,"vjsSliceGeometries","vjsShadersData","helpers","series","Object3D","_frameIndex","_slice","_border","addSeries","getStack","stackIndex","dimensions","_halfDimensions","geometry","BoxGeometry","applyMatrix","makeTranslation","_ijk2LPS","material","MeshBasicMaterial","wireframe","color","cube","Mesh","floor","sliceGeometry","round","textures","m","_nbTextures","tex","DataTexture","_rawData","_textureSize","RGBFormat","UnsignedByteType","UVMapping","ClampToEdgeWrapping","NearestFilter","needsUpdate","sliceMaterial","ShaderMaterial","side","DoubleSide","transparency","uniforms","parameters","vertexShader","fragmentShader","mySliceMaterial","uTextureSize","uTextureContainer","uDataDimensions","uWorldToData","_lps2IJK","uNumberOfChannels","_numberOfChannels","uBitsAllocated","_bitsAllocated","_invert","borderMaterial","LineBasicMaterial","polygonOffset","polygonOffsetFactor","borderGeometry","Geometry","Line","../geometries/geometries.slice","../shaders/shaders.data",6,"parsers","dicom","models","frame","loaders","manager","DefaultLoadingManager","crossOrigin","responseType","_imageHelper","_image","load","file","onLoad","onProgress","onError","XHRLoader","setCrossOrigin","setResponseType","response","dicomParser","id","_seriesInstanceUID","seriesInstanceUID","_numberOfFrames","numberOfFrames","numberOfChannels","_rows","rows","_columns","columns","_pixelData","extractPixelData","_pixelSpacing","pixelSpacing","_sliceThickness","sliceThickness","_imageOrientation","imageOrientation","_imagePosition","imagePosition","_dimensionIndexValues","dimensionIndexValues","bitsAllocated","_instanceNumber","instanceNumber","minMaxPixelData","_frame","../helpers/helpers.series","../models/models.frame","../models/models.series","../models/models.stack","../parsers/parsers.dicom",7,"_id","_stackID","_imagePositionPatient","_imageOrientationPatient","row","column","_spacingBetweenSlices",8,"_concatenationUID","_seriesNumber","_dimensionIndexSequence","_photometricInterpretation","sameSeriesUID",9,"_uid","_origin","_orientation","_windowCenter","_windowWidth","_spacing","_direction","orderFrames","zSpacing","_pixelAspectRatio","xCosine","yCosine","zCosine","baseX","baseY","baseZ","getInverse","nbVoxels","ii","Uint8Array","frameDimension","textureDimension","time","jj","inFrameIndex","textureIndex","inTextureIndex","rawValue","lsb","msb","width","orderFrameOnDimensionIndices","toString","parseInt","computeDistance","normal","_dist","map","bind","sameStackID","join",10,"_arrayBuffer","byteArray","_dataSet","parseDicom","string","modality","sopInstanceUID","transferSyntaxUID","photometricInterpretation","planarConfiguration","uint16","samplesPerPixel","intString","perFrameFunctionnalGroupSequence","x52009230","planeOrientationSequence","items","dataSet","x00209116","split","Number","pixelAspectRatio","x00209113","x2005140f","x00289110","floatString","pixelRepresentation","highBit","rescaleIntercept","philipsPrivateSequence","x00289145","rescaleSlope","windowCenter","x00289132","windowWidth","x00209111","x00209157","nbValues","uint32","inStackPositionNumber","stackID","dPixelData","pixelDataElement","x7fe00010","buffer","dataOffset","ePixelData","pixelDataOffset","numPixels","frameOffset","Uint16Array","Int16Array","encodedPixelData","nPixels","ybrIndex","rgbaIndex","cb","cr","pixelData","minMax","index","spv","frameOfReferenceUID","imageJqueryDom","seriesNumber","find","text","dicom-parser",11,"shaders","data",12,"root","factory","define","amd","Package","options","readPrefix","littleEndianByteStream","seek","prefix","readFixedString","readPart10Header","warnings","readDicomElementExplicit","tag","parser","littleEndianByteArrayParser","metaHeaderDataSet","DataSet","byteArrayParser","readTransferSyntax","x00020010","transferSyntaxElement","isExplicit","transferSyntax","getDataSetByteStream","ByteStream","bigEndianByteArrayParser","mergeDataSets","instanceDataSet","propertyName","hasOwnProperty","concat","readDataSet","explicit","dataSetByteStream","parseDicomDataSetExplicit","parseDicomDataSetImplicit","ex","exception","parseTheByteStream","readUint16","readInt16","int16","readUint32","readInt32","int32","readFloat","byteArrayForParsingFloat","floatArray","Float32Array","readDouble","Float64Array","byte","String","fromCharCode","readByteStream","numBytes","byteArrayView","getByteArrayParser","defaultParser","numStringValues","fixedString","numMatching","match","values","trim","replace","parseFloat","findEndOfEncapsulatedElement","byteStream","encapsulatedPixelData","basicOffsetTable","fragments","basicOffsetTableItemTag","readTag","basicOffsetTableItemlength","numFragments","baseOffset","findItemDelimitationItemAndSetElementLength","itemDelimitationItemLength","maxPosition","groupNumber","elementNumber","itemDelimiterLength","untilTag","readDicomElementImplicit","getDataLengthSizeInBytesForVR","vr","dataLengthSizeBytes","hadUndefinedLength","readSequenceItemsExplicit","nextTag","readSequenceItemsImplicit","getPixelDataFromFragments","bufferSize","pixelDataIndex","fragmentOffset","readFragmentsUntil","endOfFrame","fragment","readSequenceItem","readEncapsulatedPixelDataWithBasicOffsetTable","numFrames","endOfFrameOffset","readEncapsulatedDataNoBasicOffsetTable","readEncapsulatedPixelData","readDicomDataSetExplicitUndefinedLength","readSequenceItemExplicit","item","readSQElementUndefinedLengthExplicit","readSQElementKnownLengthExplicit","readDicomDataSetImplicitUndefinedLength","readSequenceItemImplicit","readSQElementUndefinedLengthImplicit","readSQElementKnownLengthImplicit","substr","explicitDataSetToJS","omitPrivateAttibutes","maxElementLength","isPrivateTag","sequenceItems","asString","explicitElementToString","multiElementToString","numItems","func","textResult","isStringVr","num","toUpperCase","stringVrs","AE","AS","AT","CS","DA","DS","DT","FL","FD","IS","LO","LT","OB","OD","OF","OW","PN","SH","SL","SQ","SS","ST","TM","UI","UL","UN","UR","US","UT","lastGroupDigit","groupIsOdd","parsePN","personName","stringValues","familyName","givenName","middleName","suffix","parseDA","date","yyyy","substring","mm","dd","year","month","day","parseTM","hh","ss","ffffff","hours","minutes","seconds","fractionalSeconds"],"mappings":"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","file":"examples/hacks_ddrop/hacks_ddrop.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats, dat*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay;\n\n// FUNCTIONS\nfunction init() {\n\n  // this function is executed on each animation frame\n  function animate() {\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    statsyay.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  statsyay = new Stats();\n  threeD.appendChild(statsyay.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 100;\n  camera.position.y = 100;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  animate();\n}\n\nwindow.onload = function() {\n\n  // init threeJS...\n  init();\n\n  var seriesHelper = [];\n\n  function readMultipleFiles(evt) {\n    //Retrieve the first (and only!) File from the FileList object\n    //window.console.log(evt.target.files.length);\n\n    for (var i = 0; i < evt.target.files.length; i++) {\n      var f = evt.target.files[i]; \n\n      if (f) {\n        var r = new FileReader();\n        r.onload = function(e) { \n        var arrayBuffer = e.target.result;\n        var loader = new vjsLoaderDicom();\n        var myHelper = loader.parse(arrayBuffer);\n        // myHelper.prepare();\n        seriesHelper.push(myHelper);\n\n        if (seriesHelper.length === evt.target.files.length) {\n          //     window.console.log(seriesHelper);\n          var mergedHelpers = [seriesHelper[0]];\n          //     // if all files loaded\n          //     window.console.log('merged:', mergedHelpers.length);\n          //     window.console.log('series:', seriesHelper.length);\n          for (var k = 0; k < seriesHelper.length; k++) {\n            // test image against existing imagess\n            for (var j = 0; j < mergedHelpers.length; j++) {\n              if (mergedHelpers[j].merge(seriesHelper[k])) {\n                // merged successfully\n                break;\n              } else if (j === mergedHelpers.length - 1) {\n                // last merge was not successful\n                // this is a new image\n                mergedHelpers.push(seriesHelper[k]);\n              }\n            }\n          }\n\n          mergedHelpers[0].prepare();\n          scene.add(mergedHelpers[0]);\n          var stack = mergedHelpers[0]._series._stack[0];\n\n          var gui = new dat.GUI({\n            autoPlace: false\n          });\n\n          var customContainer = document.getElementById('my-gui-container');\n          customContainer.appendChild(gui.domElement);\n\n          var stackFolder = gui.addFolder('Stack');\n          var windowWidthUpdate = stackFolder.add(stack, '_windowWidth', 1, stack._minMax[1]).step(1);\n          windowWidthUpdate.onChange(function(value) {\n            var windowLevel = stack._windowLevel;\n            windowLevel[1] = value;\n            mergedHelpers[0]._uniforms.uWindowLevel.value = windowLevel;\n          });\n          var windowCenterUpdate = stackFolder.add(stack, '_windowCenter', stack._minMax[0], stack._minMax[1]).step(1);\n          windowCenterUpdate.onChange(function(value) {\n            var windowLevel = stack._windowLevel;\n            windowLevel[0] = value;\n            mergedHelpers[0]._uniforms.uWindowLevel.value = windowLevel;\n          });\n\n          var invertUpdate = stackFolder.add(stack, '_invert', 0, 1).step(1);\n          invertUpdate.onChange(function(value) {\n            mergedHelpers[0]._uniforms.uInvert.value = value;\n          });\n\n          var frameIndex = stackFolder.add(mergedHelpers[0], '_frameIndex', 0, stack._dimensions.z - 1).step(1);\n          frameIndex.onChange(function(value) {\n            mergedHelpers[0].updateSliceGeometry();\n            mergedHelpers[0].updateBorderGeometry();\n          });\n\n          stackFolder.open();\n        }\n      };\n        r.readAsArrayBuffer(f);\n      } else { \n        window.console.log('Failed to load file');\n      }\n    }\n  }\n  // hook up file input listener\n  document.getElementById('fileinput').addEventListener('change', readMultipleFiles, false);\n};\n\n},{\"../../modules/controls/OrbitControls2D\":2,\"../../modules/loaders/loaders.dicom\":6}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n\n},{\"../core/Intersections\":3}],5:[function(require,module,exports){\n'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n\n},{\"../geometries/geometries.slice\":4,\"../shaders/shaders.data\":11}],6:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n\n},{\"../helpers/helpers.series\":5,\"../models/models.frame\":7,\"../models/models.series\":8,\"../models/models.stack\":9,\"../parsers/parsers.dicom\":10}],7:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n\n},{}],10:[function(require,module,exports){\n/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n\n},{\"dicom-parser\":12}],11:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n\n},{}],12:[function(require,module,exports){\n/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));\n},{}]},{},[1])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats, dat*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay;\n\n// FUNCTIONS\nfunction init() {\n\n  // this function is executed on each animation frame\n  function animate() {\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    statsyay.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  statsyay = new Stats();\n  threeD.appendChild(statsyay.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 100;\n  camera.position.y = 100;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  animate();\n}\n\nwindow.onload = function() {\n\n  // init threeJS...\n  init();\n\n  var seriesHelper = [];\n\n  function readMultipleFiles(evt) {\n    //Retrieve the first (and only!) File from the FileList object\n    //window.console.log(evt.target.files.length);\n\n    for (var i = 0; i < evt.target.files.length; i++) {\n      var f = evt.target.files[i]; \n\n      if (f) {\n        var r = new FileReader();\n        r.onload = function(e) { \n        var arrayBuffer = e.target.result;\n        var loader = new vjsLoaderDicom();\n        var myHelper = loader.parse(arrayBuffer);\n        // myHelper.prepare();\n        seriesHelper.push(myHelper);\n\n        if (seriesHelper.length === evt.target.files.length) {\n          //     window.console.log(seriesHelper);\n          var mergedHelpers = [seriesHelper[0]];\n          //     // if all files loaded\n          //     window.console.log('merged:', mergedHelpers.length);\n          //     window.console.log('series:', seriesHelper.length);\n          for (var k = 0; k < seriesHelper.length; k++) {\n            // test image against existing imagess\n            for (var j = 0; j < mergedHelpers.length; j++) {\n              if (mergedHelpers[j].merge(seriesHelper[k])) {\n                // merged successfully\n                break;\n              } else if (j === mergedHelpers.length - 1) {\n                // last merge was not successful\n                // this is a new image\n                mergedHelpers.push(seriesHelper[k]);\n              }\n            }\n          }\n\n          mergedHelpers[0].prepare();\n          scene.add(mergedHelpers[0]);\n          var stack = mergedHelpers[0]._series._stack[0];\n\n          var gui = new dat.GUI({\n            autoPlace: false\n          });\n\n          var customContainer = document.getElementById('my-gui-container');\n          customContainer.appendChild(gui.domElement);\n\n          var stackFolder = gui.addFolder('Stack');\n          var windowWidthUpdate = stackFolder.add(stack, '_windowWidth', 1, stack._minMax[1]).step(1);\n          windowWidthUpdate.onChange(function(value) {\n            var windowLevel = stack._windowLevel;\n            windowLevel[1] = value;\n            mergedHelpers[0]._uniforms.uWindowLevel.value = windowLevel;\n          });\n          var windowCenterUpdate = stackFolder.add(stack, '_windowCenter', stack._minMax[0], stack._minMax[1]).step(1);\n          windowCenterUpdate.onChange(function(value) {\n            var windowLevel = stack._windowLevel;\n            windowLevel[0] = value;\n            mergedHelpers[0]._uniforms.uWindowLevel.value = windowLevel;\n          });\n\n          var invertUpdate = stackFolder.add(stack, '_invert', 0, 1).step(1);\n          invertUpdate.onChange(function(value) {\n            mergedHelpers[0]._uniforms.uInvert.value = value;\n          });\n\n          var frameIndex = stackFolder.add(mergedHelpers[0], '_frameIndex', 0, stack._dimensions.z - 1).step(1);\n          frameIndex.onChange(function(value) {\n            mergedHelpers[0].updateSliceGeometry();\n            mergedHelpers[0].updateBorderGeometry();\n          });\n\n          stackFolder.open();\n        }\n      };\n        r.readAsArrayBuffer(f);\n      } else { \n        window.console.log('Failed to load file');\n      }\n    }\n  }\n  // hook up file input listener\n  document.getElementById('fileinput').addEventListener('change', readMultipleFiles, false);\n};\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n","'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n","'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n","'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n","/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n","/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));"],"sourceRoot":"/source/"}