{"version":3,"sources":["examples/loader_dicoms/loader_dicoms.js","examples/loader_dicoms/node_modules/browserify/node_modules/browser-pack/_prelude.js","examples/loader_dicoms/app/examples/loader_dicoms/loader_dicoms.js","examples/loader_dicoms/app/modules/controls/OrbitControls2D.js","examples/loader_dicoms/app/modules/core/Intersections.js","examples/loader_dicoms/app/modules/geometries/geometries.slice.js","examples/loader_dicoms/app/modules/helpers/helpers.series.js","examples/loader_dicoms/app/modules/loaders/loaders.dicom.js","examples/loader_dicoms/app/modules/models/models.frame.js","examples/loader_dicoms/app/modules/models/models.series.js","examples/loader_dicoms/app/modules/models/models.stack.js","examples/loader_dicoms/app/modules/parsers/parsers.dicom.js","examples/loader_dicoms/app/modules/shaders/shaders.data.js","examples/loader_dicoms/app/modules/widgets/widgets.orientation.js","examples/loader_dicoms/app/modules/widgets/widgets.pixelProbe.js","examples/loader_dicoms/node_modules/dicom-parser/dist/dicomParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","onProgressCallback","evt","filename","percentComplete","Math","round","loaded","total","window","console","log","fileContainer","document","getElementById","innerHTML","progressContainer","div","createElement","setAttribute","appendChild","init","onDocumentMouseMove","event","mouse","x","clientX","threeD","offsetWidth","y","clientY","offsetHeight","onDocumentMouseDown","preventDefault","raycaster","setFromCamera","camera","domElement","probe","mark","animate","update","orientation","controls","renderer","render","scene","stats","requestAnimationFrame","THREE","WebGLRenderer","antialias","setSize","setClearColor","maxTextureSize","context","getParameter","MAX_TEXTURE_SIZE","Stats","Scene","PerspectiveCamera","position","z","lookAt","vjsOrbitControl2D","vjsOrientationWidget","Raycaster","Vector2","addEventListener","dat","vjsProbePixelWidget","vjsLoaderDicom","onload","loadClosure","loader","manager","load","imageHelper","seriesHelper","push","message","geometry","BoxGeometry","material","MeshBasicMaterial","wireframe","color","cube","Mesh","add","LoadingManager","onProgress","item","mergedHelpers","j","merge","prepare","_series","children","filenames","files","map","v","k","../../modules/controls/OrbitControls2D","../../modules/loaders/loaders.dicom","../../modules/widgets/widgets.orientation","../../modules/widgets/widgets.pixelProbe",2,"OrbitControls2D","object","getAutoRotationAngle","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","enabled","button","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","set","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","onMouseMove","onMouseUp","dispatchEvent","startEvent","element","body","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","removeEventListener","endEvent","onMouseWheel","stopPropagation","delta","undefined","wheelDelta","detail","onKeyDown","noKeys","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","touchend","this","target","Vector3","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MOUSE","MIDDLE","theta","phi","EPS","panOffset","offset","phiDelta","thetaDelta","scale","lastPosition","lastQuaternion","Quaternion","target0","clone","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","angle","panLeft","te","matrix","elements","multiplyScalar","panUp","deltaX","deltaY","fov","sub","targetDistance","tan","top","right","left","zoom","bottom","warn","dollyScale","updateProjectionMatrix","applyQuaternion","atan2","max","min","radius","sin","cos","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","prototype","Object","create","EventDispatcher","constructor",3,"VJS","intersections","obbPlane","obb","plane","t1","direction","applyMatrix4","toOBBSpace","t0","planeOBB","normalize","bboxMin","halfDimensions","bboxMax","ray","intersection","rayPlane","toOBBSpaceInvert",4,"vjsIntersections","geometries","slice","Matrix4","centerOfMass","orderedIntersections","orderIntersections","formatIntersections","formatIntersectionsXY","point","xy","sliceShape","Shape","moveTo","lineTo","ShapeGeometry","vertices","verticesNeedUpdate","points","divideScalar","reference","a0","b0","c0","x0","y0","z0","l0","origin","base","crossVectors","orderedpoints","a1","b1","c1","x1","y1","z1","l1","thetaAngle","sort","b","../core/Intersections",5,"vjsSliceGeometries","vjsShadersData","helpers","series","Object3D","_uniforms","_frameIndex","_slice","_border","addSeries","getStack","stackIndex","stack","_stack","dimensions","_dimensions","_halfDimensions","applyMatrix","makeTranslation","_ijk2LPS","floor","sliceGeometry","textures","m","_nbTextures","tex","DataTexture","_rawData","_textureSize","RGBFormat","UnsignedByteType","UVMapping","ClampToEdgeWrapping","NearestFilter","needsUpdate","sliceMaterial","ShaderMaterial","side","DoubleSide","transparency","uniforms","parameters","vertexShader","fragmentShader","mySliceMaterial","uTextureSize","value","uTextureContainer","uDataDimensions","uWorldToData","_lps2IJK","uWindowLevel","_windowLevel","uNumberOfChannels","_numberOfChannels","uBitsAllocated","_bitsAllocated","uInvert","_invert","borderMaterial","LineBasicMaterial","polygonOffset","polygonOffsetFactor","borderGeometry","Geometry","Line","updateSliceGeometry","updateBorderGeometry","../geometries/geometries.slice","../shaders/shaders.data",6,"parsers","dicom","models","frame","loaders","DefaultLoadingManager","crossOrigin","responseType","_imageHelper","_image","file","onLoad","onError","XHRLoader","setCrossOrigin","setResponseType","response","parse","dicomParser","id","_seriesInstanceUID","seriesInstanceUID","_numberOfFrames","numberOfFrames","numberOfChannels","_rows","rows","_columns","columns","_pixelData","extractPixelData","_pixelSpacing","pixelSpacing","_sliceThickness","sliceThickness","_imageOrientation","imageOrientation","_imagePosition","imagePosition","_dimensionIndexValues","dimensionIndexValues","bitsAllocated","_instanceNumber","instanceNumber","_minMax","minMaxPixelData","_frame","../helpers/helpers.series","../models/models.frame","../models/models.series","../models/models.stack","../parsers/parsers.dicom",7,"_id","_stackID","_imagePositionPatient","_imageOrientationPatient","row","column","_spacingBetweenSlices",8,"_concatenationUID","_seriesNumber","_dimensionIndexSequence","_photometricInterpretation","sameSeriesUID",9,"_uid","_origin","_orientation","_windowCenter","_windowWidth","_spacing","_direction","orderFrames","zSpacing","_pixelAspectRatio","xCosine","yCosine","zCosine","baseX","baseY","baseZ","getInverse","nbVoxels","ii","Uint8Array","frameDimension","textureDimension","time","jj","frameIndex","inFrameIndex","textureIndex","inTextureIndex","rawValue","lsb","msb","width","orderFrameOnDimensionIndices","toString","parseInt","computeDistance","normal","_dist","bind","sameStackID","join",10,"arrayBuffer","_arrayBuffer","byteArray","_dataSet","parseDicom","string","modality","sopInstanceUID","transferSyntaxUID","photometricInterpretation","planarConfiguration","uint16","samplesPerPixel","intString","perFrameFunctionnalGroupSequence","x52009230","planeOrientationSequence","items","dataSet","x00209116","split","Number","pixelAspectRatio","x00209113","x2005140f","x00289110","floatString","pixelRepresentation","highBit","rescaleIntercept","philipsPrivateSequence","x00289145","rescaleSlope","windowCenter","x00289132","windowWidth","x00209111","x00209157","nbValues","uint32","inStackPositionNumber","stackID","dPixelData","pixelDataElement","x7fe00010","buffer","dataOffset","ePixelData","pixelDataOffset","numPixels","frameOffset","Uint16Array","Int16Array","encodedPixelData","nPixels","ybrIndex","rgbaIndex","cb","cr","pixelData","minMax","index","spv","frameOfReferenceUID","imageJqueryDom","seriesNumber","find","text","dicom-parser",11,"shaders","data",12,"widgets","parentID","targetCamera","targetControl","_ParentId","_TargetCamera","_TargetControl","_DomElement","_Renderer","_Scene","_Camera","_Axes","_Style","height","createDomContainer","setupObject","style","parent","alpha","AxisHelper","setLength",13,"pixelProbe","image","imageMeshes","rasContainer","ijkContainer","valueContainer","volumeCore","marks","createDomElement","_worldCoordinate","_dataCoordinate","_dataValue","_labelValue","computeValues","worldToData","dataCoordinate","temp","updateUI","rasContent","toFixed","ijkContent","valueContent","display","canvas","updateMarkDom","intersects","intersectObjects","intersect","worldCoordinates","hideUI","intersect2","ijk","dataToWorld","worldCenterCoordinate","voxDataCoord","voxelGeometry","voxelMaterial","voxel","name","markDom","screenCoordinates","project",14,"root","factory","define","amd","Package","options","readPrefix","littleEndianByteStream","seek","prefix","readFixedString","readPart10Header","warnings","readDicomElementExplicit","tag","parser","littleEndianByteArrayParser","metaHeaderDataSet","DataSet","byteArrayParser","readTransferSyntax","x00020010","transferSyntaxElement","isExplicit","transferSyntax","getDataSetByteStream","ByteStream","bigEndianByteArrayParser","mergeDataSets","instanceDataSet","propertyName","hasOwnProperty","concat","readDataSet","explicit","dataSetByteStream","parseDicomDataSetExplicit","parseDicomDataSetImplicit","ex","exception","parseTheByteStream","readUint16","readInt16","int16","readUint32","readInt32","int32","readFloat","byteArrayForParsingFloat","floatArray","Float32Array","readDouble","Float64Array","result","byte","String","fromCharCode","readByteStream","numBytes","byteArrayView","getByteArrayParser","defaultParser","numStringValues","fixedString","numMatching","match","values","trim","replace","parseFloat","findEndOfEncapsulatedElement","byteStream","encapsulatedPixelData","basicOffsetTable","fragments","basicOffsetTableItemTag","readTag","basicOffsetTableItemlength","numFragments","baseOffset","findItemDelimitationItemAndSetElementLength","itemDelimitationItemLength","maxPosition","groupNumber","elementNumber","itemDelimiterLength","untilTag","readDicomElementImplicit","getDataLengthSizeInBytesForVR","vr","dataLengthSizeBytes","hadUndefinedLength","readSequenceItemsExplicit","nextTag","readSequenceItemsImplicit","getPixelDataFromFragments","bufferSize","pixelDataIndex","fragmentOffset","readFragmentsUntil","endOfFrame","fragment","readSequenceItem","readEncapsulatedPixelDataWithBasicOffsetTable","numFrames","endOfFrameOffset","readEncapsulatedDataNoBasicOffsetTable","readEncapsulatedPixelData","readDicomDataSetExplicitUndefinedLength","readSequenceItemExplicit","readSQElementUndefinedLengthExplicit","readSQElementKnownLengthExplicit","readDicomDataSetImplicitUndefinedLength","readSequenceItemImplicit","readSQElementUndefinedLengthImplicit","readSQElementKnownLengthImplicit","substr","explicitDataSetToJS","omitPrivateAttibutes","maxElementLength","isPrivateTag","sequenceItems","asString","explicitElementToString","multiElementToString","numItems","func","textResult","isStringVr","num","toUpperCase","stringVrs","AE","AS","AT","CS","DA","DS","DT","FL","FD","IS","LO","LT","OB","OD","OF","OW","PN","SH","SL","SQ","SS","ST","TM","UI","UL","UN","UR","US","UT","lastGroupDigit","groupIsOdd","parsePN","personName","stringValues","familyName","givenName","middleName","suffix","parseDA","date","yyyy","substring","mm","dd","year","month","day","parseTM","hh","ss","ffffff","hours","minutes","seconds","fractionalSeconds"],"mappings":"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","file":"examples/loader_dicoms/loader_dicoms.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsProbePixelWidget = require('../../modules/widgets/widgets.pixelProbe');\nvar vjsOrientationWidget = require('../../modules/widgets/widgets.orientation');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, dat, probe, raycaster, mouse, orientation;\n\n// FUNCTIONS\nfunction onProgressCallback(evt, filename) {\n    var percentComplete = Math.round((evt.loaded / evt.total) * 100);\n\n    window.console.log(filename);\n\n    var fileContainer = document.getElementById(filename);\n    if (!fileContainer) {\n        var progressContainer = document.getElementById('my-progress-container');\n        var div = document.createElement('div');\n        div.setAttribute('id', filename);\n        div.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n\n        progressContainer.appendChild(div);\n    } else {\n        fileContainer.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n    }\n}\n\nfunction init() {\n\n    function onDocumentMouseMove(event) {\n        // calculate mouse position in normalized device coordinates\n        // (-1 to +1) for both components\n        mouse.x = (event.clientX / threeD.offsetWidth) * 2 - 1;\n        mouse.y = -(event.clientY / threeD.offsetHeight) * 2 + 1;\n        mouse.clientX = event.clientX;\n        mouse.clientY = event.clientY;\n    }\n\n    function onDocumentMouseDown(event) {\n        event.preventDefault();\n\n        // create/select handle\n        raycaster.setFromCamera(mouse, camera);\n        // name???\n        var domElement = probe.mark(raycaster, mouse);\n        if (domElement) {\n            var threeD = document.getElementById('r3d');\n            threeD.appendChild(domElement);\n        }\n\n    }\n\n    // this function is executed on each animation frame\n    function animate() {\n        // image probe widget\n        if (mouse && raycaster && probe) {\n            raycaster.setFromCamera(mouse, camera);\n            probe.update(raycaster, mouse, camera, threeD);\n        }\n\n        orientation.update();\n        controls.update();\n        renderer.render(scene, camera);\n        stats.update();\n\n        // request new frame\n        requestAnimationFrame(function() {\n            animate();\n        });\n    }\n\n    // renderer\n    var threeD = document.getElementById('r3d');\n    renderer = new THREE.WebGLRenderer({\n        antialias: true\n    });\n    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n    renderer.setClearColor(0xFFFFFF, 1);\n\n    var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n    window.console.log(maxTextureSize);\n\n    threeD.appendChild(renderer.domElement);\n\n    // stats\n    stats = new Stats();\n    threeD.appendChild(stats.domElement);\n\n    // scene\n    scene = new THREE.Scene();\n    // camera\n    camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n    camera.position.x = 150;\n    camera.position.y = 150;\n    camera.position.z = 100;\n    camera.lookAt(scene.position);\n    // controls\n    controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n    // orientation widget\n    orientation = new vjsOrientationWidget('r3d', camera, controls);\n\n    //\n    // mouse callbacks\n    raycaster = new THREE.Raycaster();\n    mouse = new THREE.Vector2();\n    renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n    renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n\n    animate();\n}\n\nwindow.onload = function() {\n\n    // init threeJS...\n    init();\n\n    window.console.log(dat);\n\n    // Create Box\n    var geometry = new THREE.BoxGeometry(500, 500, 500);\n    var material = new THREE.MeshBasicMaterial({\n        wireframe: true,\n        color: 0x607D8B\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    scene.add(cube);\n\n    // create loader manager (to keep track of progress over N files...)\n    // might not be useful with promises anymore.\n\n    // can not promise do it for us??\n    var seriesHelper = [];\n    var manager = new THREE.LoadingManager();\n    manager.onProgress = function(item, loaded, total) {\n        window.console.log('manager progress ----');\n        window.console.log(item);\n        var fileContainer = document.getElementById(item);\n        if (fileContainer) {\n            fileContainer.innerHTML = ' ' + item + ' is ready! ' + '(' + loaded + '/' + total + ')';\n        }\n\n        if (loaded === total) {\n            window.console.log(seriesHelper);\n            var mergedHelpers = [seriesHelper[0]];\n            // if all files loaded\n            for (var i = 0; i < seriesHelper.length; i++) {\n                // test image against existing imagess\n                for (var j = 0; j < mergedHelpers.length; j++) {\n                    if (mergedHelpers[j].merge(seriesHelper[i])) {\n                        // merged successfully\n                        break;\n                    } else if (j === mergedHelpers.length - 1) {\n                        // last merge was not successful\n                        // this is a new image\n                        mergedHelpers.push(seriesHelper[i]);\n                    }\n                }\n            }\n\n            mergedHelpers[0].prepare();\n            scene.add(mergedHelpers[0]);\n\n            probe = new vjsProbePixelWidget(mergedHelpers[0]._series, mergedHelpers[0].children);\n            scene.add(probe);\n\n            var threeD = document.getElementById('r3d');\n            threeD.appendChild(probe.domElement);\n\n        }\n    };\n\n    var filenames = [\n        // '36444280', '36444294', '36444308', '36444322', '36444336', '36444350',\n        // '36444364', '36444378', '36444392', '36444406', '36444420', '36444434',\n        // '36444448', '36444462', '36444476', '36444490', '36444504', '36444518',\n        // '36444532', '36746856', '36746870', '36746884', '36746898', '36746912',\n        // '36746926', '36746940', '36746954', '36746968', '36746982', '36746996',\n        // '36747010', '36747024', '36747043', '36747062', '36747136', '36747150',\n        // '36747164', '36747178', '36747192', '36747206', '36747220', '36747234',\n        // '36747248', '36747262', '36747276', '36747290', '36747304', '36747318',\n        // '36747332', '36747346', '36747360', '36747374', '36747388', '36747402',\n        // '36747416', '36747430', '36747444', '36747458', '36747472', '36747486',\n        // '36747500', '36747514', '36747528', '36747542', '36747556', '36747570',\n        // '36747584', '36747598', '36747612', '36747626', '36747640', '36747654',\n        // '36747668', '36747682', '36747696', '36747710', '36747724', '36747738',\n        // '36747752', '36747766', '36747780', '36747794', '36747808', '36747822',\n        // '36747836', '36747850', '36747864', '36747878', '36747892', '36747906',\n        // '36747920', '36747934', '36747948', '36747962', '36747976', '36747990',\n        // '36748004', '36748018', '36748032', '36748046', '36748060', '36748074',\n        // '36748088', '36748102', '36748116', '36748130', '36748144', '36748158',\n        // '36748172', '36748186', '36748200', '36748214', '36748228', '36748242',\n        // '36748256', '36748270', '36748284', '36748298', '36748312', '36748326',\n        // '36748340', '36748354', '36748368', '36748382', '36748396', '36748410',\n        // '36748424', '36748438', '36748452', '36748466', '36748480', '36748494',\n        // '36748508', '36748522', '36748578', '36748592', '36748606', '36748620',\n        // '36748634', '36748648', '36748662', '36748676', '36748690', '36748704',\n        // '36748718', '36748732', '36748746', '36748760', '36748774', '36748788',\n        // '36748802', '36748816', '36748830', '36748844', '36748858', '36748872',\n        // '36748886', '36748900', '36748914', '36748928', '36748942', '36748956',\n        // '36748970', '36748984', '36748998', '36749012', '36749026', '36749040',\n        // '36749054', '36749068', '36749082', '36749096', '36749110', '36749124',\n        // '36749138', '36749152', '36749166', '36749180', '36749194', '36749208',\n        // '36749222', '36749236', '36749250', '36749264', '36749278', '36749292',\n        // '36749306', '36749320', '36749334', '36749348', '36749362', '36749376',\n        // '36749390', '36749404', '36749418', '36749432', '36749446', '36749460',\n        // '36749474', '36749488', '36749502', '36749516', '36749530', '36749544',\n        // '36749558', '36749572', '36749586', '36749600', '36749614', '36749628',\n        // '36749642', '36749656', '36749670', '36749684', '36749698', '36749712',\n        // '36749726', '36749740', '36749754', '36749768', '36749782', '36749796',\n        '36749810', '36749824', '36749838', '36749852', '36749866', '36749880',\n        '36749894', '36749908', '36749922', '36749936', '36749950', '36749964'\n    ];\n\n    var files = filenames.map(function(v) {\n        return '../../data/dcm/adi/' + v;\n    });\n\n    window.console.log(files);\n\n    function loadClosure(filename) {\n        var loader = new vjsLoaderDicom(manager);\n        loader.load(\n            filename,\n            // on load\n            function(imageHelper) {\n                // should it just return an image model?\n                // add image helper to scene\n                seriesHelper.push(imageHelper);\n            },\n            // progress\n            function() {\n                window.console.log(filename);\n                onProgressCallback(event, filename);\n            },\n            // error\n            function(message) {\n                window.console.log('error: ', message);\n            }\n        );\n    }\n\n    for (var k = 0; k < files.length; k++) {\n        loadClosure(files[k]);\n    }\n};\n\n},{\"../../modules/controls/OrbitControls2D\":2,\"../../modules/loaders/loaders.dicom\":6,\"../../modules/widgets/widgets.orientation\":12,\"../../modules/widgets/widgets.pixelProbe\":13}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n\n},{\"../core/Intersections\":3}],5:[function(require,module,exports){\n'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n\n},{\"../geometries/geometries.slice\":4,\"../shaders/shaders.data\":11}],6:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n\n},{\"../helpers/helpers.series\":5,\"../models/models.frame\":7,\"../models/models.series\":8,\"../models/models.stack\":9,\"../parsers/parsers.dicom\":10}],7:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n\n},{}],10:[function(require,module,exports){\n/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n\n},{\"dicom-parser\":14}],11:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\nVJS.widgets.orientation = function(parentID, targetCamera, targetControl) {\n    this._ParentId = parentID;\n    this._TargetCamera = targetCamera;\n    this._TargetControl = targetControl;\n    this._DomElement = null;\n    this._Renderer = null;\n    this._Scene = null;\n    this._Camera = null;\n    this._Axes = null;\n\n    this._Style = {\n        width: 200,\n        height: 200\n    };\n\n    this.createDomContainer();\n    this.setupObject();\n};\n\nVJS.widgets.orientation.prototype.createDomContainer = function() {\n\n    // create it\n    this._DomElement = document.createElement('div');\n    this._DomElement.setAttribute('id', 'VJSOrientation');\n\n    // style it\n    this._DomElement.style.width = this._Style.width + 'px';\n    this._DomElement.style.height = this._Style.height + 'px';\n\n    // attach it\n    var parent = document.getElementById(this._ParentId);\n    parent.appendChild(this._DomElement);\n};\n\nVJS.widgets.orientation.prototype.setupObject = function() {\n    this._Renderer = new THREE.WebGLRenderer({\n        alpha: true\n    });\n    this._Renderer.setClearColor(0x000000, 0);\n    this._Renderer.setSize(this._Style.width, this._Style.height);\n    this._DomElement.appendChild(this._Renderer.domElement);\n\n    this._Scene = new THREE.Scene();\n\n    // camera\n    this._Camera = new THREE.PerspectiveCamera(50, this._Style.width / this._Style.height, 1, 1000);\n    this._Camera.up = this._TargetCamera.up; // important!\n\n    // axes\n    this._Axes = new THREE.AxisHelper(100);\n    this._Scene.add(this._Axes);\n};\n\n\n\nVJS.widgets.orientation.prototype.update = function() {\n    // call to render!\n    this._Camera.position.copy(this._TargetCamera.position);\n    this._Camera.position.sub(this._TargetControl.target); // added by @libe\n    this._Camera.position.setLength(300);\n\n    this._Camera.lookAt(this._Scene.position);\n\n    this._Renderer.render(this._Scene, this._Camera);\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.orientation;\n\n// // create arrow helper scene\n//     // scene\n// var scene2 = new THREE.Scene();\n// // camera\n// var camera2 = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n// camera2.position.x = -30;\n// camera2.up.set(0, 0, 1);\n// camera2.lookAt(scene2.position);\n// // controls\n// controls2 = new THREE.OrbitControls2D(camera2, renderer.domElement);\n// controls2.noZoom = true;\n// controls2.noPan = true;\n// // direction (normalized), origin, length, color(hex)\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(10, 0, 0);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var r = new THREE.ArrowHelper(direction, origin, 5, 0xF44336);\n// scene2.add(r);\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(0, 10, 0);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var a = new THREE.ArrowHelper(direction, origin, 5, 0x2196F3);\n// scene2.add(a);\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(0, 0, 10);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var s = new THREE.ArrowHelper(direction, origin, 5, 0x4CAF50);\n// scene2.add(s);\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\n/**\n *\n * It is typically used to get information about an image from the mouse cursor.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#widget_pixelProbe}\n *\n * @constructor\n * @class\n * @memberOf VJS.widgets\n * @public\n *\n */\nVJS.widgets.pixelProbe = function(image, imageMeshes) {\n    // it is an object 3D that we can add to the scene :)\n    THREE.Object3D.call(this);\n\n    this.domElement = null;\n    this.rasContainer = null;\n    this.ijkContainer = null;\n    this.valueContainer = null;\n\n    this.imageMeshes = imageMeshes;\n    this.image = image;\n\n    this.volumeCore = null;\n\n    this.marks = [];\n\n    this.createDomElement();\n\n    this._worldCoordinate = null; //LPS\n    this._dataCoordinate = null; //IJK\n    this._dataValue = null; //\n    this._labelValue = null; //\n};\n\nVJS.widgets.pixelProbe.prototype = Object.create(THREE.Object3D.prototype);\nVJS.widgets.pixelProbe.prototype.constructor = VJS.widgets.pixelProbe;\n\nVJS.widgets.pixelProbe.prototype.createDomElement = function() {\n\n    // RAS\n    this.rasContainer = document.createElement('div');\n    this.rasContainer.setAttribute('id', 'VJSProbeRAS');\n\n    // IJK\n    this.ijkContainer = document.createElement('div');\n    this.ijkContainer.setAttribute('id', 'VJSProbeIJK');\n\n    // Value\n    this.valueContainer = document.createElement('div');\n    this.valueContainer.setAttribute('id', 'VJSProbeValue');\n\n    this.domElement = document.createElement('div');\n    this.domElement.setAttribute('id', 'VJSProbe');\n    this.domElement.appendChild(this.rasContainer);\n    this.domElement.appendChild(this.ijkContainer);\n    this.domElement.appendChild(this.valueContainer);\n};\n\nVJS.widgets.pixelProbe.prototype.computeValues = function() {\n    // convert point to IJK\n    if (this.image) {\n        var worldToData = this.image._stack[0]._lps2IJK;\n\n        var dataCoordinate = new THREE.Vector3().copy(this._worldCoordinate).applyMatrix4(worldToData);\n        var temp = dataCoordinate.clone();\n\n        // same rounding in the shaders\n        dataCoordinate.x = Math.floor(dataCoordinate.x + 0.5);\n        dataCoordinate.y = Math.floor(dataCoordinate.y + 0.5);\n        dataCoordinate.z = Math.floor(dataCoordinate.z + 0.5);\n        this._dataCoordinate = dataCoordinate;\n\n        if (dataCoordinate.x >= 0 &&\n            dataCoordinate.y >= 0 &&\n            dataCoordinate.z >= 0) {\n            // var textureSize = this.image._stack[0]._textureSize;\n            var rows = this.image._stack[0]._rows;\n            var columns = this.image._stack[0]._columns;\n\n            // var index = this._dataCoordinate.x + columns * this._dataCoordinate.y + rows * columns * this._dataCoordinate.z;\n\n            // var textureIndex = Math.floor(index / (textureSize * textureSize));\n            // var inTextureIndex = index % (textureSize * textureSize);\n\n            this._dataValue = this.image._stack[0]._frame[this._dataCoordinate.z]._pixelData[this._dataCoordinate.x + columns * this._dataCoordinate.y];\n        } else {\n            window.console.log('something funny happening in compute value');\n            window.console.log(dataCoordinate);\n            window.console.log(temp);\n        }\n    }\n};\n\nVJS.widgets.pixelProbe.prototype.updateUI = function(mouse) {\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    this.rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    this.ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    var valueContent = this._dataValue;\n    this.valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // position of the div...\n    // need a mode to track the mouse\n    document.getElementById('VJSProbe').style.display = 'block';\n    document.getElementById('VJSProbe').style.top = mouse.clientY + 10;\n    document.getElementById('VJSProbe').style.left = mouse.clientX + 10;\n\n};\n\nVJS.widgets.pixelProbe.prototype.update = function(raycaster, mouse, camera, canvas) {\n\n    if (!this.imageMeshes) {\n        return;\n    }\n\n    this.updateMarkDom(raycaster, mouse, camera, canvas);\n\n    // calculate image intersecting the picking ray\n    var intersects = raycaster.intersectObjects(this.imageMeshes);\n\n    for (var intersect in intersects) {\n        var worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect].object.material.type === 'ShaderMaterial') {\n            this._worldCoordinate = worldCoordinates;\n            // window.console.log(this._worldCoordinate);\n            this.computeValues();\n            this.updateUI(mouse);\n            return;\n        }\n    }\n\n    // hide UI if not intersecting the planne\n    this.hideUI();\n};\n\nVJS.widgets.pixelProbe.prototype.hideUI = function() {\n    document.getElementById('VJSProbe').style.display = 'none';\n};\n\nVJS.widgets.pixelProbe.prototype.mark = function(raycaster, mouse) {\n    // calculate image intersecting against itself (ideally N spheres)\n    // no all good yet, because we can click on Shader Materail and still\n    // intersect another voxel if looking at plane from the side\n    // do we intersect a cube of the probe (in front of the plane not detected yet...)\n    var intersects = raycaster.intersectObjects(this.children);\n    var worldCoordinates = null;\n    // Look for a pixelProbeMark\n    // for (var intersect in intersects) {\n    //   worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n    //   // if on a mark, do not do anything\n    //   if (intersects[intersect].object.name === 'pixelProbeMark') {\n    //     window.console.log('intersect pixelProbeMark!');\n\n    //     return null;\n    //   }\n    // }\n\n    // Look for intersection against image\n    window.console.log(this);\n    intersects = raycaster.intersectObjects(this.imageMeshes);\n    for (var intersect2 in intersects) {\n        worldCoordinates = new THREE.Vector3().copy(intersects[intersect2].point);\n\n        // might be better to re-loop\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect2].object.material.type === 'ShaderMaterial') {\n            window.console.log('intersect shader material!');\n            this._worldCoordinate = worldCoordinates;\n            this.computeValues();\n\n            // make sure this IJK mark is not already shown...\n            for (var i = 0; i < this.marks.length; i++) {\n                if (this.marks[i].ijk.x === this._dataCoordinate.x &&\n                    this.marks[i].ijk.y === this._dataCoordinate.y &&\n                    this.marks[i].ijk.z === this._dataCoordinate.z) {\n                    return;\n                }\n            }\n\n            // create the geometry for it!\n            // var sphereGeometry = new THREE.SphereGeometry(1);\n            // var material = new THREE.MeshBasicMaterial({\n            //     // not selected: amber? #FFC107\n            //     // orange? #FF9800\n            //     // selected: deep orange? #FF5722\n            //     color: 0xFF5722\n            //   });\n            // var sphere = new THREE.Mesh(sphereGeometry, material);\n            // sphere.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n\n            // position against World Voxel Center! Not against the mouse!!\n            var dataToWorld = this.image._stack[0]._ijk2LPS;\n            var worldCenterCoordinate = new THREE.Vector3()\n                .copy(this._dataCoordinate)\n                .applyMatrix4(dataToWorld);\n\n            var voxDataCoord = this._dataCoordinate.clone();\n\n            var voxelGeometry = new THREE.BoxGeometry(1, 1, 1);\n            voxelGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n                this._dataCoordinate.x,\n                this._dataCoordinate.y,\n                this._dataCoordinate.z));\n            voxelGeometry.applyMatrix(this.image._stack[0]._ijk2LPS);\n            var voxelMaterial = new THREE.MeshBasicMaterial({\n                wireframe: true,\n                color: 0xFFC107\n            });\n            var voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);\n            // move to world space!\n            // voxel.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n            voxel.name = 'pixelProbeMark';\n            this.add(voxel);\n\n            // store mark\n            var mark = {\n                id: voxel.id,\n                position: worldCenterCoordinate,\n                ijk: voxDataCoord\n            };\n            this.marks.push(mark);\n            window.console.log(this.marks);\n\n            var domElement = this.markDom(mark, mouse);\n\n            return domElement;\n        }\n    }\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.markDom = function(mark, mouse) {\n\n    // that could be a web-component!\n    // RAS\n    var rasContainer = document.createElement('div');\n    rasContainer.setAttribute('class', 'VJSProbeRAS');\n\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    // IJK\n    var ijkContainer = document.createElement('div');\n    ijkContainer.setAttribute('class', 'VJSProbeIJK');\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    // Value\n    var valueContainer = document.createElement('div');\n    valueContainer.setAttribute('class', 'VJSProbeValue');\n\n    var valueContent = this._dataValue;\n    valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // Package everything\n    var domElement = document.createElement('div');\n    domElement.setAttribute('id', 'mark' + mark.id);\n    domElement.setAttribute('class', 'mark');\n    domElement.appendChild(rasContainer);\n    domElement.appendChild(ijkContainer);\n    domElement.appendChild(valueContainer);\n\n    domElement.style.display = 'block';\n    domElement.style.top = mouse.clientY + 10;\n    domElement.style.left = mouse.clientX + 10;\n\n    return domElement;\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.updateMarkDom = function(raycaster, mouse, camera, canvas) {\n\n    for (var i = 0; i < this.marks.length; i++) {\n        // find element in DOM!\n        // world coordinates to screen\n        var screenCoordinates = this.marks[i].position.clone();\n        screenCoordinates.project(camera);\n\n        screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);\n        screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);\n        screenCoordinates.z = 0;\n\n        // update div position\n        // window.console.log(document.getElementById('mark' + this.marks[i].id));\n        document.getElementById('mark' + this.marks[i].id).style.top = screenCoordinates.y + 10;\n        document.getElementById('mark' + this.marks[i].id).style.left = screenCoordinates.x + 10;\n\n    }\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.pixelProbe;\n},{}],14:[function(require,module,exports){\n/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));\n},{}]},{},[1])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsProbePixelWidget = require('../../modules/widgets/widgets.pixelProbe');\nvar vjsOrientationWidget = require('../../modules/widgets/widgets.orientation');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, dat, probe, raycaster, mouse, orientation;\n\n// FUNCTIONS\nfunction onProgressCallback(evt, filename) {\n    var percentComplete = Math.round((evt.loaded / evt.total) * 100);\n\n    window.console.log(filename);\n\n    var fileContainer = document.getElementById(filename);\n    if (!fileContainer) {\n        var progressContainer = document.getElementById('my-progress-container');\n        var div = document.createElement('div');\n        div.setAttribute('id', filename);\n        div.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n\n        progressContainer.appendChild(div);\n    } else {\n        fileContainer.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n    }\n}\n\nfunction init() {\n\n    function onDocumentMouseMove(event) {\n        // calculate mouse position in normalized device coordinates\n        // (-1 to +1) for both components\n        mouse.x = (event.clientX / threeD.offsetWidth) * 2 - 1;\n        mouse.y = -(event.clientY / threeD.offsetHeight) * 2 + 1;\n        mouse.clientX = event.clientX;\n        mouse.clientY = event.clientY;\n    }\n\n    function onDocumentMouseDown(event) {\n        event.preventDefault();\n\n        // create/select handle\n        raycaster.setFromCamera(mouse, camera);\n        // name???\n        var domElement = probe.mark(raycaster, mouse);\n        if (domElement) {\n            var threeD = document.getElementById('r3d');\n            threeD.appendChild(domElement);\n        }\n\n    }\n\n    // this function is executed on each animation frame\n    function animate() {\n        // image probe widget\n        if (mouse && raycaster && probe) {\n            raycaster.setFromCamera(mouse, camera);\n            probe.update(raycaster, mouse, camera, threeD);\n        }\n\n        orientation.update();\n        controls.update();\n        renderer.render(scene, camera);\n        stats.update();\n\n        // request new frame\n        requestAnimationFrame(function() {\n            animate();\n        });\n    }\n\n    // renderer\n    var threeD = document.getElementById('r3d');\n    renderer = new THREE.WebGLRenderer({\n        antialias: true\n    });\n    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n    renderer.setClearColor(0xFFFFFF, 1);\n\n    var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n    window.console.log(maxTextureSize);\n\n    threeD.appendChild(renderer.domElement);\n\n    // stats\n    stats = new Stats();\n    threeD.appendChild(stats.domElement);\n\n    // scene\n    scene = new THREE.Scene();\n    // camera\n    camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n    camera.position.x = 150;\n    camera.position.y = 150;\n    camera.position.z = 100;\n    camera.lookAt(scene.position);\n    // controls\n    controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n    // orientation widget\n    orientation = new vjsOrientationWidget('r3d', camera, controls);\n\n    //\n    // mouse callbacks\n    raycaster = new THREE.Raycaster();\n    mouse = new THREE.Vector2();\n    renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n    renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n\n    animate();\n}\n\nwindow.onload = function() {\n\n    // init threeJS...\n    init();\n\n    window.console.log(dat);\n\n    // Create Box\n    var geometry = new THREE.BoxGeometry(500, 500, 500);\n    var material = new THREE.MeshBasicMaterial({\n        wireframe: true,\n        color: 0x607D8B\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    scene.add(cube);\n\n    // create loader manager (to keep track of progress over N files...)\n    // might not be useful with promises anymore.\n\n    // can not promise do it for us??\n    var seriesHelper = [];\n    var manager = new THREE.LoadingManager();\n    manager.onProgress = function(item, loaded, total) {\n        window.console.log('manager progress ----');\n        window.console.log(item);\n        var fileContainer = document.getElementById(item);\n        if (fileContainer) {\n            fileContainer.innerHTML = ' ' + item + ' is ready! ' + '(' + loaded + '/' + total + ')';\n        }\n\n        if (loaded === total) {\n            window.console.log(seriesHelper);\n            var mergedHelpers = [seriesHelper[0]];\n            // if all files loaded\n            for (var i = 0; i < seriesHelper.length; i++) {\n                // test image against existing imagess\n                for (var j = 0; j < mergedHelpers.length; j++) {\n                    if (mergedHelpers[j].merge(seriesHelper[i])) {\n                        // merged successfully\n                        break;\n                    } else if (j === mergedHelpers.length - 1) {\n                        // last merge was not successful\n                        // this is a new image\n                        mergedHelpers.push(seriesHelper[i]);\n                    }\n                }\n            }\n\n            mergedHelpers[0].prepare();\n            scene.add(mergedHelpers[0]);\n\n            probe = new vjsProbePixelWidget(mergedHelpers[0]._series, mergedHelpers[0].children);\n            scene.add(probe);\n\n            var threeD = document.getElementById('r3d');\n            threeD.appendChild(probe.domElement);\n\n        }\n    };\n\n    var filenames = [\n        // '36444280', '36444294', '36444308', '36444322', '36444336', '36444350',\n        // '36444364', '36444378', '36444392', '36444406', '36444420', '36444434',\n        // '36444448', '36444462', '36444476', '36444490', '36444504', '36444518',\n        // '36444532', '36746856', '36746870', '36746884', '36746898', '36746912',\n        // '36746926', '36746940', '36746954', '36746968', '36746982', '36746996',\n        // '36747010', '36747024', '36747043', '36747062', '36747136', '36747150',\n        // '36747164', '36747178', '36747192', '36747206', '36747220', '36747234',\n        // '36747248', '36747262', '36747276', '36747290', '36747304', '36747318',\n        // '36747332', '36747346', '36747360', '36747374', '36747388', '36747402',\n        // '36747416', '36747430', '36747444', '36747458', '36747472', '36747486',\n        // '36747500', '36747514', '36747528', '36747542', '36747556', '36747570',\n        // '36747584', '36747598', '36747612', '36747626', '36747640', '36747654',\n        // '36747668', '36747682', '36747696', '36747710', '36747724', '36747738',\n        // '36747752', '36747766', '36747780', '36747794', '36747808', '36747822',\n        // '36747836', '36747850', '36747864', '36747878', '36747892', '36747906',\n        // '36747920', '36747934', '36747948', '36747962', '36747976', '36747990',\n        // '36748004', '36748018', '36748032', '36748046', '36748060', '36748074',\n        // '36748088', '36748102', '36748116', '36748130', '36748144', '36748158',\n        // '36748172', '36748186', '36748200', '36748214', '36748228', '36748242',\n        // '36748256', '36748270', '36748284', '36748298', '36748312', '36748326',\n        // '36748340', '36748354', '36748368', '36748382', '36748396', '36748410',\n        // '36748424', '36748438', '36748452', '36748466', '36748480', '36748494',\n        // '36748508', '36748522', '36748578', '36748592', '36748606', '36748620',\n        // '36748634', '36748648', '36748662', '36748676', '36748690', '36748704',\n        // '36748718', '36748732', '36748746', '36748760', '36748774', '36748788',\n        // '36748802', '36748816', '36748830', '36748844', '36748858', '36748872',\n        // '36748886', '36748900', '36748914', '36748928', '36748942', '36748956',\n        // '36748970', '36748984', '36748998', '36749012', '36749026', '36749040',\n        // '36749054', '36749068', '36749082', '36749096', '36749110', '36749124',\n        // '36749138', '36749152', '36749166', '36749180', '36749194', '36749208',\n        // '36749222', '36749236', '36749250', '36749264', '36749278', '36749292',\n        // '36749306', '36749320', '36749334', '36749348', '36749362', '36749376',\n        // '36749390', '36749404', '36749418', '36749432', '36749446', '36749460',\n        // '36749474', '36749488', '36749502', '36749516', '36749530', '36749544',\n        // '36749558', '36749572', '36749586', '36749600', '36749614', '36749628',\n        // '36749642', '36749656', '36749670', '36749684', '36749698', '36749712',\n        // '36749726', '36749740', '36749754', '36749768', '36749782', '36749796',\n        '36749810', '36749824', '36749838', '36749852', '36749866', '36749880',\n        '36749894', '36749908', '36749922', '36749936', '36749950', '36749964'\n    ];\n\n    var files = filenames.map(function(v) {\n        return '../../data/dcm/adi/' + v;\n    });\n\n    window.console.log(files);\n\n    function loadClosure(filename) {\n        var loader = new vjsLoaderDicom(manager);\n        loader.load(\n            filename,\n            // on load\n            function(imageHelper) {\n                // should it just return an image model?\n                // add image helper to scene\n                seriesHelper.push(imageHelper);\n            },\n            // progress\n            function() {\n                window.console.log(filename);\n                onProgressCallback(event, filename);\n            },\n            // error\n            function(message) {\n                window.console.log('error: ', message);\n            }\n        );\n    }\n\n    for (var k = 0; k < files.length; k++) {\n        loadClosure(files[k]);\n    }\n};\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n","'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n","'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n","'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n","/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\nVJS.widgets.orientation = function(parentID, targetCamera, targetControl) {\n    this._ParentId = parentID;\n    this._TargetCamera = targetCamera;\n    this._TargetControl = targetControl;\n    this._DomElement = null;\n    this._Renderer = null;\n    this._Scene = null;\n    this._Camera = null;\n    this._Axes = null;\n\n    this._Style = {\n        width: 200,\n        height: 200\n    };\n\n    this.createDomContainer();\n    this.setupObject();\n};\n\nVJS.widgets.orientation.prototype.createDomContainer = function() {\n\n    // create it\n    this._DomElement = document.createElement('div');\n    this._DomElement.setAttribute('id', 'VJSOrientation');\n\n    // style it\n    this._DomElement.style.width = this._Style.width + 'px';\n    this._DomElement.style.height = this._Style.height + 'px';\n\n    // attach it\n    var parent = document.getElementById(this._ParentId);\n    parent.appendChild(this._DomElement);\n};\n\nVJS.widgets.orientation.prototype.setupObject = function() {\n    this._Renderer = new THREE.WebGLRenderer({\n        alpha: true\n    });\n    this._Renderer.setClearColor(0x000000, 0);\n    this._Renderer.setSize(this._Style.width, this._Style.height);\n    this._DomElement.appendChild(this._Renderer.domElement);\n\n    this._Scene = new THREE.Scene();\n\n    // camera\n    this._Camera = new THREE.PerspectiveCamera(50, this._Style.width / this._Style.height, 1, 1000);\n    this._Camera.up = this._TargetCamera.up; // important!\n\n    // axes\n    this._Axes = new THREE.AxisHelper(100);\n    this._Scene.add(this._Axes);\n};\n\n\n\nVJS.widgets.orientation.prototype.update = function() {\n    // call to render!\n    this._Camera.position.copy(this._TargetCamera.position);\n    this._Camera.position.sub(this._TargetControl.target); // added by @libe\n    this._Camera.position.setLength(300);\n\n    this._Camera.lookAt(this._Scene.position);\n\n    this._Renderer.render(this._Scene, this._Camera);\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.orientation;\n\n// // create arrow helper scene\n//     // scene\n// var scene2 = new THREE.Scene();\n// // camera\n// var camera2 = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n// camera2.position.x = -30;\n// camera2.up.set(0, 0, 1);\n// camera2.lookAt(scene2.position);\n// // controls\n// controls2 = new THREE.OrbitControls2D(camera2, renderer.domElement);\n// controls2.noZoom = true;\n// controls2.noPan = true;\n// // direction (normalized), origin, length, color(hex)\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(10, 0, 0);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var r = new THREE.ArrowHelper(direction, origin, 5, 0xF44336);\n// scene2.add(r);\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(0, 10, 0);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var a = new THREE.ArrowHelper(direction, origin, 5, 0x2196F3);\n// scene2.add(a);\n// var origin = new THREE.Vector3(0, 0, 0);\n// var terminus = new THREE.Vector3(0, 0, 10);\n// var direction = new THREE.Vector3().subVectors(terminus, origin).normalize();\n// var s = new THREE.ArrowHelper(direction, origin, 5, 0x4CAF50);\n// scene2.add(s);\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\n/**\n *\n * It is typically used to get information about an image from the mouse cursor.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#widget_pixelProbe}\n *\n * @constructor\n * @class\n * @memberOf VJS.widgets\n * @public\n *\n */\nVJS.widgets.pixelProbe = function(image, imageMeshes) {\n    // it is an object 3D that we can add to the scene :)\n    THREE.Object3D.call(this);\n\n    this.domElement = null;\n    this.rasContainer = null;\n    this.ijkContainer = null;\n    this.valueContainer = null;\n\n    this.imageMeshes = imageMeshes;\n    this.image = image;\n\n    this.volumeCore = null;\n\n    this.marks = [];\n\n    this.createDomElement();\n\n    this._worldCoordinate = null; //LPS\n    this._dataCoordinate = null; //IJK\n    this._dataValue = null; //\n    this._labelValue = null; //\n};\n\nVJS.widgets.pixelProbe.prototype = Object.create(THREE.Object3D.prototype);\nVJS.widgets.pixelProbe.prototype.constructor = VJS.widgets.pixelProbe;\n\nVJS.widgets.pixelProbe.prototype.createDomElement = function() {\n\n    // RAS\n    this.rasContainer = document.createElement('div');\n    this.rasContainer.setAttribute('id', 'VJSProbeRAS');\n\n    // IJK\n    this.ijkContainer = document.createElement('div');\n    this.ijkContainer.setAttribute('id', 'VJSProbeIJK');\n\n    // Value\n    this.valueContainer = document.createElement('div');\n    this.valueContainer.setAttribute('id', 'VJSProbeValue');\n\n    this.domElement = document.createElement('div');\n    this.domElement.setAttribute('id', 'VJSProbe');\n    this.domElement.appendChild(this.rasContainer);\n    this.domElement.appendChild(this.ijkContainer);\n    this.domElement.appendChild(this.valueContainer);\n};\n\nVJS.widgets.pixelProbe.prototype.computeValues = function() {\n    // convert point to IJK\n    if (this.image) {\n        var worldToData = this.image._stack[0]._lps2IJK;\n\n        var dataCoordinate = new THREE.Vector3().copy(this._worldCoordinate).applyMatrix4(worldToData);\n        var temp = dataCoordinate.clone();\n\n        // same rounding in the shaders\n        dataCoordinate.x = Math.floor(dataCoordinate.x + 0.5);\n        dataCoordinate.y = Math.floor(dataCoordinate.y + 0.5);\n        dataCoordinate.z = Math.floor(dataCoordinate.z + 0.5);\n        this._dataCoordinate = dataCoordinate;\n\n        if (dataCoordinate.x >= 0 &&\n            dataCoordinate.y >= 0 &&\n            dataCoordinate.z >= 0) {\n            // var textureSize = this.image._stack[0]._textureSize;\n            var rows = this.image._stack[0]._rows;\n            var columns = this.image._stack[0]._columns;\n\n            // var index = this._dataCoordinate.x + columns * this._dataCoordinate.y + rows * columns * this._dataCoordinate.z;\n\n            // var textureIndex = Math.floor(index / (textureSize * textureSize));\n            // var inTextureIndex = index % (textureSize * textureSize);\n\n            this._dataValue = this.image._stack[0]._frame[this._dataCoordinate.z]._pixelData[this._dataCoordinate.x + columns * this._dataCoordinate.y];\n        } else {\n            window.console.log('something funny happening in compute value');\n            window.console.log(dataCoordinate);\n            window.console.log(temp);\n        }\n    }\n};\n\nVJS.widgets.pixelProbe.prototype.updateUI = function(mouse) {\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    this.rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    this.ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    var valueContent = this._dataValue;\n    this.valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // position of the div...\n    // need a mode to track the mouse\n    document.getElementById('VJSProbe').style.display = 'block';\n    document.getElementById('VJSProbe').style.top = mouse.clientY + 10;\n    document.getElementById('VJSProbe').style.left = mouse.clientX + 10;\n\n};\n\nVJS.widgets.pixelProbe.prototype.update = function(raycaster, mouse, camera, canvas) {\n\n    if (!this.imageMeshes) {\n        return;\n    }\n\n    this.updateMarkDom(raycaster, mouse, camera, canvas);\n\n    // calculate image intersecting the picking ray\n    var intersects = raycaster.intersectObjects(this.imageMeshes);\n\n    for (var intersect in intersects) {\n        var worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect].object.material.type === 'ShaderMaterial') {\n            this._worldCoordinate = worldCoordinates;\n            // window.console.log(this._worldCoordinate);\n            this.computeValues();\n            this.updateUI(mouse);\n            return;\n        }\n    }\n\n    // hide UI if not intersecting the planne\n    this.hideUI();\n};\n\nVJS.widgets.pixelProbe.prototype.hideUI = function() {\n    document.getElementById('VJSProbe').style.display = 'none';\n};\n\nVJS.widgets.pixelProbe.prototype.mark = function(raycaster, mouse) {\n    // calculate image intersecting against itself (ideally N spheres)\n    // no all good yet, because we can click on Shader Materail and still\n    // intersect another voxel if looking at plane from the side\n    // do we intersect a cube of the probe (in front of the plane not detected yet...)\n    var intersects = raycaster.intersectObjects(this.children);\n    var worldCoordinates = null;\n    // Look for a pixelProbeMark\n    // for (var intersect in intersects) {\n    //   worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n    //   // if on a mark, do not do anything\n    //   if (intersects[intersect].object.name === 'pixelProbeMark') {\n    //     window.console.log('intersect pixelProbeMark!');\n\n    //     return null;\n    //   }\n    // }\n\n    // Look for intersection against image\n    window.console.log(this);\n    intersects = raycaster.intersectObjects(this.imageMeshes);\n    for (var intersect2 in intersects) {\n        worldCoordinates = new THREE.Vector3().copy(intersects[intersect2].point);\n\n        // might be better to re-loop\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect2].object.material.type === 'ShaderMaterial') {\n            window.console.log('intersect shader material!');\n            this._worldCoordinate = worldCoordinates;\n            this.computeValues();\n\n            // make sure this IJK mark is not already shown...\n            for (var i = 0; i < this.marks.length; i++) {\n                if (this.marks[i].ijk.x === this._dataCoordinate.x &&\n                    this.marks[i].ijk.y === this._dataCoordinate.y &&\n                    this.marks[i].ijk.z === this._dataCoordinate.z) {\n                    return;\n                }\n            }\n\n            // create the geometry for it!\n            // var sphereGeometry = new THREE.SphereGeometry(1);\n            // var material = new THREE.MeshBasicMaterial({\n            //     // not selected: amber? #FFC107\n            //     // orange? #FF9800\n            //     // selected: deep orange? #FF5722\n            //     color: 0xFF5722\n            //   });\n            // var sphere = new THREE.Mesh(sphereGeometry, material);\n            // sphere.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n\n            // position against World Voxel Center! Not against the mouse!!\n            var dataToWorld = this.image._stack[0]._ijk2LPS;\n            var worldCenterCoordinate = new THREE.Vector3()\n                .copy(this._dataCoordinate)\n                .applyMatrix4(dataToWorld);\n\n            var voxDataCoord = this._dataCoordinate.clone();\n\n            var voxelGeometry = new THREE.BoxGeometry(1, 1, 1);\n            voxelGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n                this._dataCoordinate.x,\n                this._dataCoordinate.y,\n                this._dataCoordinate.z));\n            voxelGeometry.applyMatrix(this.image._stack[0]._ijk2LPS);\n            var voxelMaterial = new THREE.MeshBasicMaterial({\n                wireframe: true,\n                color: 0xFFC107\n            });\n            var voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);\n            // move to world space!\n            // voxel.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n            voxel.name = 'pixelProbeMark';\n            this.add(voxel);\n\n            // store mark\n            var mark = {\n                id: voxel.id,\n                position: worldCenterCoordinate,\n                ijk: voxDataCoord\n            };\n            this.marks.push(mark);\n            window.console.log(this.marks);\n\n            var domElement = this.markDom(mark, mouse);\n\n            return domElement;\n        }\n    }\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.markDom = function(mark, mouse) {\n\n    // that could be a web-component!\n    // RAS\n    var rasContainer = document.createElement('div');\n    rasContainer.setAttribute('class', 'VJSProbeRAS');\n\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    // IJK\n    var ijkContainer = document.createElement('div');\n    ijkContainer.setAttribute('class', 'VJSProbeIJK');\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    // Value\n    var valueContainer = document.createElement('div');\n    valueContainer.setAttribute('class', 'VJSProbeValue');\n\n    var valueContent = this._dataValue;\n    valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // Package everything\n    var domElement = document.createElement('div');\n    domElement.setAttribute('id', 'mark' + mark.id);\n    domElement.setAttribute('class', 'mark');\n    domElement.appendChild(rasContainer);\n    domElement.appendChild(ijkContainer);\n    domElement.appendChild(valueContainer);\n\n    domElement.style.display = 'block';\n    domElement.style.top = mouse.clientY + 10;\n    domElement.style.left = mouse.clientX + 10;\n\n    return domElement;\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.updateMarkDom = function(raycaster, mouse, camera, canvas) {\n\n    for (var i = 0; i < this.marks.length; i++) {\n        // find element in DOM!\n        // world coordinates to screen\n        var screenCoordinates = this.marks[i].position.clone();\n        screenCoordinates.project(camera);\n\n        screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);\n        screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);\n        screenCoordinates.z = 0;\n\n        // update div position\n        // window.console.log(document.getElementById('mark' + this.marks[i].id));\n        document.getElementById('mark' + this.marks[i].id).style.top = screenCoordinates.y + 10;\n        document.getElementById('mark' + this.marks[i].id).style.left = screenCoordinates.x + 10;\n\n    }\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.pixelProbe;","/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));"],"sourceRoot":"/source/"}