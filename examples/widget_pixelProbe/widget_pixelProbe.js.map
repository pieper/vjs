{"version":3,"sources":["examples/widget_pixelProbe/widget_pixelProbe.js","examples/widget_pixelProbe/node_modules/browserify/node_modules/browser-pack/_prelude.js","examples/widget_pixelProbe/app/examples/widget_pixelProbe/widget_pixelProbe.js","examples/widget_pixelProbe/app/modules/controls/OrbitControls2D.js","examples/widget_pixelProbe/app/modules/core/Intersections.js","examples/widget_pixelProbe/app/modules/geometries/geometries.slice.js","examples/widget_pixelProbe/app/modules/helpers/helpers.series.js","examples/widget_pixelProbe/app/modules/loaders/loaders.dicom.js","examples/widget_pixelProbe/app/modules/models/models.frame.js","examples/widget_pixelProbe/app/modules/models/models.series.js","examples/widget_pixelProbe/app/modules/models/models.stack.js","examples/widget_pixelProbe/app/modules/parsers/parsers.dicom.js","examples/widget_pixelProbe/app/modules/shaders/shaders.data.js","examples/widget_pixelProbe/app/modules/widgets/widgets.pixelProbe.js","examples/widget_pixelProbe/node_modules/dicom-parser/dist/dicomParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","onProgressCallback","evt","filename","percentComplete","Math","round","loaded","total","window","console","log","fileContainer","document","getElementById","innerHTML","progressContainer","div","createElement","setAttribute","appendChild","init","onDocumentMouseMove","event","preventDefault","drag","mouse","x","clientX","threeD","offsetWidth","y","clientY","offsetHeight","onDocumentMouseDown","onDocumentMouseUp","raycaster","setFromCamera","camera","domElement","probe","mark","animate","update","controls","renderer","render","scene","stats","requestAnimationFrame","THREE","WebGLRenderer","antialias","setSize","setClearColor","maxTextureSize","context","getParameter","MAX_TEXTURE_SIZE","Stats","Scene","PerspectiveCamera","position","z","lookAt","vjsOrbitControl2D","Raycaster","Vector2","addEventListener","vjsProbePixelWidget","vjsLoaderDicom","onload","manager","LoadingManager","onProgress","item","file","loader","load","imageHelper","prepare","add","_image","children","message","../../modules/controls/OrbitControls2D","../../modules/loaders/loaders.dicom","../../modules/widgets/widgets.pixelProbe",2,"OrbitControls2D","object","getAutoRotationAngle","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","enabled","button","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","set","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","onMouseMove","onMouseUp","dispatchEvent","startEvent","element","body","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","removeEventListener","endEvent","onMouseWheel","stopPropagation","delta","undefined","wheelDelta","detail","onKeyDown","noKeys","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","touchend","this","target","Vector3","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MOUSE","MIDDLE","theta","phi","EPS","panOffset","offset","phiDelta","thetaDelta","scale","lastPosition","lastQuaternion","Quaternion","target0","clone","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","angle","panLeft","te","matrix","elements","multiplyScalar","panUp","deltaX","deltaY","fov","sub","targetDistance","tan","top","right","left","zoom","bottom","warn","dollyScale","updateProjectionMatrix","applyQuaternion","atan2","max","min","radius","sin","cos","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","prototype","Object","create","EventDispatcher","constructor",3,"VJS","intersections","obbPlane","obb","plane","t1","direction","applyMatrix4","toOBBSpace","t0","planeOBB","normalize","bboxMin","halfDimensions","bboxMax","ray","orientation","intersection","rayPlane","push","toOBBSpaceInvert",4,"vjsIntersections","geometries","slice","Matrix4","centerOfMass","orderedIntersections","orderIntersections","formatIntersections","formatIntersectionsXY","k","point","xy","sliceShape","Shape","moveTo","lineTo","ShapeGeometry","vertices","verticesNeedUpdate","points","divideScalar","reference","a0","b0","c0","x0","y0","z0","l0","origin","base","crossVectors","orderedpoints","j","a1","b1","c1","x1","y1","z1","l1","thetaAngle","sort","b","../core/Intersections",5,"vjsSliceGeometries","vjsShadersData","helpers","series","Object3D","_series","_uniforms","_frameIndex","_slice","_border","merge","seriesHelper","addSeries","getStack","stackIndex","stack","_stack","dimensions","_dimensions","_halfDimensions","geometry","BoxGeometry","applyMatrix","makeTranslation","_ijk2LPS","material","MeshBasicMaterial","wireframe","color","cube","Mesh","floor","sliceGeometry","textures","m","_nbTextures","tex","DataTexture","_rawData","_textureSize","RGBFormat","UnsignedByteType","UVMapping","ClampToEdgeWrapping","NearestFilter","needsUpdate","sliceMaterial","ShaderMaterial","side","DoubleSide","transparency","uniforms","parameters","vertexShader","fragmentShader","mySliceMaterial","uTextureSize","value","uTextureContainer","uDataDimensions","uWorldToData","_lps2IJK","uWindowLevel","_windowLevel","uNumberOfChannels","_numberOfChannels","uBitsAllocated","_bitsAllocated","uInvert","_invert","borderMaterial","LineBasicMaterial","polygonOffset","polygonOffsetFactor","borderGeometry","Geometry","Line","updateSliceGeometry","updateBorderGeometry","../geometries/geometries.slice","../shaders/shaders.data",6,"parsers","dicom","models","frame","loaders","DefaultLoadingManager","crossOrigin","responseType","_imageHelper","onLoad","onError","XHRLoader","setCrossOrigin","setResponseType","response","parse","dicomParser","id","_seriesInstanceUID","seriesInstanceUID","_numberOfFrames","numberOfFrames","numberOfChannels","_rows","rows","_columns","columns","_pixelData","extractPixelData","_pixelSpacing","pixelSpacing","_sliceThickness","sliceThickness","_imageOrientation","imageOrientation","_imagePosition","imagePosition","_dimensionIndexValues","dimensionIndexValues","bitsAllocated","_instanceNumber","instanceNumber","_minMax","minMaxPixelData","_frame","../helpers/helpers.series","../models/models.frame","../models/models.series","../models/models.stack","../parsers/parsers.dicom",7,"_id","_stackID","_imagePositionPatient","_imageOrientationPatient","row","column","_spacingBetweenSlices",8,"_concatenationUID","_seriesNumber","_dimensionIndexSequence","_photometricInterpretation","sameSeriesUID",9,"_uid","_origin","_orientation","_windowCenter","_windowWidth","_spacing","_direction","orderFrames","zSpacing","_pixelAspectRatio","xCosine","yCosine","zCosine","baseX","baseY","baseZ","getInverse","nbVoxels","ii","Uint8Array","frameDimension","textureDimension","time","jj","frameIndex","inFrameIndex","textureIndex","inTextureIndex","rawValue","lsb","msb","width","orderFrameOnDimensionIndices","toString","parseInt","computeDistance","normal","_dist","map","bind","sameStackID","join",10,"arrayBuffer","_arrayBuffer","byteArray","_dataSet","parseDicom","string","modality","sopInstanceUID","transferSyntaxUID","photometricInterpretation","planarConfiguration","uint16","samplesPerPixel","intString","perFrameFunctionnalGroupSequence","x52009230","planeOrientationSequence","items","dataSet","x00209116","split","Number","pixelAspectRatio","x00209113","x2005140f","x00289110","floatString","pixelRepresentation","highBit","rescaleIntercept","philipsPrivateSequence","x00289145","rescaleSlope","windowCenter","x00289132","windowWidth","x00209111","x00209157","nbValues","uint32","inStackPositionNumber","stackID","dPixelData","pixelDataElement","x7fe00010","buffer","dataOffset","ePixelData","pixelDataOffset","numPixels","frameOffset","Uint16Array","Int16Array","encodedPixelData","nPixels","ybrIndex","rgbaIndex","cb","cr","pixelData","minMax","index","spv","frameOfReferenceUID","imageJqueryDom","seriesNumber","find","text","dicom-parser",11,"shaders","data",12,"widgets","pixelProbe","image","imageMeshes","rasContainer","ijkContainer","valueContainer","volumeCore","marks","createDomElement","_worldCoordinate","_dataCoordinate","_dataValue","_labelValue","computeValues","worldToData","dataCoordinate","temp","updateUI","rasContent","toFixed","ijkContent","valueContent","style","display","canvas","updateMarkDom","intersects","intersectObjects","intersect","worldCoordinates","hideUI","intersect2","ijk","dataToWorld","worldCenterCoordinate","voxDataCoord","voxelGeometry","voxelMaterial","voxel","name","markDom","screenCoordinates","project",13,"root","factory","define","amd","Package","options","readPrefix","littleEndianByteStream","seek","prefix","readFixedString","readPart10Header","warnings","readDicomElementExplicit","tag","parser","littleEndianByteArrayParser","metaHeaderDataSet","DataSet","byteArrayParser","readTransferSyntax","x00020010","transferSyntaxElement","isExplicit","transferSyntax","getDataSetByteStream","ByteStream","bigEndianByteArrayParser","mergeDataSets","instanceDataSet","propertyName","hasOwnProperty","concat","readDataSet","explicit","dataSetByteStream","parseDicomDataSetExplicit","parseDicomDataSetImplicit","ex","exception","parseTheByteStream","readUint16","readInt16","int16","readUint32","readInt32","int32","readFloat","byteArrayForParsingFloat","floatArray","Float32Array","readDouble","Float64Array","result","byte","String","fromCharCode","readByteStream","numBytes","byteArrayView","getByteArrayParser","defaultParser","numStringValues","fixedString","numMatching","match","values","trim","replace","parseFloat","findEndOfEncapsulatedElement","byteStream","encapsulatedPixelData","basicOffsetTable","fragments","basicOffsetTableItemTag","readTag","basicOffsetTableItemlength","numFragments","baseOffset","findItemDelimitationItemAndSetElementLength","itemDelimitationItemLength","maxPosition","groupNumber","elementNumber","itemDelimiterLength","untilTag","readDicomElementImplicit","getDataLengthSizeInBytesForVR","vr","dataLengthSizeBytes","hadUndefinedLength","readSequenceItemsExplicit","nextTag","readSequenceItemsImplicit","getPixelDataFromFragments","bufferSize","pixelDataIndex","fragmentOffset","readFragmentsUntil","endOfFrame","fragment","readSequenceItem","readEncapsulatedPixelDataWithBasicOffsetTable","numFrames","endOfFrameOffset","readEncapsulatedDataNoBasicOffsetTable","readEncapsulatedPixelData","readDicomDataSetExplicitUndefinedLength","readSequenceItemExplicit","readSQElementUndefinedLengthExplicit","readSQElementKnownLengthExplicit","readDicomDataSetImplicitUndefinedLength","readSequenceItemImplicit","readSQElementUndefinedLengthImplicit","readSQElementKnownLengthImplicit","substr","explicitDataSetToJS","omitPrivateAttibutes","maxElementLength","isPrivateTag","sequenceItems","asString","explicitElementToString","multiElementToString","numItems","func","textResult","isStringVr","num","toUpperCase","stringVrs","AE","AS","AT","CS","DA","DS","DT","FL","FD","IS","LO","LT","OB","OD","OF","OW","PN","SH","SL","SQ","SS","ST","TM","UI","UL","UN","UR","US","UT","lastGroupDigit","groupIsOdd","parsePN","personName","stringValues","familyName","givenName","middleName","suffix","parseDA","date","yyyy","substring","mm","dd","year","month","day","parseTM","hh","ss","ffffff","hours","minutes","seconds","fractionalSeconds"],"mappings":"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","file":"examples/widget_pixelProbe/widget_pixelProbe.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsProbePixelWidget = require('../../modules/widgets/widgets.pixelProbe');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, probe, raycaster, mouse, drag;\n\n// FUNCTIONS\nfunction onProgressCallback(evt, filename) {\n  var percentComplete = Math.round((evt.loaded / evt.total) * 100);\n\n  window.console.log(filename);\n\n  var fileContainer = document.getElementById(filename);\n  if (!fileContainer) {\n    var progressContainer = document.getElementById('my-progress-container');\n    var div = document.createElement('div');\n    div.setAttribute('id', filename);\n    div.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n\n    progressContainer.appendChild(div);\n  } else {\n    fileContainer.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n  }\n}\n\nfunction init() {\n  function onDocumentMouseMove(event) {\n    event.preventDefault();\n\n    drag = 1;\n\n    // calculate mouse position in normalized device coordinates\n    // (-1 to +1) for both components\n    mouse.x = (event.clientX / threeD.offsetWidth) * 2 - 1;\n    mouse.y = -(event.clientY / threeD.offsetHeight) * 2 + 1;\n    mouse.clientX = event.clientX;\n    mouse.clientY = event.clientY;\n  }\n\n  function onDocumentMouseDown(event) {\n    event.preventDefault();\n\n    drag = 0;\n\n  }\n\n  function onDocumentMouseUp(event) {\n    event.preventDefault();\n\n    if (drag === 0) {\n      // create/select handle\n      raycaster.setFromCamera(mouse, camera);\n      // name???\n      var domElement = probe.mark(raycaster, mouse);\n      if (domElement) {\n        var threeD = document.getElementById('r3d');\n        threeD.appendChild(domElement);\n      }\n    }\n  }\n\n  // this function is executed on each animation frame\n  function animate() {\n\n    // image probe widget\n    if (mouse && raycaster && probe) {\n      raycaster.setFromCamera(mouse, camera);\n      probe.update(raycaster, mouse, camera, threeD);\n    }\n\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    stats.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  stats = new Stats();\n  threeD.appendChild(stats.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  \n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 150;\n  camera.position.y = 150;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  //\n  // mouse callbacks\n  raycaster = new THREE.Raycaster();\n  mouse = new THREE.Vector2();\n  renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n  renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n  renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);\n\n  animate();\n}\n\nwindow.onload = function() {\n  // init threeJS...\n  init();\n\n  // create loader manager (to keep track of progress over N files...)\n  // might not be useful with promises anymore.\n\n  // can not promise do it for us??\n  var manager = new THREE.LoadingManager();\n  manager.onProgress = function(item, loaded, total) {\n    window.console.log(item);\n    var fileContainer = document.getElementById(item);\n    if (fileContainer) {\n      fileContainer.innerHTML = ' ' + item + ' is ready! ' + '(' + loaded + '/' + total + ')';\n      // merge images!\n      // add it to the scene!\n    }\n  };\n\n  var file = '/data/dcm/adi/36749894';\n  //var file = '../../data/dcm/fruit';\n\n  // instantiate the loader\n  var loader = new vjsLoaderDicom(manager);\n  loader.load(\n      file,\n      // on load\n        function(imageHelper) {\n          // should it just return an image model?\n          // add image helper to scene\n          imageHelper.prepare();\n          scene.add(imageHelper);\n\n          probe = new vjsProbePixelWidget(imageHelper._image, imageHelper.children);\n          scene.add(probe);\n\n          var threeD = document.getElementById('r3d');\n          threeD.appendChild(probe.domElement);\n        },\n        // progress\n        function() {\n          onProgressCallback(event, file);\n        },\n        // error\n        function(message) {\n          window.console.log('error: ', message);\n        }\n    );\n\n  // use manager to deal with \"all loaded\"\n  // similar to promise all\n\n};\n\n},{\"../../modules/controls/OrbitControls2D\":2,\"../../modules/loaders/loaders.dicom\":6,\"../../modules/widgets/widgets.pixelProbe\":12}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n\n},{\"../core/Intersections\":3}],5:[function(require,module,exports){\n'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n\n},{\"../geometries/geometries.slice\":4,\"../shaders/shaders.data\":11}],6:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n\n},{\"../helpers/helpers.series\":5,\"../models/models.frame\":7,\"../models/models.series\":8,\"../models/models.stack\":9,\"../parsers/parsers.dicom\":10}],7:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n\n},{}],10:[function(require,module,exports){\n/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n\n},{\"dicom-parser\":13}],11:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\n/**\n *\n * It is typically used to get information about an image from the mouse cursor.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#widget_pixelProbe}\n *\n * @constructor\n * @class\n * @memberOf VJS.widgets\n * @public\n *\n */\nVJS.widgets.pixelProbe = function(image, imageMeshes) {\n    // it is an object 3D that we can add to the scene :)\n    THREE.Object3D.call(this);\n\n    this.domElement = null;\n    this.rasContainer = null;\n    this.ijkContainer = null;\n    this.valueContainer = null;\n\n    this.imageMeshes = imageMeshes;\n    this.image = image;\n\n    this.volumeCore = null;\n\n    this.marks = [];\n\n    this.createDomElement();\n\n    this._worldCoordinate = null; //LPS\n    this._dataCoordinate = null; //IJK\n    this._dataValue = null; //\n    this._labelValue = null; //\n};\n\nVJS.widgets.pixelProbe.prototype = Object.create(THREE.Object3D.prototype);\nVJS.widgets.pixelProbe.prototype.constructor = VJS.widgets.pixelProbe;\n\nVJS.widgets.pixelProbe.prototype.createDomElement = function() {\n\n    // RAS\n    this.rasContainer = document.createElement('div');\n    this.rasContainer.setAttribute('id', 'VJSProbeRAS');\n\n    // IJK\n    this.ijkContainer = document.createElement('div');\n    this.ijkContainer.setAttribute('id', 'VJSProbeIJK');\n\n    // Value\n    this.valueContainer = document.createElement('div');\n    this.valueContainer.setAttribute('id', 'VJSProbeValue');\n\n    this.domElement = document.createElement('div');\n    this.domElement.setAttribute('id', 'VJSProbe');\n    this.domElement.appendChild(this.rasContainer);\n    this.domElement.appendChild(this.ijkContainer);\n    this.domElement.appendChild(this.valueContainer);\n};\n\nVJS.widgets.pixelProbe.prototype.computeValues = function() {\n    // convert point to IJK\n    if (this.image) {\n        var worldToData = this.image._stack[0]._lps2IJK;\n\n        var dataCoordinate = new THREE.Vector3().copy(this._worldCoordinate).applyMatrix4(worldToData);\n        var temp = dataCoordinate.clone();\n\n        // same rounding in the shaders\n        dataCoordinate.x = Math.floor(dataCoordinate.x + 0.5);\n        dataCoordinate.y = Math.floor(dataCoordinate.y + 0.5);\n        dataCoordinate.z = Math.floor(dataCoordinate.z + 0.5);\n        this._dataCoordinate = dataCoordinate;\n\n        if (dataCoordinate.x >= 0 &&\n            dataCoordinate.y >= 0 &&\n            dataCoordinate.z >= 0) {\n            // var textureSize = this.image._stack[0]._textureSize;\n            var rows = this.image._stack[0]._rows;\n            var columns = this.image._stack[0]._columns;\n\n            // var index = this._dataCoordinate.x + columns * this._dataCoordinate.y + rows * columns * this._dataCoordinate.z;\n\n            // var textureIndex = Math.floor(index / (textureSize * textureSize));\n            // var inTextureIndex = index % (textureSize * textureSize);\n\n            this._dataValue = this.image._stack[0]._frame[this._dataCoordinate.z]._pixelData[this._dataCoordinate.x + columns * this._dataCoordinate.y];\n        } else {\n            window.console.log('something funny happening in compute value');\n            window.console.log(dataCoordinate);\n            window.console.log(temp);\n        }\n    }\n};\n\nVJS.widgets.pixelProbe.prototype.updateUI = function(mouse) {\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    this.rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    this.ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    var valueContent = this._dataValue;\n    this.valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // position of the div...\n    // need a mode to track the mouse\n    document.getElementById('VJSProbe').style.display = 'block';\n    document.getElementById('VJSProbe').style.top = mouse.clientY + 10;\n    document.getElementById('VJSProbe').style.left = mouse.clientX + 10;\n\n};\n\nVJS.widgets.pixelProbe.prototype.update = function(raycaster, mouse, camera, canvas) {\n\n    if (!this.imageMeshes) {\n        return;\n    }\n\n    this.updateMarkDom(raycaster, mouse, camera, canvas);\n\n    // calculate image intersecting the picking ray\n    var intersects = raycaster.intersectObjects(this.imageMeshes);\n\n    for (var intersect in intersects) {\n        var worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect].object.material.type === 'ShaderMaterial') {\n            this._worldCoordinate = worldCoordinates;\n            // window.console.log(this._worldCoordinate);\n            this.computeValues();\n            this.updateUI(mouse);\n            return;\n        }\n    }\n\n    // hide UI if not intersecting the planne\n    this.hideUI();\n};\n\nVJS.widgets.pixelProbe.prototype.hideUI = function() {\n    document.getElementById('VJSProbe').style.display = 'none';\n};\n\nVJS.widgets.pixelProbe.prototype.mark = function(raycaster, mouse) {\n    // calculate image intersecting against itself (ideally N spheres)\n    // no all good yet, because we can click on Shader Materail and still\n    // intersect another voxel if looking at plane from the side\n    // do we intersect a cube of the probe (in front of the plane not detected yet...)\n    var intersects = raycaster.intersectObjects(this.children);\n    var worldCoordinates = null;\n    // Look for a pixelProbeMark\n    // for (var intersect in intersects) {\n    //   worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n    //   // if on a mark, do not do anything\n    //   if (intersects[intersect].object.name === 'pixelProbeMark') {\n    //     window.console.log('intersect pixelProbeMark!');\n\n    //     return null;\n    //   }\n    // }\n\n    // Look for intersection against image\n    window.console.log(this);\n    intersects = raycaster.intersectObjects(this.imageMeshes);\n    for (var intersect2 in intersects) {\n        worldCoordinates = new THREE.Vector3().copy(intersects[intersect2].point);\n\n        // might be better to re-loop\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect2].object.material.type === 'ShaderMaterial') {\n            window.console.log('intersect shader material!');\n            this._worldCoordinate = worldCoordinates;\n            this.computeValues();\n\n            // make sure this IJK mark is not already shown...\n            for (var i = 0; i < this.marks.length; i++) {\n                if (this.marks[i].ijk.x === this._dataCoordinate.x &&\n                    this.marks[i].ijk.y === this._dataCoordinate.y &&\n                    this.marks[i].ijk.z === this._dataCoordinate.z) {\n                    return;\n                }\n            }\n\n            // create the geometry for it!\n            // var sphereGeometry = new THREE.SphereGeometry(1);\n            // var material = new THREE.MeshBasicMaterial({\n            //     // not selected: amber? #FFC107\n            //     // orange? #FF9800\n            //     // selected: deep orange? #FF5722\n            //     color: 0xFF5722\n            //   });\n            // var sphere = new THREE.Mesh(sphereGeometry, material);\n            // sphere.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n\n            // position against World Voxel Center! Not against the mouse!!\n            var dataToWorld = this.image._stack[0]._ijk2LPS;\n            var worldCenterCoordinate = new THREE.Vector3()\n                .copy(this._dataCoordinate)\n                .applyMatrix4(dataToWorld);\n\n            var voxDataCoord = this._dataCoordinate.clone();\n\n            var voxelGeometry = new THREE.BoxGeometry(1, 1, 1);\n            voxelGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n                this._dataCoordinate.x,\n                this._dataCoordinate.y,\n                this._dataCoordinate.z));\n            voxelGeometry.applyMatrix(this.image._stack[0]._ijk2LPS);\n            var voxelMaterial = new THREE.MeshBasicMaterial({\n                wireframe: true,\n                color: 0xFFC107\n            });\n            var voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);\n            // move to world space!\n            // voxel.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n            voxel.name = 'pixelProbeMark';\n            this.add(voxel);\n\n            // store mark\n            var mark = {\n                id: voxel.id,\n                position: worldCenterCoordinate,\n                ijk: voxDataCoord\n            };\n            this.marks.push(mark);\n            window.console.log(this.marks);\n\n            var domElement = this.markDom(mark, mouse);\n\n            return domElement;\n        }\n    }\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.markDom = function(mark, mouse) {\n\n    // that could be a web-component!\n    // RAS\n    var rasContainer = document.createElement('div');\n    rasContainer.setAttribute('class', 'VJSProbeRAS');\n\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    // IJK\n    var ijkContainer = document.createElement('div');\n    ijkContainer.setAttribute('class', 'VJSProbeIJK');\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    // Value\n    var valueContainer = document.createElement('div');\n    valueContainer.setAttribute('class', 'VJSProbeValue');\n\n    var valueContent = this._dataValue;\n    valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // Package everything\n    var domElement = document.createElement('div');\n    domElement.setAttribute('id', 'mark' + mark.id);\n    domElement.setAttribute('class', 'mark');\n    domElement.appendChild(rasContainer);\n    domElement.appendChild(ijkContainer);\n    domElement.appendChild(valueContainer);\n\n    domElement.style.display = 'block';\n    domElement.style.top = mouse.clientY + 10;\n    domElement.style.left = mouse.clientX + 10;\n\n    return domElement;\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.updateMarkDom = function(raycaster, mouse, camera, canvas) {\n\n    for (var i = 0; i < this.marks.length; i++) {\n        // find element in DOM!\n        // world coordinates to screen\n        var screenCoordinates = this.marks[i].position.clone();\n        screenCoordinates.project(camera);\n\n        screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);\n        screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);\n        screenCoordinates.z = 0;\n\n        // update div position\n        // window.console.log(document.getElementById('mark' + this.marks[i].id));\n        document.getElementById('mark' + this.marks[i].id).style.top = screenCoordinates.y + 10;\n        document.getElementById('mark' + this.marks[i].id).style.left = screenCoordinates.x + 10;\n\n    }\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.pixelProbe;\n},{}],13:[function(require,module,exports){\n/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));\n},{}]},{},[1])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsProbePixelWidget = require('../../modules/widgets/widgets.pixelProbe');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, probe, raycaster, mouse, drag;\n\n// FUNCTIONS\nfunction onProgressCallback(evt, filename) {\n  var percentComplete = Math.round((evt.loaded / evt.total) * 100);\n\n  window.console.log(filename);\n\n  var fileContainer = document.getElementById(filename);\n  if (!fileContainer) {\n    var progressContainer = document.getElementById('my-progress-container');\n    var div = document.createElement('div');\n    div.setAttribute('id', filename);\n    div.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n\n    progressContainer.appendChild(div);\n  } else {\n    fileContainer.innerHTML = 'Downloading ' + filename + ': ' + percentComplete + '%';\n  }\n}\n\nfunction init() {\n  function onDocumentMouseMove(event) {\n    event.preventDefault();\n\n    drag = 1;\n\n    // calculate mouse position in normalized device coordinates\n    // (-1 to +1) for both components\n    mouse.x = (event.clientX / threeD.offsetWidth) * 2 - 1;\n    mouse.y = -(event.clientY / threeD.offsetHeight) * 2 + 1;\n    mouse.clientX = event.clientX;\n    mouse.clientY = event.clientY;\n  }\n\n  function onDocumentMouseDown(event) {\n    event.preventDefault();\n\n    drag = 0;\n\n  }\n\n  function onDocumentMouseUp(event) {\n    event.preventDefault();\n\n    if (drag === 0) {\n      // create/select handle\n      raycaster.setFromCamera(mouse, camera);\n      // name???\n      var domElement = probe.mark(raycaster, mouse);\n      if (domElement) {\n        var threeD = document.getElementById('r3d');\n        threeD.appendChild(domElement);\n      }\n    }\n  }\n\n  // this function is executed on each animation frame\n  function animate() {\n\n    // image probe widget\n    if (mouse && raycaster && probe) {\n      raycaster.setFromCamera(mouse, camera);\n      probe.update(raycaster, mouse, camera, threeD);\n    }\n\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    stats.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  stats = new Stats();\n  threeD.appendChild(stats.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  \n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 150;\n  camera.position.y = 150;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  //\n  // mouse callbacks\n  raycaster = new THREE.Raycaster();\n  mouse = new THREE.Vector2();\n  renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n  renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n  renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);\n\n  animate();\n}\n\nwindow.onload = function() {\n  // init threeJS...\n  init();\n\n  // create loader manager (to keep track of progress over N files...)\n  // might not be useful with promises anymore.\n\n  // can not promise do it for us??\n  var manager = new THREE.LoadingManager();\n  manager.onProgress = function(item, loaded, total) {\n    window.console.log(item);\n    var fileContainer = document.getElementById(item);\n    if (fileContainer) {\n      fileContainer.innerHTML = ' ' + item + ' is ready! ' + '(' + loaded + '/' + total + ')';\n      // merge images!\n      // add it to the scene!\n    }\n  };\n\n  var file = '/data/dcm/adi/36749894';\n  //var file = '../../data/dcm/fruit';\n\n  // instantiate the loader\n  var loader = new vjsLoaderDicom(manager);\n  loader.load(\n      file,\n      // on load\n        function(imageHelper) {\n          // should it just return an image model?\n          // add image helper to scene\n          imageHelper.prepare();\n          scene.add(imageHelper);\n\n          probe = new vjsProbePixelWidget(imageHelper._image, imageHelper.children);\n          scene.add(probe);\n\n          var threeD = document.getElementById('r3d');\n          threeD.appendChild(probe.domElement);\n        },\n        // progress\n        function() {\n          onProgressCallback(event, file);\n        },\n        // error\n        function(message) {\n          window.console.log('error: ', message);\n        }\n    );\n\n  // use manager to deal with \"all loaded\"\n  // similar to promise all\n\n};\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n","'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n","'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n","'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n","/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.widgets = VJS.widgets || {};\n\n/**\n *\n * It is typically used to get information about an image from the mouse cursor.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#widget_pixelProbe}\n *\n * @constructor\n * @class\n * @memberOf VJS.widgets\n * @public\n *\n */\nVJS.widgets.pixelProbe = function(image, imageMeshes) {\n    // it is an object 3D that we can add to the scene :)\n    THREE.Object3D.call(this);\n\n    this.domElement = null;\n    this.rasContainer = null;\n    this.ijkContainer = null;\n    this.valueContainer = null;\n\n    this.imageMeshes = imageMeshes;\n    this.image = image;\n\n    this.volumeCore = null;\n\n    this.marks = [];\n\n    this.createDomElement();\n\n    this._worldCoordinate = null; //LPS\n    this._dataCoordinate = null; //IJK\n    this._dataValue = null; //\n    this._labelValue = null; //\n};\n\nVJS.widgets.pixelProbe.prototype = Object.create(THREE.Object3D.prototype);\nVJS.widgets.pixelProbe.prototype.constructor = VJS.widgets.pixelProbe;\n\nVJS.widgets.pixelProbe.prototype.createDomElement = function() {\n\n    // RAS\n    this.rasContainer = document.createElement('div');\n    this.rasContainer.setAttribute('id', 'VJSProbeRAS');\n\n    // IJK\n    this.ijkContainer = document.createElement('div');\n    this.ijkContainer.setAttribute('id', 'VJSProbeIJK');\n\n    // Value\n    this.valueContainer = document.createElement('div');\n    this.valueContainer.setAttribute('id', 'VJSProbeValue');\n\n    this.domElement = document.createElement('div');\n    this.domElement.setAttribute('id', 'VJSProbe');\n    this.domElement.appendChild(this.rasContainer);\n    this.domElement.appendChild(this.ijkContainer);\n    this.domElement.appendChild(this.valueContainer);\n};\n\nVJS.widgets.pixelProbe.prototype.computeValues = function() {\n    // convert point to IJK\n    if (this.image) {\n        var worldToData = this.image._stack[0]._lps2IJK;\n\n        var dataCoordinate = new THREE.Vector3().copy(this._worldCoordinate).applyMatrix4(worldToData);\n        var temp = dataCoordinate.clone();\n\n        // same rounding in the shaders\n        dataCoordinate.x = Math.floor(dataCoordinate.x + 0.5);\n        dataCoordinate.y = Math.floor(dataCoordinate.y + 0.5);\n        dataCoordinate.z = Math.floor(dataCoordinate.z + 0.5);\n        this._dataCoordinate = dataCoordinate;\n\n        if (dataCoordinate.x >= 0 &&\n            dataCoordinate.y >= 0 &&\n            dataCoordinate.z >= 0) {\n            // var textureSize = this.image._stack[0]._textureSize;\n            var rows = this.image._stack[0]._rows;\n            var columns = this.image._stack[0]._columns;\n\n            // var index = this._dataCoordinate.x + columns * this._dataCoordinate.y + rows * columns * this._dataCoordinate.z;\n\n            // var textureIndex = Math.floor(index / (textureSize * textureSize));\n            // var inTextureIndex = index % (textureSize * textureSize);\n\n            this._dataValue = this.image._stack[0]._frame[this._dataCoordinate.z]._pixelData[this._dataCoordinate.x + columns * this._dataCoordinate.y];\n        } else {\n            window.console.log('something funny happening in compute value');\n            window.console.log(dataCoordinate);\n            window.console.log(temp);\n        }\n    }\n};\n\nVJS.widgets.pixelProbe.prototype.updateUI = function(mouse) {\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    this.rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    this.ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    var valueContent = this._dataValue;\n    this.valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // position of the div...\n    // need a mode to track the mouse\n    document.getElementById('VJSProbe').style.display = 'block';\n    document.getElementById('VJSProbe').style.top = mouse.clientY + 10;\n    document.getElementById('VJSProbe').style.left = mouse.clientX + 10;\n\n};\n\nVJS.widgets.pixelProbe.prototype.update = function(raycaster, mouse, camera, canvas) {\n\n    if (!this.imageMeshes) {\n        return;\n    }\n\n    this.updateMarkDom(raycaster, mouse, camera, canvas);\n\n    // calculate image intersecting the picking ray\n    var intersects = raycaster.intersectObjects(this.imageMeshes);\n\n    for (var intersect in intersects) {\n        var worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect].object.material.type === 'ShaderMaterial') {\n            this._worldCoordinate = worldCoordinates;\n            // window.console.log(this._worldCoordinate);\n            this.computeValues();\n            this.updateUI(mouse);\n            return;\n        }\n    }\n\n    // hide UI if not intersecting the planne\n    this.hideUI();\n};\n\nVJS.widgets.pixelProbe.prototype.hideUI = function() {\n    document.getElementById('VJSProbe').style.display = 'none';\n};\n\nVJS.widgets.pixelProbe.prototype.mark = function(raycaster, mouse) {\n    // calculate image intersecting against itself (ideally N spheres)\n    // no all good yet, because we can click on Shader Materail and still\n    // intersect another voxel if looking at plane from the side\n    // do we intersect a cube of the probe (in front of the plane not detected yet...)\n    var intersects = raycaster.intersectObjects(this.children);\n    var worldCoordinates = null;\n    // Look for a pixelProbeMark\n    // for (var intersect in intersects) {\n    //   worldCoordinates = new THREE.Vector3().copy(intersects[intersect].point);\n\n    //   // if on a mark, do not do anything\n    //   if (intersects[intersect].object.name === 'pixelProbeMark') {\n    //     window.console.log('intersect pixelProbeMark!');\n\n    //     return null;\n    //   }\n    // }\n\n    // Look for intersection against image\n    window.console.log(this);\n    intersects = raycaster.intersectObjects(this.imageMeshes);\n    for (var intersect2 in intersects) {\n        worldCoordinates = new THREE.Vector3().copy(intersects[intersect2].point);\n\n        // might be better to re-loop\n        // if we intersect an image with a ShaderMaterial\n        // TODO: review that\n        if (intersects[intersect2].object.material.type === 'ShaderMaterial') {\n            window.console.log('intersect shader material!');\n            this._worldCoordinate = worldCoordinates;\n            this.computeValues();\n\n            // make sure this IJK mark is not already shown...\n            for (var i = 0; i < this.marks.length; i++) {\n                if (this.marks[i].ijk.x === this._dataCoordinate.x &&\n                    this.marks[i].ijk.y === this._dataCoordinate.y &&\n                    this.marks[i].ijk.z === this._dataCoordinate.z) {\n                    return;\n                }\n            }\n\n            // create the geometry for it!\n            // var sphereGeometry = new THREE.SphereGeometry(1);\n            // var material = new THREE.MeshBasicMaterial({\n            //     // not selected: amber? #FFC107\n            //     // orange? #FF9800\n            //     // selected: deep orange? #FF5722\n            //     color: 0xFF5722\n            //   });\n            // var sphere = new THREE.Mesh(sphereGeometry, material);\n            // sphere.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n\n            // position against World Voxel Center! Not against the mouse!!\n            var dataToWorld = this.image._stack[0]._ijk2LPS;\n            var worldCenterCoordinate = new THREE.Vector3()\n                .copy(this._dataCoordinate)\n                .applyMatrix4(dataToWorld);\n\n            var voxDataCoord = this._dataCoordinate.clone();\n\n            var voxelGeometry = new THREE.BoxGeometry(1, 1, 1);\n            voxelGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n                this._dataCoordinate.x,\n                this._dataCoordinate.y,\n                this._dataCoordinate.z));\n            voxelGeometry.applyMatrix(this.image._stack[0]._ijk2LPS);\n            var voxelMaterial = new THREE.MeshBasicMaterial({\n                wireframe: true,\n                color: 0xFFC107\n            });\n            var voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);\n            // move to world space!\n            // voxel.applyMatrix(new THREE.Matrix4().makeTranslation(\n            //   worldCoordinates.x, worldCoordinates.y, worldCoordinates.z));\n            voxel.name = 'pixelProbeMark';\n            this.add(voxel);\n\n            // store mark\n            var mark = {\n                id: voxel.id,\n                position: worldCenterCoordinate,\n                ijk: voxDataCoord\n            };\n            this.marks.push(mark);\n            window.console.log(this.marks);\n\n            var domElement = this.markDom(mark, mouse);\n\n            return domElement;\n        }\n    }\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.markDom = function(mark, mouse) {\n\n    // that could be a web-component!\n    // RAS\n    var rasContainer = document.createElement('div');\n    rasContainer.setAttribute('class', 'VJSProbeRAS');\n\n    var rasContent = this._worldCoordinate.x.toFixed(2) + ' : ' + this._worldCoordinate.y.toFixed(2) + ' : ' + this._worldCoordinate.z.toFixed(2);\n    rasContainer.innerHTML = 'LPS: ' + rasContent;\n\n    // IJK\n    var ijkContainer = document.createElement('div');\n    ijkContainer.setAttribute('class', 'VJSProbeIJK');\n\n    var ijkContent = this._dataCoordinate.x + ' : ' + this._dataCoordinate.y + ' : ' + this._dataCoordinate.z;\n    ijkContainer.innerHTML = 'IJK: ' + ijkContent;\n\n    // Value\n    var valueContainer = document.createElement('div');\n    valueContainer.setAttribute('class', 'VJSProbeValue');\n\n    var valueContent = this._dataValue;\n    valueContainer.innerHTML = 'Value: ' + valueContent;\n\n    // Package everything\n    var domElement = document.createElement('div');\n    domElement.setAttribute('id', 'mark' + mark.id);\n    domElement.setAttribute('class', 'mark');\n    domElement.appendChild(rasContainer);\n    domElement.appendChild(ijkContainer);\n    domElement.appendChild(valueContainer);\n\n    domElement.style.display = 'block';\n    domElement.style.top = mouse.clientY + 10;\n    domElement.style.left = mouse.clientX + 10;\n\n    return domElement;\n};\n\n// do not need mouse in theory...\nVJS.widgets.pixelProbe.prototype.updateMarkDom = function(raycaster, mouse, camera, canvas) {\n\n    for (var i = 0; i < this.marks.length; i++) {\n        // find element in DOM!\n        // world coordinates to screen\n        var screenCoordinates = this.marks[i].position.clone();\n        screenCoordinates.project(camera);\n\n        screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);\n        screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);\n        screenCoordinates.z = 0;\n\n        // update div position\n        // window.console.log(document.getElementById('mark' + this.marks[i].id));\n        document.getElementById('mark' + this.marks[i].id).style.top = screenCoordinates.y + 10;\n        document.getElementById('mark' + this.marks[i].id).style.left = screenCoordinates.x + 10;\n\n    }\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.widgets.pixelProbe;","/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));"],"sourceRoot":"/source/"}