{"version":3,"sources":["geometries_slice/node_modules/browserify/node_modules/browser-pack/_prelude.js","geometries_slice/examples/geometries_slice/geometries_slice.js","geometries_slice/geometries_slice.js","geometries_slice/src/controls/OrbitControls2D.js","geometries_slice/src/core/core.intersections.js","geometries_slice/src/geometries/geometries.slice.js"],"names":[],"mappings":"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","file":"geometries_slice/geometries_slice.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats, dat*/\n'use strict';\n\nvar VJS = VJS || {};\nVJS.geometries = VJS.geometries || {};\nVJS.geometries.slice = require('../../src/geometries/geometries.slice');\n\nVJS.controls = VJS.controls || {};\nVJS.controls.orbitControls2D = require('../../src/controls/OrbitControls2D');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay, particleLight, sliceMesh, arrowMesh;\n\nvar arrow = {\n  'direction': new THREE.Vector3(0, 0, 0),\n  'position':  new THREE.Vector3(0, 0, 0),\n  'length': 20,\n  'color': 0xFFF336\n};\n\nvar box = {\n  'dimensions': new THREE.Vector3(123, 45, 67),\n  'halfDimensions': new THREE.Vector3(123, 45, 67).divideScalar(2),\n  'center': new THREE.Vector3(0, 0, 0),\n  'orientation': new THREE.Vector3(\n    new THREE.Vector3(1, 0, 0),\n    new THREE.Vector3(0, 1, 0),\n    new THREE.Vector3(0, 0, 1))\n};\n\nfunction disposeSliceMesh() {\n  scene.remove(sliceMesh);\n  sliceMesh.geometry.dispose();\n  sliceMesh.material.dispose();\n  sliceMesh = null;\n}\n\nfunction createSliceMesh() {\n  // create the geometry\n  var sliceGeometry = new VJS.geometries.slice(box.halfDimensions, box.center, box.orientation, arrow.position, arrow.direction);\n  // create the material\n  var sliceMaterial = new THREE.MeshLambertMaterial({\n    color: 0x03A9F4,\n    emissive: 0x000000,\n    shininess: 30,\n    shading: THREE.SmoothShading,\n    'side': THREE.DoubleSide\n  });\n  return new THREE.Mesh(sliceGeometry, sliceMaterial);\n}\n\nfunction updateGeometries() {\n  if (arrowMesh && sliceMesh) {\n    // update arrow\n    arrowMesh.position.set(arrow.position.x, arrow.position.y, arrow.position.z);\n    arrowMesh.setDirection(arrow.direction);\n\n    // create new slice\n    // not super efficient...\n    disposeSliceMesh();\n    sliceMesh = createSliceMesh();\n    scene.add(sliceMesh);\n  }\n}\n\n// FUNCTIONS\nfunction init() {\n\n  // this function is executed on each animation frame\n  function animate() {\n\n    // update light position\n    var timer = Date.now() * 0.00025;\n\n    particleLight.position.x = Math.sin(timer * 7) * 70;\n    particleLight.position.y = Math.cos(timer * 5) * 80;\n    particleLight.position.z = Math.cos(timer * 3) * 90;\n\n    //update normal to look at particle\n    var dir = new THREE.Vector3(\n      particleLight.position.x - arrow.position.x,\n      particleLight.position.y - arrow.position.y,\n      particleLight.position.z - arrow.position.z\n      ).normalize();\n    arrow.direction.x = dir.x;\n    arrow.direction.y = dir.y;\n    arrow.direction.z = dir.z;\n\n    updateGeometries();\n        \n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    statsyay.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0x353535, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  statsyay = new Stats();\n  threeD.appendChild(statsyay.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 100;\n  camera.position.y = 100;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new VJS.controls.orbitControls2D(camera, renderer.domElement);\n\n  scene.add(new THREE.AmbientLight(0x444444));\n\n  var directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n  directionalLight.position.set(1, 1, 1).normalize();\n  scene.add(directionalLight);\n\n  particleLight = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshBasicMaterial({color: 0xFFF336}));\n  scene.add(particleLight);\n\n  var pointLight = new THREE.PointLight(0xffffff, 2, 200);\n  particleLight.add(pointLight);\n\n  animate();\n}\n\nwindow.onload = function() {\n  // init threeJS...\n  init();\n\n  // make a box!\n  var boxGeometry = new THREE.BoxGeometry(box.dimensions.x, box.dimensions.y, box.dimensions.z);\n  var boxMaterial = new THREE.MeshBasicMaterial({\n    wireframe: true,\n    color: 0x61F2F3\n  });\n  var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);\n  scene.add(boxMesh);\n\n  // make a slice!\n  sliceMesh = createSliceMesh();\n  scene.add(sliceMesh);\n\n  // make an arrow\n  arrowMesh = new THREE.ArrowHelper(arrow.direction, arrow.position, arrow.length, arrow.color);\n  scene.add(arrowMesh);\n\n  var gui = new dat.GUI({\n    autoPlace: false\n  });\n\n  var customContainer = document.getElementById('my-gui-container');\n  customContainer.appendChild(gui.domElement);\n\n  var directionFolder = gui.addFolder('Plane direction');\n  var frameIndexControllerDirectionI = directionFolder.add(arrow.direction, 'x', -1, 1).listen();\n  var frameIndexControllerDirectionJ = directionFolder.add(arrow.direction, 'y', -1, 1).listen();\n  var frameIndexControllerDirectionK = directionFolder.add(arrow.direction, 'z', -1, 1).listen();\n  directionFolder.open();\n\n  var positionFolder = gui.addFolder('Plane position');\n  var frameIndexControllerOriginI = positionFolder.add(arrow.position, 'x', -61.5, 61.5).listen();\n  var frameIndexControllerOriginJ = positionFolder.add(arrow.position, 'y', -22.5, 22.5).listen();\n  var frameIndexControllerOriginK = positionFolder.add(arrow.position, 'z', -33.5, 33.5).listen();\n  positionFolder.open();\n\n  frameIndexControllerDirectionI.onChange(updateGeometries);\n  frameIndexControllerDirectionJ.onChange(updateGeometries);\n  frameIndexControllerDirectionK.onChange(updateGeometries);\n  frameIndexControllerOriginI.onChange(updateGeometries);\n  frameIndexControllerOriginJ.onChange(updateGeometries);\n  frameIndexControllerOriginK.onChange(updateGeometries);\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats, dat*/\n'use strict';\n\nvar VJS = VJS || {};\nVJS.geometries = VJS.geometries || {};\nVJS.geometries.slice = require('../../src/geometries/geometries.slice');\n\nVJS.controls = VJS.controls || {};\nVJS.controls.orbitControls2D = require('../../src/controls/OrbitControls2D');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay, particleLight, sliceMesh, arrowMesh;\n\nvar arrow = {\n  'direction': new THREE.Vector3(0, 0, 0),\n  'position':  new THREE.Vector3(0, 0, 0),\n  'length': 20,\n  'color': 0xFFF336\n};\n\nvar box = {\n  'dimensions': new THREE.Vector3(123, 45, 67),\n  'halfDimensions': new THREE.Vector3(123, 45, 67).divideScalar(2),\n  'center': new THREE.Vector3(0, 0, 0),\n  'orientation': new THREE.Vector3(\n    new THREE.Vector3(1, 0, 0),\n    new THREE.Vector3(0, 1, 0),\n    new THREE.Vector3(0, 0, 1))\n};\n\nfunction disposeSliceMesh() {\n  scene.remove(sliceMesh);\n  sliceMesh.geometry.dispose();\n  sliceMesh.material.dispose();\n  sliceMesh = null;\n}\n\nfunction createSliceMesh() {\n  // create the geometry\n  var sliceGeometry = new VJS.geometries.slice(box.halfDimensions, box.center, box.orientation, arrow.position, arrow.direction);\n  // create the material\n  var sliceMaterial = new THREE.MeshLambertMaterial({\n    color: 0x03A9F4,\n    emissive: 0x000000,\n    shininess: 30,\n    shading: THREE.SmoothShading,\n    'side': THREE.DoubleSide\n  });\n  return new THREE.Mesh(sliceGeometry, sliceMaterial);\n}\n\nfunction updateGeometries() {\n  if (arrowMesh && sliceMesh) {\n    // update arrow\n    arrowMesh.position.set(arrow.position.x, arrow.position.y, arrow.position.z);\n    arrowMesh.setDirection(arrow.direction);\n\n    // create new slice\n    // not super efficient...\n    disposeSliceMesh();\n    sliceMesh = createSliceMesh();\n    scene.add(sliceMesh);\n  }\n}\n\n// FUNCTIONS\nfunction init() {\n\n  // this function is executed on each animation frame\n  function animate() {\n\n    // update light position\n    var timer = Date.now() * 0.00025;\n\n    particleLight.position.x = Math.sin(timer * 7) * 70;\n    particleLight.position.y = Math.cos(timer * 5) * 80;\n    particleLight.position.z = Math.cos(timer * 3) * 90;\n\n    //update normal to look at particle\n    var dir = new THREE.Vector3(\n      particleLight.position.x - arrow.position.x,\n      particleLight.position.y - arrow.position.y,\n      particleLight.position.z - arrow.position.z\n      ).normalize();\n    arrow.direction.x = dir.x;\n    arrow.direction.y = dir.y;\n    arrow.direction.z = dir.z;\n\n    updateGeometries();\n        \n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    statsyay.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0x353535, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  statsyay = new Stats();\n  threeD.appendChild(statsyay.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 100;\n  camera.position.y = 100;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new VJS.controls.orbitControls2D(camera, renderer.domElement);\n\n  scene.add(new THREE.AmbientLight(0x444444));\n\n  var directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n  directionalLight.position.set(1, 1, 1).normalize();\n  scene.add(directionalLight);\n\n  particleLight = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshBasicMaterial({color: 0xFFF336}));\n  scene.add(particleLight);\n\n  var pointLight = new THREE.PointLight(0xffffff, 2, 200);\n  particleLight.add(pointLight);\n\n  animate();\n}\n\nwindow.onload = function() {\n  // init threeJS...\n  init();\n\n  // make a box!\n  var boxGeometry = new THREE.BoxGeometry(box.dimensions.x, box.dimensions.y, box.dimensions.z);\n  var boxMaterial = new THREE.MeshBasicMaterial({\n    wireframe: true,\n    color: 0x61F2F3\n  });\n  var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);\n  scene.add(boxMesh);\n\n  // make a slice!\n  sliceMesh = createSliceMesh();\n  scene.add(sliceMesh);\n\n  // make an arrow\n  arrowMesh = new THREE.ArrowHelper(arrow.direction, arrow.position, arrow.length, arrow.color);\n  scene.add(arrowMesh);\n\n  var gui = new dat.GUI({\n    autoPlace: false\n  });\n\n  var customContainer = document.getElementById('my-gui-container');\n  customContainer.appendChild(gui.domElement);\n\n  var directionFolder = gui.addFolder('Plane direction');\n  var frameIndexControllerDirectionI = directionFolder.add(arrow.direction, 'x', -1, 1).listen();\n  var frameIndexControllerDirectionJ = directionFolder.add(arrow.direction, 'y', -1, 1).listen();\n  var frameIndexControllerDirectionK = directionFolder.add(arrow.direction, 'z', -1, 1).listen();\n  directionFolder.open();\n\n  var positionFolder = gui.addFolder('Plane position');\n  var frameIndexControllerOriginI = positionFolder.add(arrow.position, 'x', -61.5, 61.5).listen();\n  var frameIndexControllerOriginJ = positionFolder.add(arrow.position, 'y', -22.5, 22.5).listen();\n  var frameIndexControllerOriginK = positionFolder.add(arrow.position, 'z', -33.5, 33.5).listen();\n  positionFolder.open();\n\n  frameIndexControllerDirectionI.onChange(updateGeometries);\n  frameIndexControllerDirectionJ.onChange(updateGeometries);\n  frameIndexControllerDirectionK.onChange(updateGeometries);\n  frameIndexControllerOriginI.onChange(updateGeometries);\n  frameIndexControllerOriginJ.onChange(updateGeometries);\n  frameIndexControllerOriginK.onChange(updateGeometries);\n};\n\n},{\"../../src/controls/OrbitControls2D\":2,\"../../src/geometries/geometries.slice\":4}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.core = VJS.core || {};\n\n/**\n * @constructor\n * @class\n * @memberOf VJS.core\n * @public\n*/\nVJS.core.intersections = VJS.core.intersections || {};\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.core.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.core.intersections.obbPlane = function(obb, plane) {\n\n  //\n  // obb = { halfDimensions, orientation, center, toOBBSpace }\n  // plane = { position, direction }\n  //\n  //\n  // LOGIC:\n  //\n  // Test intersection of each edge of the Oriented Bounding Box with the Plane\n  // \n  // ALL EDGES \n  //\n  //      .+-------+  \n  //    .' |     .'|  \n  //   +---+---+'  |  \n  //   |   |   |   |  \n  //   |  ,+---+---+  \n  //   |.'     | .'   \n  //   +-------+'     \n  //\n  // SPACE ORIENTATION\n  //\n  //       +\n  //     j |\n  //       |\n  //       |   i \n  //   k  ,+-------+  \n  //    .'\n  //   +\n  //\n  //\n  // 1- Move Plane position and orientation in IJK space\n  // 2- Test Edges/ IJK Plane intersections\n  // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n  var intersections = [];\n\n  var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n  var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n  var planeOBB = {\n    position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n    direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n  };\n\n  var bboxMin = new THREE.Vector3(\n      obb.center.x - obb.halfDimensions.x,\n      obb.center.y - obb.halfDimensions.y,\n      obb.center.z - obb.halfDimensions.z);\n  var bboxMax = new THREE.Vector3(\n      obb.center.x + obb.halfDimensions.x,\n      obb.center.y + obb.halfDimensions.y,\n      obb.center.z + obb.halfDimensions.z);\n\n  // 12 edges (i.e. ray)/plane intersection tests\n\n  // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n  //\n  //       +\n  //       |\n  //       |\n  //       | \n  //      ,+---+---+\n  //    .'   \n  //   +   \n\n  var ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  var intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE LAST CORNER\n  //\n  //               +\n  //             .'\n  //   +-------+'\n  //           |\n  //           |\n  //           |\n  //           +\n  //\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE SECOND CORNER\n  //\n  //               +\n  //               |\n  //               |\n  //               |\n  //               +\n  //             .'\n  //           +'\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.y\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE THIRD CORNER\n  //\n  //      .+-------+  \n  //    .'\n  //   +\n  //   \n  //   \n  //   \n  //   \n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE FOURTH CORNER\n  //\n  //   \n  //   \n  //   +\n  //   |\n  //   |  \n  //   |\n  //   +-------+\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.core.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.core.intersections.rayPlane = function(ray, plane) {\n  // ray: {position, direction}\n  // plane: {position, direction}\n\n  if (ray.direction.dot(plane.direction) !== 0) {\n    //\n    // not parallel, move forward\n    //\n    // LOGIC:\n    //\n    // Ray equation: P = P0 + tV\n    // P = <Px, Py, Pz>\n    // P0 = <ray.position.x, ray.position.y, ray.position.z>\n    // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n    //\n    // Therefore:\n    // Px = ray.position.x + t*ray.direction.x\n    // Py = ray.position.y + t*ray.direction.y\n    // Pz = ray.position.z + t*ray.direction.z\n    //\n    //\n    //\n    // Plane equation: ax + by + cz + d = 0\n    // a = plane.direction.x\n    // b = plane.direction.y\n    // c = plane.direction.z\n    // d = -( plane.direction.x*plane.position.x +\n    //        plane.direction.y*plane.position.y +\n    //        plane.direction.z*plane.position.z )\n    //\n    //\n    // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n    // 2- find t\n    // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n    //\n    var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n        (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n    var intersection = new THREE.Vector3(\n        ray.position.x + t * ray.direction.x,\n        ray.position.y + t * ray.direction.y,\n        ray.position.z + t * ray.direction.z);\n\n    return intersection;\n\n  }\n\n  return null;\n\n};\n\nVJS.core.intersections.rayBox = function(ray, box) {\n  // ray: {position, direction}\n  // box: {halfDimensions, center}\n\n  var intersections = [];\n  var plane = {\n    position: null,\n    direction: null\n  };\n\n  var bboxMin = new THREE.Vector3(\n    box.center.x - box.halfDimensions.x,\n    box.center.y - box.halfDimensions.y,\n    box.center.z - box.halfDimensions.z);\n  var bboxMax = new THREE.Vector3(\n      box.center.x + box.halfDimensions.x,\n      box.center.y + box.halfDimensions.y,\n      box.center.z + box.halfDimensions.z);\n\n  // X min\n  plane.direction = new THREE.Vector3(-1, 0, 0);\n  plane.position = new THREE.Vector3(\n    bboxMin.x,\n    box.center.y,\n    box.center.z);\n  var intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // X max\n  plane.direction = new THREE.Vector3(1, 0, 0);\n  plane.position = new THREE.Vector3(\n    bboxMax.x,\n    box.center.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Y min\n  plane.direction = new THREE.Vector3(0, -1, 0);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    bboxMin.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Y max\n  plane.direction = new THREE.Vector3(0, 1, 0);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    bboxMax.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Z min\n  plane.direction = new THREE.Vector3(0, 0, -1);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    box.center.y,\n    bboxMin.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Z max\n  plane.direction = new THREE.Vector3(0, 0, 1);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    box.center.y,\n    bboxMax.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n  \n  return intersections;\n};\n\nVJS.core.intersections.inBBox = function(point, bboxMin, bboxMax) {\n  if (point &&\n  point.x >= bboxMin.x && point.y >= bboxMin.y && point.z >= bboxMin.z &&\n  point.x <= bboxMax.x && point.y <= bboxMax.y && point.z <= bboxMax.z) {\n    return true;\n  }\n  return false;\n};\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== 'undefined') && module.exports) {\n  module.exports = VJS.core.intersections;\n}\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.geometries = VJS.geometries || {};\n\n/*** Imports ***/\n\nVJS.core = VJS.core || {};\nVJS.core.intersections = VJS.core.intersections || require('../core/core.intersections');\n\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = VJS.core.intersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== 'undefined') && module.exports) {\n    module.exports = VJS.geometries.slice;\n}\n\n},{\"../core/core.intersections\":3}]},{},[1])\n\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.core = VJS.core || {};\n\n/**\n * @constructor\n * @class\n * @memberOf VJS.core\n * @public\n*/\nVJS.core.intersections = VJS.core.intersections || {};\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.core.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.core.intersections.obbPlane = function(obb, plane) {\n\n  //\n  // obb = { halfDimensions, orientation, center, toOBBSpace }\n  // plane = { position, direction }\n  //\n  //\n  // LOGIC:\n  //\n  // Test intersection of each edge of the Oriented Bounding Box with the Plane\n  // \n  // ALL EDGES \n  //\n  //      .+-------+  \n  //    .' |     .'|  \n  //   +---+---+'  |  \n  //   |   |   |   |  \n  //   |  ,+---+---+  \n  //   |.'     | .'   \n  //   +-------+'     \n  //\n  // SPACE ORIENTATION\n  //\n  //       +\n  //     j |\n  //       |\n  //       |   i \n  //   k  ,+-------+  \n  //    .'\n  //   +\n  //\n  //\n  // 1- Move Plane position and orientation in IJK space\n  // 2- Test Edges/ IJK Plane intersections\n  // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n  var intersections = [];\n\n  var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n  var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n  var planeOBB = {\n    position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n    direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n  };\n\n  var bboxMin = new THREE.Vector3(\n      obb.center.x - obb.halfDimensions.x,\n      obb.center.y - obb.halfDimensions.y,\n      obb.center.z - obb.halfDimensions.z);\n  var bboxMax = new THREE.Vector3(\n      obb.center.x + obb.halfDimensions.x,\n      obb.center.y + obb.halfDimensions.y,\n      obb.center.z + obb.halfDimensions.z);\n\n  // 12 edges (i.e. ray)/plane intersection tests\n\n  // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n  //\n  //       +\n  //       |\n  //       |\n  //       | \n  //      ,+---+---+\n  //    .'   \n  //   +   \n\n  var ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  var intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE LAST CORNER\n  //\n  //               +\n  //             .'\n  //   +-------+'\n  //           |\n  //           |\n  //           |\n  //           +\n  //\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE SECOND CORNER\n  //\n  //               +\n  //               |\n  //               |\n  //               |\n  //               +\n  //             .'\n  //           +'\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.y\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE THIRD CORNER\n  //\n  //      .+-------+  \n  //    .'\n  //   +\n  //   \n  //   \n  //   \n  //   \n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.z;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  // RAYS STARTING FROM THE FOURTH CORNER\n  //\n  //   \n  //   \n  //   +\n  //   |\n  //   |  \n  //   |\n  //   +-------+\n\n  ray = {\n    'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n    'direction': obb.orientation.x\n  };\n\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  ray.direction = obb.orientation.y;\n  intersection = this.rayPlane(ray, planeOBB);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n  }\n\n  return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.core.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.core.intersections.rayPlane = function(ray, plane) {\n  // ray: {position, direction}\n  // plane: {position, direction}\n\n  if (ray.direction.dot(plane.direction) !== 0) {\n    //\n    // not parallel, move forward\n    //\n    // LOGIC:\n    //\n    // Ray equation: P = P0 + tV\n    // P = <Px, Py, Pz>\n    // P0 = <ray.position.x, ray.position.y, ray.position.z>\n    // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n    //\n    // Therefore:\n    // Px = ray.position.x + t*ray.direction.x\n    // Py = ray.position.y + t*ray.direction.y\n    // Pz = ray.position.z + t*ray.direction.z\n    //\n    //\n    //\n    // Plane equation: ax + by + cz + d = 0\n    // a = plane.direction.x\n    // b = plane.direction.y\n    // c = plane.direction.z\n    // d = -( plane.direction.x*plane.position.x +\n    //        plane.direction.y*plane.position.y +\n    //        plane.direction.z*plane.position.z )\n    //\n    //\n    // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n    // 2- find t\n    // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n    //\n    var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n        (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n    var intersection = new THREE.Vector3(\n        ray.position.x + t * ray.direction.x,\n        ray.position.y + t * ray.direction.y,\n        ray.position.z + t * ray.direction.z);\n\n    return intersection;\n\n  }\n\n  return null;\n\n};\n\nVJS.core.intersections.rayBox = function(ray, box) {\n  // ray: {position, direction}\n  // box: {halfDimensions, center}\n\n  var intersections = [];\n  var plane = {\n    position: null,\n    direction: null\n  };\n\n  var bboxMin = new THREE.Vector3(\n    box.center.x - box.halfDimensions.x,\n    box.center.y - box.halfDimensions.y,\n    box.center.z - box.halfDimensions.z);\n  var bboxMax = new THREE.Vector3(\n      box.center.x + box.halfDimensions.x,\n      box.center.y + box.halfDimensions.y,\n      box.center.z + box.halfDimensions.z);\n\n  // X min\n  plane.direction = new THREE.Vector3(-1, 0, 0);\n  plane.position = new THREE.Vector3(\n    bboxMin.x,\n    box.center.y,\n    box.center.z);\n  var intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // X max\n  plane.direction = new THREE.Vector3(1, 0, 0);\n  plane.position = new THREE.Vector3(\n    bboxMax.x,\n    box.center.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Y min\n  plane.direction = new THREE.Vector3(0, -1, 0);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    bboxMin.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Y max\n  plane.direction = new THREE.Vector3(0, 1, 0);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    bboxMax.y,\n    box.center.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Z min\n  plane.direction = new THREE.Vector3(0, 0, -1);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    box.center.y,\n    bboxMin.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n\n  // Z max\n  plane.direction = new THREE.Vector3(0, 0, 1);\n  plane.position = new THREE.Vector3(\n    box.center.x,\n    box.center.y,\n    bboxMax.z);\n  intersection = this.rayPlane(ray, plane);\n  if (this.inBBox(intersection, bboxMin, bboxMax)) {\n    intersections.push(intersection);\n  }\n  \n  return intersections;\n};\n\nVJS.core.intersections.inBBox = function(point, bboxMin, bboxMax) {\n  if (point &&\n  point.x >= bboxMin.x && point.y >= bboxMin.y && point.z >= bboxMin.z &&\n  point.x <= bboxMax.x && point.y <= bboxMax.y && point.z <= bboxMax.z) {\n    return true;\n  }\n  return false;\n};\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== 'undefined') && module.exports) {\n  module.exports = VJS.core.intersections;\n}\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.geometries = VJS.geometries || {};\n\n/*** Imports ***/\n\nVJS.core = VJS.core || {};\nVJS.core.intersections = VJS.core.intersections || require('../core/core.intersections');\n\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = VJS.core.intersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== 'undefined') && module.exports) {\n    module.exports = VJS.geometries.slice;\n}\n"],"sourceRoot":"/source/"}