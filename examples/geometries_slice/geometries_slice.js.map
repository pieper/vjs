{"version":3,"sources":["examples/geometries_slice/geometries_slice.js","examples/geometries_slice/node_modules/browserify/node_modules/browser-pack/_prelude.js","examples/geometries_slice/app/examples/geometries_slice/geometries_slice.js","examples/geometries_slice/app/modules/controls/OrbitControls2D.js","examples/geometries_slice/app/modules/core/Intersections.js","examples/geometries_slice/app/modules/geometries/geometries.slice.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","init","animate","controls","update","renderer","render","scene","camera","statsyay","requestAnimationFrame","threeD","document","getElementById","THREE","WebGLRenderer","antialias","setSize","offsetWidth","offsetHeight","setClearColor","maxTextureSize","context","getParameter","MAX_TEXTURE_SIZE","window","console","log","appendChild","domElement","Stats","Scene","PerspectiveCamera","position","x","y","z","lookAt","vjsOrbitControl2D","vjsSliceGeometry","onload","dimensions","Vector3","boxGeometry","BoxGeometry","boxMaterial","MeshBasicMaterial","wireframe","color","box","Mesh","add","halfDimensions","clone","divideScalar","center","orientation","direction","sliceGeometry","sliceMaterial","side","DoubleSide","transparency","slice","hex","arrowHelper","ArrowHelper","arrowUpdate","j","k","gui","dat","GUI","autoPlace","customContainer","directionFolder","addFolder","frameIndexControllerDirectionI","frameIndexControllerDirectionJ","frameIndexControllerDirectionK","open","positionFolder","frameIndexControllerOriginI","frameIndexControllerOriginJ","frameIndexControllerOriginK","onChange","value","newDirection","normalize","newPosition","setDirection","newSliceGeometry","geometry","verticesNeedUpdate","remove","../../modules/controls/OrbitControls2D","../../modules/geometries/geometries.slice",2,"OrbitControls2D","object","getAutoRotationAngle","Math","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","event","enabled","preventDefault","button","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","set","clientX","clientY","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","addEventListener","onMouseMove","onMouseUp","dispatchEvent","startEvent","element","body","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","removeEventListener","endEvent","onMouseWheel","stopPropagation","delta","undefined","wheelDelta","detail","onKeyDown","noKeys","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","touchend","this","target","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MOUSE","MIDDLE","theta","phi","EPS","Vector2","panOffset","offset","phiDelta","thetaDelta","scale","lastPosition","lastQuaternion","Quaternion","target0","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","angle","panLeft","te","matrix","elements","multiplyScalar","panUp","deltaX","deltaY","fov","sub","targetDistance","tan","top","right","left","zoom","bottom","warn","dollyScale","updateProjectionMatrix","applyQuaternion","atan2","max","min","radius","sin","cos","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","prototype","Object","create","EventDispatcher","constructor",3,"VJS","intersections","obbPlane","obb","plane","t1","applyMatrix4","toOBBSpace","t0","planeOBB","bboxMin","bboxMax","ray","intersection","rayPlane","push","toOBBSpaceInvert",4,"vjsIntersections","geometries","Matrix4","centerOfMass","orderedIntersections","orderIntersections","formatIntersections","formatIntersectionsXY","point","xy","sliceShape","Shape","moveTo","lineTo","ShapeGeometry","vertices","points","reference","a0","b0","c0","x0","y0","z0","l0","origin","base","crossVectors","orderedpoints","a1","b1","c1","x1","y1","z1","l1","thetaAngle","sort","b","../core/Intersections"],"mappings":"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","file":"examples/geometries_slice/geometries_slice.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats, dat*/\n'use strict';\n\nvar vjsSliceGeometry = require('../../modules/geometries/geometries.slice');\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay;\n\n// FUNCTIONS\nfunction init() {\n\n    // this function is executed on each animation frame\n    function animate() {\n        // render\n        controls.update();\n        renderer.render(scene, camera);\n        statsyay.update();\n\n        // request new frame\n        requestAnimationFrame(function() {\n            animate();\n        });\n    }\n\n    // renderer\n    var threeD = document.getElementById('r3d');\n    renderer = new THREE.WebGLRenderer({\n        antialias: true\n    });\n    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n    renderer.setClearColor(0xFFFFFF, 1);\n\n    var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n    window.console.log(maxTextureSize);\n\n    threeD.appendChild(renderer.domElement);\n\n    // stats\n    statsyay = new Stats();\n    threeD.appendChild(statsyay.domElement);\n\n    // scene\n    scene = new THREE.Scene();\n    // camera\n    camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n    camera.position.x = 100;\n    camera.position.y = 100;\n    camera.position.z = 100;\n    camera.lookAt(scene.position);\n    // controls\n    controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n    animate();\n}\n\nwindow.onload = function() {\n    // init threeJS...\n    init();\n\n    // make a box!\n    var dimensions = new THREE.Vector3(123, 45, 67);\n    var boxGeometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);\n    var boxMaterial = new THREE.MeshBasicMaterial({\n        wireframe: true,\n        color: 0x61F2F3\n    });\n    var box = new THREE.Mesh(boxGeometry, boxMaterial);\n    scene.add(box);\n\n    // make a slice!\n    var halfDimensions = dimensions.clone().divideScalar(2);\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = center.clone();\n    var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n\n    var sliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, position, direction);\n    var sliceMaterial = new THREE.MeshBasicMaterial({\n        'side': THREE.DoubleSide,\n        'transparency': true,\n        'color': 0x03A9F4\n    });\n    var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n    scene.add(slice);\n\n    // make the direction!!\n    var length = 20;\n    var hex = 0xF44336;\n\n    var arrowHelper = new THREE.ArrowHelper(direction, position, length, hex);\n    var arrowUpdate = {\n        'direction': {\n            'i': direction.x,\n            'j': direction.y,\n            'k': direction.z\n        },\n        'position': {\n            'i': position.x,\n            'j': position.y,\n            'k': position.z\n        }\n    };\n\n    scene.add(arrowHelper);\n\n    var gui = new dat.GUI({\n        autoPlace: false\n    });\n\n    var customContainer = document.getElementById('my-gui-container');\n    customContainer.appendChild(gui.domElement);\n\n    var directionFolder = gui.addFolder('Plane direction');\n    var frameIndexControllerDirectionI = directionFolder.add(arrowUpdate.direction, 'i', -1, 1);\n    var frameIndexControllerDirectionJ = directionFolder.add(arrowUpdate.direction, 'j', -1, 1);\n    var frameIndexControllerDirectionK = directionFolder.add(arrowUpdate.direction, 'k', -1, 1);\n    directionFolder.open();\n\n    var positionFolder = gui.addFolder('Plane position');\n    var frameIndexControllerOriginI = positionFolder.add(arrowUpdate.position, 'i', -61.5, 61.5);\n    var frameIndexControllerOriginJ = positionFolder.add(arrowUpdate.position, 'j', -22.5, 22.5);\n    var frameIndexControllerOriginK = positionFolder.add(arrowUpdate.position, 'k', -33.5, 33.5);\n    positionFolder.open();\n\n    frameIndexControllerDirectionI.onChange(function(value) {\n        var newDirection = new THREE.Vector3(value, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerDirectionJ.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, value, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerDirectionK.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, value);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginI.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(value, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginJ.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, value, arrowUpdate.position.k);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginK.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, value);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n};\n\n},{\"../../modules/controls/OrbitControls2D\":2,\"../../modules/geometries/geometries.slice\":4}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n\n},{\"../core/Intersections\":3}]},{},[1])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats, dat*/\n'use strict';\n\nvar vjsSliceGeometry = require('../../modules/geometries/geometries.slice');\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\n\n// standard global variables\nvar controls, renderer, scene, camera, statsyay;\n\n// FUNCTIONS\nfunction init() {\n\n    // this function is executed on each animation frame\n    function animate() {\n        // render\n        controls.update();\n        renderer.render(scene, camera);\n        statsyay.update();\n\n        // request new frame\n        requestAnimationFrame(function() {\n            animate();\n        });\n    }\n\n    // renderer\n    var threeD = document.getElementById('r3d');\n    renderer = new THREE.WebGLRenderer({\n        antialias: true\n    });\n    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n    renderer.setClearColor(0xFFFFFF, 1);\n\n    var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n    window.console.log(maxTextureSize);\n\n    threeD.appendChild(renderer.domElement);\n\n    // stats\n    statsyay = new Stats();\n    threeD.appendChild(statsyay.domElement);\n\n    // scene\n    scene = new THREE.Scene();\n    // camera\n    camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n    camera.position.x = 100;\n    camera.position.y = 100;\n    camera.position.z = 100;\n    camera.lookAt(scene.position);\n    // controls\n    controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n    animate();\n}\n\nwindow.onload = function() {\n    // init threeJS...\n    init();\n\n    // make a box!\n    var dimensions = new THREE.Vector3(123, 45, 67);\n    var boxGeometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);\n    var boxMaterial = new THREE.MeshBasicMaterial({\n        wireframe: true,\n        color: 0x61F2F3\n    });\n    var box = new THREE.Mesh(boxGeometry, boxMaterial);\n    scene.add(box);\n\n    // make a slice!\n    var halfDimensions = dimensions.clone().divideScalar(2);\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = center.clone();\n    var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n\n    var sliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, position, direction);\n    var sliceMaterial = new THREE.MeshBasicMaterial({\n        'side': THREE.DoubleSide,\n        'transparency': true,\n        'color': 0x03A9F4\n    });\n    var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n    scene.add(slice);\n\n    // make the direction!!\n    var length = 20;\n    var hex = 0xF44336;\n\n    var arrowHelper = new THREE.ArrowHelper(direction, position, length, hex);\n    var arrowUpdate = {\n        'direction': {\n            'i': direction.x,\n            'j': direction.y,\n            'k': direction.z\n        },\n        'position': {\n            'i': position.x,\n            'j': position.y,\n            'k': position.z\n        }\n    };\n\n    scene.add(arrowHelper);\n\n    var gui = new dat.GUI({\n        autoPlace: false\n    });\n\n    var customContainer = document.getElementById('my-gui-container');\n    customContainer.appendChild(gui.domElement);\n\n    var directionFolder = gui.addFolder('Plane direction');\n    var frameIndexControllerDirectionI = directionFolder.add(arrowUpdate.direction, 'i', -1, 1);\n    var frameIndexControllerDirectionJ = directionFolder.add(arrowUpdate.direction, 'j', -1, 1);\n    var frameIndexControllerDirectionK = directionFolder.add(arrowUpdate.direction, 'k', -1, 1);\n    directionFolder.open();\n\n    var positionFolder = gui.addFolder('Plane position');\n    var frameIndexControllerOriginI = positionFolder.add(arrowUpdate.position, 'i', -61.5, 61.5);\n    var frameIndexControllerOriginJ = positionFolder.add(arrowUpdate.position, 'j', -22.5, 22.5);\n    var frameIndexControllerOriginK = positionFolder.add(arrowUpdate.position, 'k', -33.5, 33.5);\n    positionFolder.open();\n\n    frameIndexControllerDirectionI.onChange(function(value) {\n        var newDirection = new THREE.Vector3(value, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerDirectionJ.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, value, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerDirectionK.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, value);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        arrowHelper.setDirection(newDirection);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginI.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(value, arrowUpdate.position.j, arrowUpdate.position.k);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginJ.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, value, arrowUpdate.position.k);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n\n    frameIndexControllerOriginK.onChange(function(value) {\n        var newDirection = new THREE.Vector3(arrowUpdate.direction.i, arrowUpdate.direction.j, arrowUpdate.direction.k);\n        newDirection.normalize();\n        var newPosition = new THREE.Vector3(arrowUpdate.position.i, arrowUpdate.position.j, value);\n\n        scene.remove(arrowHelper);\n        arrowHelper = new THREE.ArrowHelper(newDirection, newPosition, length, hex);\n        scene.add(arrowHelper);\n\n        // is memory leaking???\n        var newSliceGeometry = new vjsSliceGeometry(halfDimensions, center, orientation, newPosition, newDirection);\n        slice.geometry = newSliceGeometry;\n        slice.geometry.verticesNeedUpdate = true;\n    });\n};\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n","'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n"],"sourceRoot":"/source/"}