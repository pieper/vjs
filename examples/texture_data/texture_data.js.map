{"version":3,"sources":["examples/texture_data/texture_data.js","examples/texture_data/node_modules/browserify/node_modules/browser-pack/_prelude.js","examples/texture_data/app/examples/texture_data/texture_data.js","examples/texture_data/app/modules/controls/OrbitControls2D.js","examples/texture_data/app/modules/core/Intersections.js","examples/texture_data/app/modules/geometries/geometries.slice.js","examples/texture_data/app/modules/helpers/helpers.series.js","examples/texture_data/app/modules/loaders/loaders.dicom.js","examples/texture_data/app/modules/models/models.frame.js","examples/texture_data/app/modules/models/models.series.js","examples/texture_data/app/modules/models/models.stack.js","examples/texture_data/app/modules/parsers/parsers.dicom.js","examples/texture_data/app/modules/shaders/shaders.data.js","examples/texture_data/node_modules/dicom-parser/dist/dicomParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","init","animate","spheres","testSpheres","nbSpheres","position","x","bbox","directions","y","z","steps","controls","update","renderer","render","scene","camera","stats","requestAnimationFrame","threeD","document","getElementById","THREE","WebGLRenderer","antialias","setSize","offsetWidth","offsetHeight","setClearColor","maxTextureSize","context","getParameter","MAX_TEXTURE_SIZE","window","console","log","appendChild","domElement","Stats","Scene","PerspectiveCamera","lookAt","vjsOrbitControl2D","createSphere","material","direction","Vector3","Math","random","step","radius","floor","sphereGeometry","SphereGeometry","sphere","Mesh","push","add","bboxMin","bboxMax","vjsLoaderDicom","vjsShadersData","onload","file","loader","load","message","stack","_series","_stack","prepare","geometry","BoxGeometry","applyMatrix","Matrix4","makeTranslation","_ijk2LPS","MeshBasicMaterial","wireframe","color","cube","textures","m","_nbTextures","tex","DataTexture","_rawData","_textureSize","RGBFormat","UnsignedByteType","UVMapping","ClampToEdgeWrapping","NearestFilter","needsUpdate","uniforms","parameters","uTextureSize","value","uTextureContainer","uDataDimensions","_columns","_rows","_numberOfFrames","uWorldToData","_lps2IJK","uWindowLevel","_windowLevel","uNumberOfChannels","_numberOfChannels","uBitsAllocated","_bitsAllocated","uInvert","_invert","sliceMaterial","ShaderMaterial","side","DoubleSide","transparency","vertexShader","fragmentShader","applyMatrix4","min","max","bboxCenter","gui","dat","GUI","autoPlace","customContainer","stackFolder","addFolder","windowWidthUpdate","_minMax","onChange","windowCenterUpdate","invertUpdate","open","ballsFolder","numberOfSpheresUpdate","diff","j","abs","k","remove","shift","../../modules/controls/OrbitControls2D","../../modules/loaders/loaders.dicom","../../modules/shaders/shaders.data",2,"OrbitControls2D","object","getAutoRotationAngle","PI","scope","autoRotateSpeed","getZoomScale","pow","zoomSpeed","onMouseDown","event","enabled","preventDefault","button","mouseButtons","ORBIT","noRotate","state","STATE","ROTATE","rotateStart","set","clientX","clientY","ZOOM","noZoom","DOLLY","dollyStart","PAN","noPan","panStart","NONE","addEventListener","onMouseMove","onMouseUp","dispatchEvent","startEvent","element","body","rotateEnd","rotateDelta","subVectors","rotateLeft","clientWidth","rotateSpeed","rotateUp","clientHeight","copy","dollyEnd","dollyDelta","dollyIn","dollyOut","panEnd","panDelta","pan","removeEventListener","endEvent","onMouseWheel","stopPropagation","delta","undefined","wheelDelta","detail","onKeyDown","noKeys","keyCode","keys","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","dx","dy","distance","sqrt","TOUCH_PAN","touchmove","touchend","this","target","center","minDistance","maxDistance","Infinity","autoRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","MOUSE","MIDDLE","theta","phi","EPS","Vector2","panOffset","offset","phiDelta","thetaDelta","scale","lastPosition","lastQuaternion","Quaternion","target0","clone","position0","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","angle","panLeft","te","matrix","elements","multiplyScalar","panUp","deltaX","deltaY","fov","sub","targetDistance","tan","top","right","left","zoom","bottom","warn","dollyScale","updateProjectionMatrix","applyQuaternion","atan2","sin","cos","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","prototype","Object","create","EventDispatcher","constructor",3,"VJS","intersections","obbPlane","obb","plane","t1","toOBBSpace","t0","planeOBB","normalize","halfDimensions","ray","orientation","intersection","rayPlane","toOBBSpaceInvert",4,"vjsIntersections","geometries","slice","centerOfMass","orderedIntersections","orderIntersections","formatIntersections","formatIntersectionsXY","point","xy","sliceShape","Shape","moveTo","lineTo","ShapeGeometry","vertices","verticesNeedUpdate","points","divideScalar","reference","a0","b0","c0","x0","y0","z0","l0","origin","base","crossVectors","orderedpoints","a1","b1","c1","x1","y1","z1","l1","thetaAngle","sort","b","../core/Intersections",5,"vjsSliceGeometries","helpers","series","Object3D","_uniforms","_frameIndex","_slice","_border","merge","seriesHelper","addSeries","getStack","stackIndex","dimensions","_dimensions","_halfDimensions","sliceGeometry","round","mySliceMaterial","borderMaterial","LineBasicMaterial","polygonOffset","polygonOffsetFactor","borderGeometry","Geometry","Line","updateSliceGeometry","updateBorderGeometry","../geometries/geometries.slice","../shaders/shaders.data",6,"parsers","dicom","models","frame","loaders","manager","DefaultLoadingManager","crossOrigin","responseType","_imageHelper","_image","onLoad","onProgress","onError","XHRLoader","setCrossOrigin","setResponseType","response","parse","dicomParser","id","_seriesInstanceUID","seriesInstanceUID","numberOfFrames","numberOfChannels","rows","columns","_pixelData","extractPixelData","_pixelSpacing","pixelSpacing","_sliceThickness","sliceThickness","_imageOrientation","imageOrientation","_imagePosition","imagePosition","_dimensionIndexValues","dimensionIndexValues","bitsAllocated","_instanceNumber","instanceNumber","minMaxPixelData","_frame","../helpers/helpers.series","../models/models.frame","../models/models.series","../models/models.stack","../parsers/parsers.dicom",7,"_id","_stackID","_imagePositionPatient","_imageOrientationPatient","row","column","_spacingBetweenSlices",8,"_concatenationUID","_seriesNumber","_dimensionIndexSequence","_photometricInterpretation","sameSeriesUID",9,"_uid","_origin","_orientation","_windowCenter","_windowWidth","_spacing","_direction","orderFrames","zSpacing","_pixelAspectRatio","xCosine","yCosine","zCosine","baseX","baseY","baseZ","getInverse","nbVoxels","ii","Uint8Array","frameDimension","textureDimension","time","jj","frameIndex","inFrameIndex","textureIndex","inTextureIndex","rawValue","lsb","msb","width","orderFrameOnDimensionIndices","toString","parseInt","computeDistance","normal","_dist","map","bind","sameStackID","join",10,"arrayBuffer","_arrayBuffer","byteArray","_dataSet","parseDicom","string","modality","sopInstanceUID","transferSyntaxUID","photometricInterpretation","planarConfiguration","uint16","samplesPerPixel","intString","perFrameFunctionnalGroupSequence","x52009230","planeOrientationSequence","items","dataSet","x00209116","split","Number","pixelAspectRatio","x00209113","x2005140f","x00289110","floatString","pixelRepresentation","highBit","rescaleIntercept","philipsPrivateSequence","x00289145","rescaleSlope","windowCenter","x00289132","windowWidth","x00209111","x00209157","nbValues","uint32","inStackPositionNumber","stackID","dPixelData","pixelDataElement","x7fe00010","buffer","dataOffset","ePixelData","pixelDataOffset","numPixels","frameOffset","Uint16Array","Int16Array","encodedPixelData","nPixels","ybrIndex","rgbaIndex","cb","cr","pixelData","minMax","index","spv","frameOfReferenceUID","imageJqueryDom","seriesNumber","find","text","dicom-parser",11,"shaders","data",12,"root","factory","define","amd","Package","options","readPrefix","littleEndianByteStream","seek","prefix","readFixedString","readPart10Header","warnings","readDicomElementExplicit","tag","parser","littleEndianByteArrayParser","metaHeaderDataSet","DataSet","byteArrayParser","readTransferSyntax","x00020010","transferSyntaxElement","isExplicit","transferSyntax","getDataSetByteStream","ByteStream","bigEndianByteArrayParser","mergeDataSets","instanceDataSet","propertyName","hasOwnProperty","concat","readDataSet","explicit","dataSetByteStream","parseDicomDataSetExplicit","parseDicomDataSetImplicit","ex","exception","parseTheByteStream","readUint16","readInt16","int16","readUint32","readInt32","int32","readFloat","byteArrayForParsingFloat","floatArray","Float32Array","readDouble","Float64Array","result","byte","String","fromCharCode","readByteStream","numBytes","byteArrayView","getByteArrayParser","defaultParser","numStringValues","fixedString","numMatching","match","values","trim","replace","parseFloat","findEndOfEncapsulatedElement","byteStream","encapsulatedPixelData","basicOffsetTable","fragments","basicOffsetTableItemTag","readTag","basicOffsetTableItemlength","numFragments","baseOffset","findItemDelimitationItemAndSetElementLength","itemDelimitationItemLength","maxPosition","groupNumber","elementNumber","itemDelimiterLength","untilTag","readDicomElementImplicit","getDataLengthSizeInBytesForVR","vr","dataLengthSizeBytes","hadUndefinedLength","readSequenceItemsExplicit","nextTag","readSequenceItemsImplicit","getPixelDataFromFragments","bufferSize","pixelDataIndex","fragmentOffset","readFragmentsUntil","endOfFrame","fragment","readSequenceItem","readEncapsulatedPixelDataWithBasicOffsetTable","numFrames","endOfFrameOffset","readEncapsulatedDataNoBasicOffsetTable","readEncapsulatedPixelData","readDicomDataSetExplicitUndefinedLength","readSequenceItemExplicit","item","readSQElementUndefinedLengthExplicit","readSQElementKnownLengthExplicit","readDicomDataSetImplicitUndefinedLength","readSequenceItemImplicit","readSQElementUndefinedLengthImplicit","readSQElementKnownLengthImplicit","substr","explicitDataSetToJS","omitPrivateAttibutes","maxElementLength","isPrivateTag","sequenceItems","asString","explicitElementToString","multiElementToString","numItems","func","textResult","isStringVr","num","toUpperCase","stringVrs","AE","AS","AT","CS","DA","DS","DT","FL","FD","IS","LO","LT","OB","OD","OF","OW","PN","SH","SL","SQ","SS","ST","TM","UI","UL","UN","UR","US","UT","lastGroupDigit","groupIsOdd","parsePN","personName","stringValues","familyName","givenName","middleName","suffix","parseDA","date","yyyy","substring","mm","dd","year","month","day","parseTM","hh","ss","ffffff","hours","minutes","seconds","fractionalSeconds"],"mappings":"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","file":"examples/texture_data/texture_data.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* globals Stats, dat*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\nvar vjsShadersData = require('../../modules/shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, bbox, bboxMin, bboxMax, spheres, directions, steps, testSpheres;\n\n// FUNCTIONS\nfunction init() {\n\n  testSpheres = {\n    'nbSpheres': 20\n  };\n\n  // this function is executed on each animation frame\n  function animate() {\n    // update spheres positions\n    if (spheres && spheres.length === testSpheres.nbSpheres) {\n\n      for (var i = 0; i < testSpheres.nbSpheres; i++) {\n\n        if (spheres[i].position.x >= bbox[1].x) {\n          directions[i].x = -1;\n        } else if (spheres[i].position.x <= bbox[0].x) {\n          directions[i].x = 1;\n        }\n\n        if (spheres[i].position.y >= bbox[1].y) {\n          directions[i].y = -1;\n        } else if (spheres[i].position.y <= bbox[0].y) {\n          directions[i].y = 1;\n        }\n\n        if (spheres[i].position.z >= bbox[1].z) {\n          directions[i].z = -1;\n        } else if (spheres[i].position.z <= bbox[0].z) {\n          directions[i].z = 1;\n        }\n\n        spheres[i].position.x += directions[i].x * steps[i].x;\n        spheres[i].position.y += directions[i].y * steps[i].y;\n        spheres[i].position.z += directions[i].z * steps[i].z;\n\n      }\n    }\n\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    stats.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  stats = new Stats();\n  threeD.appendChild(stats.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 150;\n  camera.position.y = 150;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  animate();\n}\n\nfunction createSphere(position, material) {\n  var direction = new THREE.Vector3(Math.random() < 0.5 ? -1 : 1, Math.random() < 0.5 ? -1 : 1, Math.random() < 0.5 ? -1 : 1);\n  var step = new THREE.Vector3(Math.random(), Math.random(), Math.random());\n  var radius = Math.floor((Math.random() * 30) + 1);\n  var sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);\n  var sphere = new THREE.Mesh(sphereGeometry, material);\n  sphere.position.x = bbox[0].x + (bbox[1].x - bbox[0].x) / 2;\n  sphere.position.y = bbox[0].y + (bbox[1].y - bbox[0].y) / 2;\n  sphere.position.z = bbox[0].z + (bbox[1].z - bbox[0].z) / 2;\n\n  spheres.push(sphere);\n  directions.push(direction);\n  steps.push(step);\n\n  scene.add(sphere);\n}\n\nwindow.onload = function() {\n\n  // init threeJS...\n  init();\n\n  var file = ['../../data/dcm/fruit.dcm'];\n\n  // instantiate the loader\n  var loader = new vjsLoaderDicom();\n  loader.load(\n      file,\n      // on load\n        function(message) {\n\n          // float textures to shaders\n          //http://jsfiddle.net/greggman/upZ7V/\n          //http://jsfiddle.net/greggman/LMbhk/\n\n          // merge images if needed!\n          // prepare images (generate convenience vars at all image/stack/frame levels)\n          // view the stack (N slices to start...)\n          window.console.log('all parsed');\n\n          // those operations could be async too!\n          // prepare the texture!\n          var stack = message._series._stack[0];\n          window.console.log(stack);\n          stack.prepare();\n\n          // make a box!\n          var geometry = new THREE.BoxGeometry(896, 896, 60);\n          geometry.applyMatrix(new THREE.Matrix4().makeTranslation(448, 448, 30));\n          geometry.applyMatrix(stack._ijk2LPS);\n          var material = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0x61F2F3\n          });\n          var cube = new THREE.Mesh(geometry, material);\n          scene.add(cube);\n\n          // create 16 luminance textures!\n          var textures = [];\n          for (var m = 0; m < stack._nbTextures; m++) {\n            // always pass it as RGB\n            // in shaders handle it depending on how channels/bytes\n            //\n            var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n            tex.needsUpdate = true;\n            textures.push(tex);\n          }\n\n          var uniforms = vjsShadersData.parameters.uniforms;\n          uniforms.uTextureSize.value = stack._textureSize; //this._sliceCore._volumeCore._textureSize;\n          // array of 16 textures\n          uniforms.uTextureContainer.value = textures;\n          // texture dimensions\n          uniforms.uDataDimensions.value = new THREE.Vector3(stack._columns, stack._rows, stack._numberOfFrames); //[stack._columns, stack._rows, stack._numberOfFrames];\n          // world to model\n          uniforms.uWorldToData.value = stack._lps2IJK; //new THREE.Matrix4().makeTranslation(448, 448, 30); //new THREE.Matrix4(); //stack._lps2IJK;\n          // window level\n          uniforms.uWindowLevel.value = stack._windowLevel;\n          uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n          uniforms.uBitsAllocated.value = stack._bitsAllocated;\n          uniforms.uInvert.value = stack._invert;\n\n          var sliceMaterial = new THREE.ShaderMaterial({\n            // 'wireframe': true,\n            'side': THREE.DoubleSide,\n            'transparency': true,\n            'uniforms': uniforms,\n            'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n            'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n          });\n\n          bboxMax = new THREE.Vector3(896, 896, 60).applyMatrix4(stack._ijk2LPS);\n          bboxMin = new THREE.Vector3(0, 0, 0).applyMatrix4(stack._ijk2LPS);\n          bbox = [\n              new THREE.Vector3(Math.min(bboxMin.x, bboxMax.x), Math.min(bboxMin.y, bboxMax.y), Math.min(bboxMin.z, bboxMax.z)),\n              new THREE.Vector3(Math.max(bboxMin.x, bboxMax.x), Math.max(bboxMin.y, bboxMax.y), Math.max(bboxMin.z, bboxMax.z))\n          ];\n          var bboxCenter = new THREE.Vector3(\n              bbox[0].x + (bbox[1].x - bbox[0].x) / 2,\n              bbox[0].y + (bbox[1].y - bbox[0].y) / 2,\n              bbox[0].z + (bbox[1].z - bbox[0].z) / 2);\n\n          spheres = [];\n          directions = [];\n          steps = [];\n          for (var i = 0; i < testSpheres.nbSpheres; i++) {\n            createSphere(bboxCenter, sliceMaterial);\n          }\n\n          var gui = new dat.GUI({\n            autoPlace: false\n          });\n\n          var customContainer = document.getElementById('my-gui-container');\n          customContainer.appendChild(gui.domElement);\n\n          var stackFolder = gui.addFolder('Stack');\n          var windowWidthUpdate = stackFolder.add(stack, '_windowWidth', 1, stack._minMax[1]).step(1);\n          windowWidthUpdate.onChange(function(value){\n            uniforms.uWindowLevel.value[1] = value;\n          });\n          var windowCenterUpdate = stackFolder.add(stack, '_windowCenter', stack._minMax[0], stack._minMax[1]).step(1);\n          windowCenterUpdate.onChange(function(value){\n            uniforms.uWindowLevel.value[0] = value;\n          });\n\n          var invertUpdate = stackFolder.add(stack, '_invert', 0, 1).step(1);\n          invertUpdate.onChange(function(value){\n            uniforms.uInvert.value = value;\n          });\n\n          stackFolder.open();\n\n          var ballsFolder = gui.addFolder('Spheres');\n          var numberOfSpheresUpdate = ballsFolder.add(testSpheres, 'nbSpheres', 1, 100).step(1);\n          ballsFolder.open();\n\n          numberOfSpheresUpdate.onChange(function(value) {\n            var diff = value - spheres.length;\n            if (diff > 0) {\n              for (var j = 0; j < diff; j++) {\n                createSphere(bboxCenter, sliceMaterial);\n              }\n\n            } else if (diff < 0) {\n              diff = Math.abs(diff);\n\n              for (var k = 0; k < diff; k++) {\n                scene.remove(spheres[0]);\n                spheres.shift();\n                directions.shift();\n                steps.shift();\n              }\n            }\n          });\n        },\n        // progress\n        function() {},\n        // error\n        function() {}\n    );\n};\n\n},{\"../../modules/controls/OrbitControls2D\":2,\"../../modules/loaders/loaders.dicom\":6,\"../../modules/shaders/shaders.data\":11}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n\n},{\"../core/Intersections\":3}],5:[function(require,module,exports){\n'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n\n},{\"../geometries/geometries.slice\":4,\"../shaders/shaders.data\":11}],6:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n\n},{\"../helpers/helpers.series\":5,\"../models/models.frame\":7,\"../models/models.series\":8,\"../models/models.stack\":9,\"../parsers/parsers.dicom\":10}],7:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n\n},{}],10:[function(require,module,exports){\n/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n\n},{\"dicom-parser\":12}],11:[function(require,module,exports){\n'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n\n},{}],12:[function(require,module,exports){\n/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));\n},{}]},{},[1])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* globals Stats, dat*/\n'use strict';\n\nvar vjsOrbitControl2D = require('../../modules/controls/OrbitControls2D');\nvar vjsLoaderDicom = require('../../modules/loaders/loaders.dicom');\nvar vjsShadersData = require('../../modules/shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n// standard global variables\nvar controls, renderer, stats, scene, camera, bbox, bboxMin, bboxMax, spheres, directions, steps, testSpheres;\n\n// FUNCTIONS\nfunction init() {\n\n  testSpheres = {\n    'nbSpheres': 20\n  };\n\n  // this function is executed on each animation frame\n  function animate() {\n    // update spheres positions\n    if (spheres && spheres.length === testSpheres.nbSpheres) {\n\n      for (var i = 0; i < testSpheres.nbSpheres; i++) {\n\n        if (spheres[i].position.x >= bbox[1].x) {\n          directions[i].x = -1;\n        } else if (spheres[i].position.x <= bbox[0].x) {\n          directions[i].x = 1;\n        }\n\n        if (spheres[i].position.y >= bbox[1].y) {\n          directions[i].y = -1;\n        } else if (spheres[i].position.y <= bbox[0].y) {\n          directions[i].y = 1;\n        }\n\n        if (spheres[i].position.z >= bbox[1].z) {\n          directions[i].z = -1;\n        } else if (spheres[i].position.z <= bbox[0].z) {\n          directions[i].z = 1;\n        }\n\n        spheres[i].position.x += directions[i].x * steps[i].x;\n        spheres[i].position.y += directions[i].y * steps[i].y;\n        spheres[i].position.z += directions[i].z * steps[i].z;\n\n      }\n    }\n\n    // render\n    controls.update();\n    renderer.render(scene, camera);\n    stats.update();\n\n    // request new frame\n    requestAnimationFrame(function() {\n      animate();\n    });\n  }\n\n  // renderer\n  var threeD = document.getElementById('r3d');\n  renderer = new THREE.WebGLRenderer({\n    antialias: true\n  });\n  renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);\n  renderer.setClearColor(0xFFFFFF, 1);\n\n  var maxTextureSize = renderer.context.getParameter(renderer.context.MAX_TEXTURE_SIZE);\n  window.console.log(maxTextureSize);\n\n  threeD.appendChild(renderer.domElement);\n\n  // stats\n  stats = new Stats();\n  threeD.appendChild(stats.domElement);\n\n  // scene\n  scene = new THREE.Scene();\n  // camera\n  camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 1, 10000000);\n  camera.position.x = 150;\n  camera.position.y = 150;\n  camera.position.z = 100;\n  camera.lookAt(scene.position);\n  // controls\n  controls = new vjsOrbitControl2D(camera, renderer.domElement);\n\n  animate();\n}\n\nfunction createSphere(position, material) {\n  var direction = new THREE.Vector3(Math.random() < 0.5 ? -1 : 1, Math.random() < 0.5 ? -1 : 1, Math.random() < 0.5 ? -1 : 1);\n  var step = new THREE.Vector3(Math.random(), Math.random(), Math.random());\n  var radius = Math.floor((Math.random() * 30) + 1);\n  var sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);\n  var sphere = new THREE.Mesh(sphereGeometry, material);\n  sphere.position.x = bbox[0].x + (bbox[1].x - bbox[0].x) / 2;\n  sphere.position.y = bbox[0].y + (bbox[1].y - bbox[0].y) / 2;\n  sphere.position.z = bbox[0].z + (bbox[1].z - bbox[0].z) / 2;\n\n  spheres.push(sphere);\n  directions.push(direction);\n  steps.push(step);\n\n  scene.add(sphere);\n}\n\nwindow.onload = function() {\n\n  // init threeJS...\n  init();\n\n  var file = ['../../data/dcm/fruit.dcm'];\n\n  // instantiate the loader\n  var loader = new vjsLoaderDicom();\n  loader.load(\n      file,\n      // on load\n        function(message) {\n\n          // float textures to shaders\n          //http://jsfiddle.net/greggman/upZ7V/\n          //http://jsfiddle.net/greggman/LMbhk/\n\n          // merge images if needed!\n          // prepare images (generate convenience vars at all image/stack/frame levels)\n          // view the stack (N slices to start...)\n          window.console.log('all parsed');\n\n          // those operations could be async too!\n          // prepare the texture!\n          var stack = message._series._stack[0];\n          window.console.log(stack);\n          stack.prepare();\n\n          // make a box!\n          var geometry = new THREE.BoxGeometry(896, 896, 60);\n          geometry.applyMatrix(new THREE.Matrix4().makeTranslation(448, 448, 30));\n          geometry.applyMatrix(stack._ijk2LPS);\n          var material = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0x61F2F3\n          });\n          var cube = new THREE.Mesh(geometry, material);\n          scene.add(cube);\n\n          // create 16 luminance textures!\n          var textures = [];\n          for (var m = 0; m < stack._nbTextures; m++) {\n            // always pass it as RGB\n            // in shaders handle it depending on how channels/bytes\n            //\n            var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n            tex.needsUpdate = true;\n            textures.push(tex);\n          }\n\n          var uniforms = vjsShadersData.parameters.uniforms;\n          uniforms.uTextureSize.value = stack._textureSize; //this._sliceCore._volumeCore._textureSize;\n          // array of 16 textures\n          uniforms.uTextureContainer.value = textures;\n          // texture dimensions\n          uniforms.uDataDimensions.value = new THREE.Vector3(stack._columns, stack._rows, stack._numberOfFrames); //[stack._columns, stack._rows, stack._numberOfFrames];\n          // world to model\n          uniforms.uWorldToData.value = stack._lps2IJK; //new THREE.Matrix4().makeTranslation(448, 448, 30); //new THREE.Matrix4(); //stack._lps2IJK;\n          // window level\n          uniforms.uWindowLevel.value = stack._windowLevel;\n          uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n          uniforms.uBitsAllocated.value = stack._bitsAllocated;\n          uniforms.uInvert.value = stack._invert;\n\n          var sliceMaterial = new THREE.ShaderMaterial({\n            // 'wireframe': true,\n            'side': THREE.DoubleSide,\n            'transparency': true,\n            'uniforms': uniforms,\n            'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n            'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n          });\n\n          bboxMax = new THREE.Vector3(896, 896, 60).applyMatrix4(stack._ijk2LPS);\n          bboxMin = new THREE.Vector3(0, 0, 0).applyMatrix4(stack._ijk2LPS);\n          bbox = [\n              new THREE.Vector3(Math.min(bboxMin.x, bboxMax.x), Math.min(bboxMin.y, bboxMax.y), Math.min(bboxMin.z, bboxMax.z)),\n              new THREE.Vector3(Math.max(bboxMin.x, bboxMax.x), Math.max(bboxMin.y, bboxMax.y), Math.max(bboxMin.z, bboxMax.z))\n          ];\n          var bboxCenter = new THREE.Vector3(\n              bbox[0].x + (bbox[1].x - bbox[0].x) / 2,\n              bbox[0].y + (bbox[1].y - bbox[0].y) / 2,\n              bbox[0].z + (bbox[1].z - bbox[0].z) / 2);\n\n          spheres = [];\n          directions = [];\n          steps = [];\n          for (var i = 0; i < testSpheres.nbSpheres; i++) {\n            createSphere(bboxCenter, sliceMaterial);\n          }\n\n          var gui = new dat.GUI({\n            autoPlace: false\n          });\n\n          var customContainer = document.getElementById('my-gui-container');\n          customContainer.appendChild(gui.domElement);\n\n          var stackFolder = gui.addFolder('Stack');\n          var windowWidthUpdate = stackFolder.add(stack, '_windowWidth', 1, stack._minMax[1]).step(1);\n          windowWidthUpdate.onChange(function(value){\n            uniforms.uWindowLevel.value[1] = value;\n          });\n          var windowCenterUpdate = stackFolder.add(stack, '_windowCenter', stack._minMax[0], stack._minMax[1]).step(1);\n          windowCenterUpdate.onChange(function(value){\n            uniforms.uWindowLevel.value[0] = value;\n          });\n\n          var invertUpdate = stackFolder.add(stack, '_invert', 0, 1).step(1);\n          invertUpdate.onChange(function(value){\n            uniforms.uInvert.value = value;\n          });\n\n          stackFolder.open();\n\n          var ballsFolder = gui.addFolder('Spheres');\n          var numberOfSpheresUpdate = ballsFolder.add(testSpheres, 'nbSpheres', 1, 100).step(1);\n          ballsFolder.open();\n\n          numberOfSpheresUpdate.onChange(function(value) {\n            var diff = value - spheres.length;\n            if (diff > 0) {\n              for (var j = 0; j < diff; j++) {\n                createSphere(bboxCenter, sliceMaterial);\n              }\n\n            } else if (diff < 0) {\n              diff = Math.abs(diff);\n\n              for (var k = 0; k < diff; k++) {\n                scene.remove(spheres[0]);\n                spheres.shift();\n                directions.shift();\n                steps.shift();\n              }\n            }\n          });\n        },\n        // progress\n        function() {},\n        // error\n        function() {}\n    );\n};\n","'use strict';\n\n/**\n * traversc: modified mouse wheel zoom to work with orthographic camera\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls2D = function(object, domElement) {\n\n    this.object = object;\n    this.domElement = (domElement !== undefined) ? domElement : document;\n\n    // API\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n\n    // Limits to how far you can dolly in and out\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n\n    var offset = new THREE.Vector3();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n\n    // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n\n    // events\n\n    var changeEvent = {\n        type: 'change'\n    };\n    var startEvent = {\n        type: 'start'\n    };\n    var endEvent = {\n        type: 'end'\n    };\n\n    this.rotateLeft = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function(angle) {\n\n        if (angle === undefined) {\n\n            angle = getAutoRotationAngle();\n\n        }\n\n        phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n\n        pan.add(panOffset);\n\n    };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (scope.object.fov !== undefined) {\n\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n\n        } else if (scope.object.top !== undefined) {\n\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / (element.clientWidth * this.object.zoom));\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / (element.clientHeight * this.object.zoom));\n\n        } else {\n\n            // camera neither orthographic or perspective\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n        }\n\n    };\n\n    //traversc: fix with orthographic camera zoom\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom *= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale /= dollyScale;\n        }\n    };\n\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) {\n            dollyScale = getZoomScale();\n        }\n        if (scope.object.top !== undefined) {\n            this.object.zoom /= dollyScale;\n            this.object.updateProjectionMatrix();\n        } else {\n            scale *= dollyScale;\n        }\n    };\n\n    this.update = function() {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        if (this.autoRotate && state === STATE.NONE) {\n\n            this.rotateLeft(getAutoRotationAngle());\n\n        }\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(pan);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n            this.dispatchEvent(changeEvent);\n\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n\n        }\n\n    };\n\n\n    this.reset = function() {\n\n        state = STATE.NONE;\n\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n\n        this.update();\n\n    };\n\n    this.getPolarAngle = function() {\n\n        return phi;\n\n    };\n\n    this.getAzimuthalAngle = function() {\n\n        return theta;\n\n    };\n\n    function getAutoRotationAngle() {\n\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n        return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n        event.preventDefault();\n\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            state = STATE.ROTATE;\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            state = STATE.DOLLY;\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) {\n                return;\n            }\n\n            state = STATE.PAN;\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        if (state !== STATE.NONE) {\n            document.addEventListener('mousemove', onMouseMove, false);\n            document.addEventListener('mouseup', onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function onMouseMove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        if (state === STATE.ROTATE) {\n\n            if (scope.noRotate === true) {\n                return;\n            }\n\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n            rotateStart.copy(rotateEnd);\n\n        } else if (state === STATE.DOLLY) {\n\n            if (scope.noZoom === true) {\n                return;\n            }\n\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                scope.dollyIn();\n\n            } else {\n\n                scope.dollyOut();\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n        } else if (state === STATE.PAN) {\n\n            if (scope.noPan === true) {\n                return;\n            }\n\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n\n            scope.pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.update();\n        }\n\n    }\n\n    function onMouseUp( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        document.removeEventListener('mousemove', onMouseMove, false);\n        document.removeEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var delta = 0;\n\n        if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9\n\n            delta = event.wheelDelta;\n\n        } else if (event.detail !== undefined) { // Firefox\n\n            delta = -event.detail;\n\n        }\n\n        if (delta > 0) {\n\n            scope.dollyOut();\n\n        } else {\n\n            scope.dollyIn();\n\n        }\n\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) {\n            return;\n        }\n\n        switch (event.keyCode) {\n\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n\n        }\n\n    }\n\n    function touchstart(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_ROTATE;\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_DOLLY;\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n\n                state = STATE.TOUCH_PAN;\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n        if (state !== STATE.NONE) {\n            scope.dispatchEvent(startEvent);\n        }\n\n    }\n\n    function touchmove(event) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n        switch (event.touches.length) {\n\n            case 1: // one-fingered touch: rotate\n\n                if (scope.noRotate === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_ROTATE) {\n                    return;\n                }\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n                rotateStart.copy(rotateEnd);\n\n                scope.update();\n                break;\n\n            case 2: // two-fingered touch: dolly\n\n                if (scope.noZoom === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_DOLLY) {\n                    return;\n                }\n\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n\n                if (dollyDelta.y > 0) {\n\n                    scope.dollyOut();\n\n                } else {\n\n                    scope.dollyIn();\n\n                }\n\n                dollyStart.copy(dollyEnd);\n\n                scope.update();\n                break;\n\n            case 3: // three-fingered touch: pan\n\n                if (scope.noPan === true) {\n                    return;\n                }\n                if (state !== STATE.TOUCH_PAN) {\n                    return;\n                }\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n\n                scope.pan(panDelta.x, panDelta.y);\n\n                panStart.copy(panEnd);\n\n                scope.update();\n                break;\n\n            default:\n\n                state = STATE.NONE;\n\n        }\n\n    }\n\n    function touchend( /* event */ ) {\n\n        if (scope.enabled === false) {\n            return;\n        }\n\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n\n    }\n\n    this.domElement.addEventListener('contextmenu', function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n};\n\nTHREE.OrbitControls2D.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls2D.prototype.constructor = THREE.OrbitControls2D;\n\n// export the frame module\nmodule.exports = THREE.OrbitControls2D;\n","'use strict';\n\nvar VJS = VJS || {};\n\n/**\n * intersections namespace\n * @namespace intersections\n * @memberOf VJS\n */\nVJS.intersections = VJS.intersections || {};\n\n\n/**\n * Compute intersection between oriented bounding box and a plane.\n * Returns intersection in plane's space (toOBBSpaceInvert applied).\n * Should return at least 3 intersections. If not, the plane and the box do not\n * intersect.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} obb - Oriented Bounding Box representation.\n * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.\n * @param {THREE.Vector3<THREE.Vector3>} obb.orientation - Orientation of the edges of the box.\n * @param {THREE.Vector3} obb.center - Center of the box.\n * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.\n * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {Array<THREE.Vector3>} List of all intersections, in plane's space.\n *\n * @todo toOBBSpace and toOBBSpaceInvert might be redundent.\n * @todo find best way to deal with different spaces.\n */\n\nVJS.intersections.obbPlane = function(obb, plane) {\n\n    //\n    // obb = { halfDimensions, orientation, center, toOBBSpace }\n    // plane = { position, direction }\n    //\n    //\n    // LOGIC:\n    //\n    // Test intersection of each edge of the Oriented Bounding Box with the Plane\n    // \n    // ALL EDGES \n    //\n    //      .+-------+  \n    //    .' |     .'|  \n    //   +---+---+'  |  \n    //   |   |   |   |  \n    //   |  ,+---+---+  \n    //   |.'     | .'   \n    //   +-------+'     \n    //\n    // SPACE ORIENTATION\n    //\n    //       +\n    //     j |\n    //       |\n    //       |   i \n    //   k  ,+-------+  \n    //    .'\n    //   +\n    //\n    //\n    // 1- Move Plane position and orientation in IJK space\n    // 2- Test Edges/ IJK Plane intersections\n    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox\n\n    var intersections = [];\n\n    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);\n    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);\n\n    var planeOBB = {\n        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),\n        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()\n    };\n\n    var bboxMin = new THREE.Vector3(\n        obb.center.x - obb.halfDimensions.x,\n        obb.center.y - obb.halfDimensions.y,\n        obb.center.z - obb.halfDimensions.z);\n    var bboxMax = new THREE.Vector3(\n        obb.center.x + obb.halfDimensions.x,\n        obb.center.y + obb.halfDimensions.y,\n        obb.center.z + obb.halfDimensions.z);\n\n    // 12 edges (i.e. ray)/plane intersection tests\n\n    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)\n    //\n    //       +\n    //       |\n    //       |\n    //       | \n    //      ,+---+---+\n    //    .'   \n    //   +   \n\n    var ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    var intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE LAST CORNER\n    //\n    //               +\n    //             .'\n    //   +-------+'\n    //           |\n    //           |\n    //           |\n    //           +\n    //\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE SECOND CORNER\n    //\n    //               +\n    //               |\n    //               |\n    //               |\n    //               +\n    //             .'\n    //           +'\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.y\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE THIRD CORNER\n    //\n    //      .+-------+  \n    //    .'\n    //   +\n    //   \n    //   \n    //   \n    //   \n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.z;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    // RAYS STARTING FROM THE FOURTH CORNER\n    //\n    //   \n    //   \n    //   +\n    //   |\n    //   |  \n    //   |\n    //   +-------+\n\n    ray = {\n        'position': new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),\n        'direction': obb.orientation.x\n    };\n\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    ray.direction = obb.orientation.y;\n    intersection = this.rayPlane(ray, planeOBB);\n    if (intersection &&\n        intersection.x >= bboxMin.x && intersection.y >= bboxMin.y && intersection.z >= bboxMin.z &&\n        intersection.x <= bboxMax.x && intersection.y <= bboxMax.y && intersection.z <= bboxMax.z) {\n        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));\n    }\n\n    return intersections;\n};\n\n/**\n * Compute intersection between a ray and a plane.\n *\n * @memberOf VJS.intersections\n * @public\n *\n * @param {Object} ray - Ray representation.\n * @param {THREE.Vector3} ray.position - position of normal which describes the ray.\n * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.\n * @param {Object} plane - Plane representation\n * @param {THREE.Vector3} plane.position - position of normal which describes the plane.\n * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.\n *\n * @returns {THREE.Vector3|null} Intersection between ray and plane or null.\n */\nVJS.intersections.rayPlane = function(ray, plane) {\n    // ray: {position, direction}\n    // plane: {position, direction}\n\n    if (ray.direction.dot(plane.direction) !== 0) {\n        //\n        // not parallel, move forward\n        //\n        // LOGIC:\n        //\n        // Ray equation: P = P0 + tV\n        // P = <Px, Py, Pz>\n        // P0 = <ray.position.x, ray.position.y, ray.position.z>\n        // V = <ray.direction.x, ray.direction.y, ray.direction.z>\n        //\n        // Therefore:\n        // Px = ray.position.x + t*ray.direction.x\n        // Py = ray.position.y + t*ray.direction.y\n        // Pz = ray.position.z + t*ray.direction.z\n        //\n        //\n        //\n        // Plane equation: ax + by + cz + d = 0\n        // a = plane.direction.x\n        // b = plane.direction.y\n        // c = plane.direction.z\n        // d = -( plane.direction.x*plane.position.x +\n        //        plane.direction.y*plane.position.y +\n        //        plane.direction.z*plane.position.z )\n        //\n        //\n        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz\n        // 2- find t\n        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection\n        //\n        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /\n            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);\n\n        var intersection = new THREE.Vector3(\n            ray.position.x + t * ray.direction.x,\n            ray.position.y + t * ray.direction.y,\n            ray.position.z + t * ray.direction.z);\n\n        return intersection;\n\n    }\n\n    return null;\n\n};\n\n// export the frame module\nmodule.exports = VJS.intersections;\n","'use strict';\n\nvar vjsIntersections = require('../core/Intersections');\n\nvar VJS = VJS || {};\n\n/**\n * geometries namespace\n * @namespace geometries\n * @memberOf VJS\n * @public\n */\nVJS.geometries = VJS.geometries || {};\n\n/**\n *\n * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}\n *\n * @constructor\n * @class\n * @memberOf VJS.geometries\n * @public\n *\n * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.\n * @param {THREE.Vector3} center - Center of the box to be sliced.\n * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)\n * @param {THREE.Vector3} position - Position of the cutting plane.\n * @param {THREE.Vector3} direction - Cross direction of the cutting plane.\n *\n * @example\n * // Define box to be sliced\n * var halfDimensions = new THREE.Vector(123, 45, 67);\n * var center = new THREE.Vector3(0, 0, 0);\n * var orientation = new THREE.Vector3(\n *   new THREE.Vector3(1, 0, 0),\n *   new THREE.Vector3(0, 1, 0),\n *   new THREE.Vector3(0, 0, 1)\n * );\n *\n * // Define slice plane\n * var position = center.clone();\n * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);\n *\n * // Create the slice geometry & materials\n * var sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);\n * var sliceMaterial = new THREE.MeshBasicMaterial({\n *   'side': THREE.DoubleSide,\n *   'color': 0xFF5722\n * });\n *\n *  // Create mesh and add it to the scene\n *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);\n *  scene.add(slice);\n */\nVJS.geometries.slice = function(halfDimensions, center, orientation, position, direction) {\n\n    //\n    // prepare data for the shape!\n    //\n    var obb = {\n        'halfDimensions': halfDimensions,\n        'center': center,\n        'orientation': orientation,\n        'toOBBSpace': new THREE.Matrix4(), // not necessary\n        'toOBBSpaceInvert': new THREE.Matrix4() // not necessary\n    };\n\n    var plane = {\n        'position': position,\n        'direction': direction\n    };\n\n    // BOOM!\n    var intersections = vjsIntersections.obbPlane(obb, plane);\n\n    if (intersections.length < 3) {\n        window.console.log('WARNING: Less than 3 intersections between OBB and Plane.');\n        window.console.log('OBB');\n        window.console.log(obb);\n        window.console.log('Plane');\n        window.console.log(plane);\n        window.console.log('exiting...');\n    }\n\n    var centerOfMass = this.centerOfMass(intersections);\n    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);\n\n    // split for convenience\n    var formatIntersections = [];\n    var formatIntersectionsXY = [];\n    for (var k = 0; k < orderedIntersections.length; k++) {\n        formatIntersections.push(orderedIntersections[k].point);\n        formatIntersectionsXY.push(orderedIntersections[k].xy);\n    }\n\n    //\n    // Create Shape\n    //\n    var sliceShape = new THREE.Shape();\n    // move to first point!\n    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    // loop through all points!\n    for (var l = 1; l < formatIntersectionsXY.length; l++) {\n        // project each on plane!\n        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);\n    }\n\n    // close the shape!\n    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);\n\n    //\n    // Generate Geometry from shape\n    // It does triangulation for us!\n    //\n    THREE.ShapeGeometry.call(this, sliceShape);\n    this.type = 'SliceGeometry';\n\n    // update real position of each vertex! (not in 2d)\n    this.vertices = formatIntersections;\n    this.verticesNeedUpdate = true;\n};\n\nVJS.geometries.slice.prototype = Object.create(THREE.ShapeGeometry.prototype);\nVJS.geometries.slice.prototype.constructor = VJS.geometries.slice;\n\n/**\n *\n * Convenience function to extract center of mass from list of points.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.\n *\n * @returns {THREE.Vector3} Center of mass from given points.\n */\nVJS.geometries.slice.prototype.centerOfMass = function(points) {\n    var centerOfMass = new THREE.Vector3(0, 0, 0);\n    for (var i = 0; i < points.length; i++) {\n        centerOfMass.x += points[i].x;\n        centerOfMass.y += points[i].y;\n        centerOfMass.z += points[i].z;\n    }\n    centerOfMass.divideScalar(points.length);\n\n    return centerOfMass;\n};\n\n/**\n *\n * Order 3D planar points around a refence point.\n *\n * @private\n *\n * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.\n * @param {THREE.Vector3} reference - Reference point for ordering.\n * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.\n *\n * @returns {Array<Object>} Set of object representing the ordered points.\n */\nVJS.geometries.slice.prototype.orderIntersections = function(points, reference, direction) {\n\n    var a0 = points[0].x;\n    var b0 = points[0].y;\n    var c0 = points[0].z;\n    var x0 = points[0].x - reference.x;\n    var y0 = points[0].y - reference.y;\n    var z0 = points[0].z - reference.z;\n    var l0 = {\n        origin: new THREE.Vector3(a0, b0, c0),\n        direction: new THREE.Vector3(x0, y0, z0).normalize()\n    };\n\n    var base = new THREE.Vector3(0, 0, 0)\n        .crossVectors(l0.direction, direction)\n        .normalize();\n\n    var orderedpoints = [];\n\n    // other lines // if inter, return location + angle\n    for (var j = 0; j < points.length; j++) {\n\n        var a1 = points[j].x;\n        var b1 = points[j].y;\n        var c1 = points[j].z;\n        var x1 = points[j].x - reference.x;\n        var y1 = points[j].y - reference.y;\n        var z1 = points[j].z - reference.z;\n\n        var l1 = {\n            origin: new THREE.Vector3(a1, b1, c1),\n            direction: new THREE.Vector3(x1, y1, z1).normalize()\n        };\n\n        var x = l0.direction.dot(l1.direction);\n        var y = base.dot(l1.direction);\n\n        var thetaAngle = Math.atan2(y, x);\n        var theta = thetaAngle * (180 / Math.PI);\n        orderedpoints.push({\n            'angle': theta,\n            'point': l1.origin,\n            'xy': {\n                'x': x,\n                'y': y\n            }\n        });\n    }\n\n    orderedpoints.sort(function(a, b) {\n        return a.angle - b.angle;\n    });\n\n    return orderedpoints;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.geometries.slice;\n","'use strict';\n\nvar vjsSliceGeometries = require('../geometries/geometries.slice');\nvar vjsShadersData = require('../shaders/shaders.data');\n\n\nvar VJS = VJS || {};\n\n/**\n * helpers namespace\n * @namespace helpers\n * @memberOf VJS\n * @public\n */\nVJS.helpers = VJS.helpers || {};\n\n//\n// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\nVJS.helpers.series = function() {\n\n  THREE.Object3D.call(this);\n\n  // ...\n  this._series = null;\n  this._uniforms = null;\n  this._frameIndex = null;\n  this._slice = null;\n  this._border = null;\n\n};\n\nVJS.helpers.series.prototype = Object.create(THREE.Object3D.prototype);\n\nVJS.helpers.series.prototype.constructor = VJS.helpers.series;\n\nVJS.helpers.series.prototype.merge = function(seriesHelper) {\n  return this._series.merge(seriesHelper._series);\n};\n\nVJS.helpers.series.prototype.addSeries = function(series) {\n  this._series = series;\n};\n\nVJS.helpers.series.prototype.getStack = function(stackIndex) {\n  return stackIndex;\n};\n\nVJS.helpers.series.prototype.prepare = function() {\n\n  window.console.log('helpers Series Prepare!!!');\n  if (this._series) {\n\n    // get first stack!\n    var stack = this._series._stack[0];\n    stack.prepare();\n    window.console.log(stack);\n\n    // Convenience function\n    var dimensions = stack._dimensions;\n    var halfDimensions = stack._halfDimensions;\n\n    // voxel offset\n    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n    // Bounding Box\n    var geometry = new THREE.BoxGeometry(\n        dimensions.x, dimensions.y, dimensions.z);\n    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    geometry.applyMatrix(stack._ijk2LPS);\n    var material = new THREE.MeshBasicMaterial({\n      wireframe: true,\n      color: 0x61F2F3\n    });\n    var cube = new THREE.Mesh(geometry, material);\n    this.add(cube);\n\n    // Slice\n    // Geometry\n    //\n\n    // Define the bouding box used to generate the slice geometry\n    // center\n    // orientation\n    // and half-dimensions\n    var center = new THREE.Vector3(0, 0, 0);\n    var orientation = new THREE.Vector3(\n        new THREE.Vector3(1, 0, 0),\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3(0, 0, 1));\n\n    var position = new THREE.Vector3(\n      Math.floor(stack._halfDimensions.x),\n      Math.floor(stack._halfDimensions.y),\n      Math.floor(stack._halfDimensions.z) + 0.5 - stack._halfDimensions.z\n    );\n\n    var direction = new THREE.Vector3(0, 0, 1);\n\n    var sliceGeometry = new vjsSliceGeometries(\n        halfDimensions, center, orientation,\n        position, direction);\n    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n        halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n    sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n    // update _framIndex\n    this._frameIndex = Math.round(halfDimensions.z);\n\n    // Slice\n    // Material\n    var textures = [];\n    for (var m = 0; m < stack._nbTextures; m++) {\n      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.RGBFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);\n      tex.needsUpdate = true;\n      textures.push(tex);\n    }\n\n    var sliceMaterial = new THREE.ShaderMaterial({\n      // 'wireframe': true,\n      'side': THREE.DoubleSide,\n      'transparency': true,\n      'uniforms': vjsShadersData.parameters.uniforms,\n      'vertexShader': \"#define GLSLIFY 1\\nvarying highp vec4 vPos;\\n\\n//\\n// main\\n//\\nvoid main() {\\n\\n  vPos = modelMatrix * vec4(position, 1.0 );\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\\n\\n}\",\n      'fragmentShader': \"#define GLSLIFY 1\\nvec4 sampleAs3DTexture(sampler2D textureContainer[16], vec3 textureCoordinate, vec3 dataSize, float textureSize) {\\n\\n  float slicePixelSize = 1.0 / textureSize;\\n  // Model coordinate (IJK) to data index\\n  float index = textureCoordinate.x * dataSize.x + textureCoordinate.y * dataSize.y * dataSize.x + textureCoordinate.z * dataSize.z * dataSize.y * dataSize.x;\\n\\n  // Map data index to right sampler2D texture\\n  float textureIndex = floor(index / (textureSize*textureSize));\\n  float inTextureIndex = mod(index, textureSize*textureSize);\\n\\n  // Get row and column in the texture\\n  float rowIndex = floor(inTextureIndex/textureSize);\\n  float colIndex = mod(inTextureIndex, textureSize);\\n\\n  // Map row and column to uv\\n  vec2 uv = vec2(0,0);\\n  uv.x = slicePixelSize * 0.5 + colIndex * slicePixelSize;\\n  uv.y = 1.0 - (slicePixelSize * 0.5 + rowIndex * slicePixelSize);\\n\\n  vec4 dataValue = vec4(0, 0, 0, 1);\\n  if(textureIndex == 0.0){\\n    dataValue = texture2D(textureContainer[0], uv);\\n  }\\n  else if(textureIndex == 1.0){\\n    dataValue = texture2D(textureContainer[1], uv);\\n  }\\n  else if(textureIndex == 2.0){\\n    dataValue = texture2D(textureContainer[2], uv);\\n  }\\n  else if(textureIndex == 3.0){\\n    dataValue = texture2D(textureContainer[3], uv);\\n  }\\n  else if(textureIndex == 4.0){\\n    dataValue = texture2D(textureContainer[4], uv);\\n  }\\n  else if(textureIndex == 5.0){\\n    dataValue = texture2D(textureContainer[5], uv);\\n  }\\n  else if(textureIndex == 6.0){\\n    dataValue = texture2D(textureContainer[6], uv);\\n  }\\n  else if(textureIndex == 7.0){\\n    dataValue = texture2D(textureContainer[7], uv);\\n  }\\n  else if(textureIndex == 8.0){\\n    dataValue = texture2D(textureContainer[8], uv);\\n  }\\n  else if(textureIndex == 9.0){\\n    dataValue = texture2D(textureContainer[9], uv);\\n  }\\n  else if(textureIndex == 10.0){\\n    dataValue = texture2D(textureContainer[10], uv);\\n  }\\n  else if(textureIndex == 11.0){\\n    dataValue = texture2D(textureContainer[11], uv);\\n  }\\n  else if(textureIndex == 12.0){\\n    dataValue = texture2D(textureContainer[12], uv);\\n  }\\n  else if(textureIndex == 13.0){\\n    dataValue = texture2D(textureContainer[13], uv);\\n  }\\n  else if(textureIndex == 14.0){\\n    dataValue = texture2D(textureContainer[14], uv);\\n  }\\n  else if(textureIndex == 15.0){\\n    dataValue = texture2D(textureContainer[15], uv);\\n  }\\n  else {\\n    discard;\\n  }\\n\\n  return dataValue;\\n}\\n\\nuniform float uTextureSize;\\nuniform float uWindowLevel[ 2 ];\\nuniform sampler2D uTextureContainer[16];\\nuniform vec3 uDataDimensions;\\nuniform mat4 uWorldToData;\\nuniform int uNumberOfChannels;\\nuniform int uBitsAllocated;\\nuniform int uInvert;\\n\\nvarying vec4 vPos;\\n\\nvoid main(void) {\\n\\n  // get texture coordinates of current pixel\\n  // might not be the right way to do it:\\n  // precision issues ar voxels limits\\n  // need to add machine epsilon?\\n  vec4 dataCoordinateRaw = uWorldToData * vPos;\\n  dataCoordinateRaw += 0.5;\\n  vec3 dataCoordinate = vec3(floor(dataCoordinateRaw.x), floor(dataCoordinateRaw.y), floor(dataCoordinateRaw.z));\\n\\n\\n  // if data in range, look it up in the texture!\\n  if(dataCoordinate.x >= 0.0\\n  && dataCoordinate.y >= 0.0\\n  && dataCoordinate.z >= 0.0\\n  && dataCoordinate.x < uDataDimensions.x\\n  && dataCoordinate.y < uDataDimensions.y\\n  && dataCoordinate.z < uDataDimensions.z\\n  ){\\n    vec3 textureCoordinate = dataCoordinate/uDataDimensions;\\n    vec4 dataValue = sampleAs3DTexture(uTextureContainer, textureCoordinate, uDataDimensions, uTextureSize);\\n    \\n\\n    if(uNumberOfChannels == 1){\\n      // reconstruct 16bits data if any\\n      float rawValue = dataValue.r * 255.0 * 256.0 + dataValue.g * 255.0;\\n      float windowMin = uWindowLevel[0] - uWindowLevel[1]/2.0;\\n      float windowMax = uWindowLevel[0] + uWindowLevel[1]/2.0;\\n      float combined = ( rawValue - windowMin ) / uWindowLevel[1];\\n\\n      dataValue.r = dataValue.g = dataValue.b = combined;\\n    }\\n\\n    if(uInvert == 1){\\n      dataValue = vec4(1, 1, 1, 1) - dataValue;\\n      dataValue.a = 1.0;\\n    }\\n\\n    gl_FragColor = dataValue;\\n  }\\n  else{\\n    // should be able to choose what we want to do if not in range:\\n    // discard or specific color\\n    //discard;\\n    gl_FragColor = vec4(0.011, 0.662, 0.956, 1.0);\\n  }\\n}\"\n    });\n\n    // important so uniforms are not overwritten!\n    // clone it!\n    var mySliceMaterial = sliceMaterial.clone();\n    this._uniforms = mySliceMaterial.uniforms;\n    this._uniforms.uTextureSize.value = stack._textureSize;\n    this._uniforms.uTextureContainer.value = textures;\n    // texture dimensions\n    this._uniforms.uDataDimensions.value = stack._dimensions;\n    // world to model\n    this._uniforms.uWorldToData.value = stack._lps2IJK;\n    // window level\n    this._uniforms.uWindowLevel.value = stack._windowLevel;\n    this._uniforms.uNumberOfChannels.value = stack._numberOfChannels;\n    this._uniforms.uBitsAllocated.value = stack._bitsAllocated;\n    this._uniforms.uInvert.value = stack._invert;\n\n    this._slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);\n    this.add(this._slice);\n\n    // Border of the slice\n    var borderMaterial = new THREE.LineBasicMaterial({\n      color: 0xff0000,\n      polygonOffset: true,\n      polygonOffsetFactor: -0.1\n    });\n    var borderGeometry = new THREE.Geometry();\n    for (var i = 0; i < sliceGeometry.vertices.length; i++) {\n      borderGeometry.vertices.push(sliceGeometry.vertices[i]);\n    }\n    borderGeometry.vertices.push(sliceGeometry.vertices[0]);\n\n    // borderGeometry.vertices = sliceGeometry.vertices;\n    this._border = new THREE.Line(borderGeometry, borderMaterial);\n    this.add(this._border);\n\n  } else {\n    window.console.log('no series to be prepared...');\n  }\n};\n\nVJS.helpers.series.prototype.updateSliceGeometry = function() {\n  var stack = this._series._stack[0];\n  var halfDimensions = stack._halfDimensions;\n  // voxel offset\n  var offset = new THREE.Vector3(-0.5, -0.5, -0.5);\n\n  var center = new THREE.Vector3(0, 0, 0);\n  var orientation = new THREE.Vector3(\n      new THREE.Vector3(1, 0, 0),\n      new THREE.Vector3(0, 1, 0),\n      new THREE.Vector3(0, 0, 1));\n\n  var position = new THREE.Vector3(\n    0,\n    0,\n    this._frameIndex + 0.5 - stack._halfDimensions.z\n    );\n\n  var direction = new THREE.Vector3(0, 0, 1);\n\n  var sliceGeometry = new vjsSliceGeometries(\n      halfDimensions, center, orientation,\n      position, direction);\n  sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(\n      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));\n  sliceGeometry.applyMatrix(stack._ijk2LPS);\n\n  // helper - update Geometry\n  //is memory leaking???\n\n  this._slice.geometry = sliceGeometry;\n  this._slice.geometry.verticesNeedUpdate = true;\n};\n\nVJS.helpers.series.prototype.updateBorderGeometry = function() {\n\n  var borderGeometry = new THREE.Geometry();\n  for (var i = 0; i < this._slice.geometry.vertices.length; i++) {\n    borderGeometry.vertices.push(this._slice.geometry.vertices[i]);\n  }\n  borderGeometry.vertices.push(this._slice.geometry.vertices[0]);\n\n  this._border.geometry.vertices = borderGeometry.vertices;\n  this._border.geometry.verticesNeedUpdate = true;\n};\n\n// export the slice geometry module\nmodule.exports = VJS.helpers.series;\n","'use strict';\n\nvar VJS = VJS || {};\n\nVJS.parsers = VJS.parsers || {};\nVJS.parsers.dicom = VJS.parsers.dicom || require('../parsers/parsers.dicom');\n\nVJS.models = VJS.models || {};\nVJS.models.series = VJS.models.series || require('../models/models.series');\nVJS.models.stack = VJS.models.stack || require('../models/models.stack');\nVJS.models.frame = VJS.models.frame || require('../models/models.frame');\n\nVJS.helpers = VJS.helpers || {};\nVJS.helpers.series = VJS.helpers.series || require('../helpers/helpers.series');\n\n/**\n * loaders namespace\n * @namespace loaders\n * @memberOf VJS\n * @public\n */\n\nVJS.loaders = VJS.loaders || {};\n\n/**\n *\n * It is typically used to load a DICOM image. Use loading manager for\n * advanced usage, such as multiple files handling.\n *\n * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}\n *\n * @constructor\n * @class\n * @memberOf VJS.loaders\n * @public\n *\n * @param {THREE.DefaultLoadingManager=} manager - Manager for advanced users.\n *\n * @example\n * var files = ['/data/dcm/fruit'];\n *\n * // Instantiate a dicom loader\n * var dicomLoader = new VJS.loaders.dicom();\n *\n * // load a resource\n * loader.load(\n *   // resource URL\n *   files[0],\n *   // Function when resource is loaded\n *   function(object) {\n *     //scene.add( object );\n *     window.console.log(object);\n *   }\n * );\n */\nVJS.loaders.dicom = function(manager) {\n\n  this.manager =\n      (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n  this.crossOrigin = true;\n  this.responseType = 'arraybuffer';\n  this._imageHelper = null;\n  this._image = null;\n\n};\nVJS.loaders.dicom.prototype.constructor = VJS.loaders.dicom;\n\n/**\n *\n * Load target file and attach necessary callbacks.\n *\n * @todo Might want to implement onError extra layer like for \"onLoad\".\n * @public\n *\n * @param {string} url - Url of the file to be pulled.\n * @param {function} onLoad - On load callback, after response has been parsed by VJS.loaders.dicom.parse.\n * @param {function} onProgress - On progress callback.\n * @param {function} onError - On error callback.\n *\n * @returns {Array<Promise>} Loading sequence for each file.\n *\n */\nVJS.loaders.dicom.prototype.load = function(file, onLoad, onProgress, onError) {\n  // no more promises...!\n  //\n\n  var scope = this;\n\n  // scope._imageHelper = new Array(files.length);\n  // scope._image = new Array(files.length);\n\n  var loader = new THREE.XHRLoader(scope.manager);\n  loader.setCrossOrigin(this.crossOrigin);\n  loader.setResponseType(this.responseType);\n  loader.load(file, function(response) {\n\n    onLoad(scope.parse(response));\n\n  }, onProgress, onError);\n\n  // Build the promise sequence for each file\n  // return files.map(function(url, i) {\n\n  //   var loader = new VJS.loader.xhrpromise(scope.manager);\n  //   loader.setCrossOrigin(scope.crossOrigin);\n  //   loader.setResponseType(scope.responseType);\n\n  //   // 1- get the data\n  //   // return an array buffer\n  //   return loader.load(url, onProgress)\n  //     .catch(function(error) {\n  //       window.console.log(error);\n  //       if (onError) {\n  //         onError(error);\n  //       }\n  //     })\n  //   // 2- parse the array buffer\n  //   // return an image model\n  //     .then(function(response) {\n  //       var imageHelper = new VJS.helpers.image();\n  //       scope._imageHelper[i] = imageHelper;\n  //       var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n  //       return dicomParser.parse();\n  //     })\n  //   // 3- create helper with image\n  //   // return the image helper\n  //     .then(function(image) {\n  //       scope._imageHelper[i].addImage(image);\n  //       scope._image[i] = image;\n\n  //       // a helper is an object we can directly add to the scene and visualize\n  //       window.console.log('ALL SET');\n\n  //       return scope._imageHelper[i];\n  //     })\n  //   // 4- run onLoad callback\n  //   // input is imageHelper\n  //   // (should it be the image?)\n  //     .then(function(imageHelper) {\n  //       if (onLoad) {\n  //         window.console.log('onLoad callback (i.e. add to scene or play with helper)');\n  //         onLoad(imageHelper);\n  //       }\n\n  //       return imageHelper;\n  //     });\n  // });\n};\n\n/**\n *\n * Parse the response and returned a well formatted VJS Image Helper;\n *\n * @public\n *\n * @param {arraybuffer} response - Data to be parsed.\n *\n * @returns {VJS.Helper.Image}\n *\n */\nVJS.loaders.dicom.prototype.parse = function(response) {\n  window.console.log(response);\n  window.console.log('file downloaded yay!');\n\n  // series helper with lot of goodies\n  var seriesHelper = new VJS.helpers.series();\n\n  // parse DICOM\n  var dicomParser = new VJS.parsers.dicom(response, seriesHelper.id);\n    \n  // create a series\n  var series = new VJS.models.series();\n  series._seriesInstanceUID = dicomParser.seriesInstanceUID();\n  series._numberOfFrames = dicomParser.numberOfFrames();\n  if(!series._numberOfFrames){\n    series._numberOfFrames = 1;\n  }\n  series._numberOfChannels = dicomParser.numberOfChannels();\n\n  // just create 1 dummy stack for now\n  var stack = new VJS.models.stack();\n  stack._numberOfChannels = dicomParser.numberOfChannels();\n\n  series._stack.push(stack);\n\n  // loop through all the frames!\n  for (var i = 0; i < series._numberOfFrames; i++) {\n    // shoud check for target stack\n    // should check if frame was already added in stack\n    // etc.\n    var frame = new VJS.models.frame();\n    frame._rows = dicomParser.rows(i);\n    frame._columns = dicomParser.columns(i);\n    frame._pixelData = dicomParser.extractPixelData(i);\n    frame._pixelSpacing = dicomParser.pixelSpacing(i);\n    frame._sliceThickness = dicomParser.sliceThickness(i);\n    frame._imageOrientation = dicomParser.imageOrientation(i);\n    frame._imagePosition = dicomParser.imagePosition(i);\n    frame._dimensionIndexValues = dicomParser.dimensionIndexValues(i);\n    frame._bitsAllocated = dicomParser.bitsAllocated(i);\n    frame._instanceNumber = dicomParser.instanceNumber(i);\n    // should pass frame index for consistency...\n    frame._minMax = dicomParser.minMaxPixelData(frame._pixelData);\n\n    stack._frame.push(frame);\n  }\n\n  // var image = dicomParser.parse();\n\n  // add image to image helper\n  // image helper is a 3D object image wherease image is a general JS Object\n  seriesHelper.addSeries(series);\n  return seriesHelper;\n  //var self = this;\n\n  //return new Promise(function(resolve) {\n\n  // console.time('LoaderDicom');\n  // // use response as input to image helper.\n  // // can provide an image or not...\n  // var imageHelper = new VJS.helpers.image();\n  // var dicomParser = new VJS.parsers.dicom(response, imageHelper.id);\n\n  // //var image = dicomParser.parse();\n  // var sequence = Promise.resolve();\n  // sequence\n  //   .then(function() {\n  //     return dicomParser.parse();\n  //   })\n  //   .then(function(image) {\n  //     imageHelper.add(image);\n  //     console.timeEnd('LoaderDicom');\n  //     return (imageHelper);\n  //   });\n\n  // return sequence;\n\n  //imageHelper.add(dicomParser.parse());\n\n  //\n  //  Create A dicom parser to help us fill the Image Helper!\n  //\n\n  // var dicomParser = new VJS.parsers.dicom(name, jQueryDom);\n\n  // var object, objects = [];\n  // var geometry, material;\n\n  // for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n  //   object = objects[ i ];\n  //   geometry = object.geometry;\n\n  //   var buffergeometry = new THREE.BufferGeometry();\n\n  //   buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n  //   if ( geometry.normals.length > 0 ) {\n  //     buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n  //   }\n\n  //   if ( geometry.uvs.length > 0 ) {\n  //     buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n  //   }\n\n  //   material = new THREE.MeshLambertMaterial();\n  //   material.name = object.material.name;\n\n  //   var mesh = new THREE.Mesh( buffergeometry, material );\n  //   mesh.name = object.name;\n\n  //   container.add( mesh );\n\n  // }\n\n  //resolve(imageHelper);\n  //});\n\n// VJS.parsers.dicom.prototype.parsePromise = function() {\n//   var self = this;\n//   console.time('Parsing Dicom');\n//   var imageNameFS = 'image_' + self._id;\n//   var frameNameFS = imageNameFS + '-raw.8b';\n//   //\n//   // Promises in action!\n//   //\n//   var sequence = Promise.resolve();\n//   return sequence\n//         .then(function() {\n//           // same image to Virtual FS\n//           return self.fileToFS(imageNameFS, self._arrayBuffer);\n//         })\n//         .then(function() {\n//           // extract frames from image and save it on Vistual FS\n//           return self.framesToFS(imageNameFS, frameNameFS);\n//         })\n//         .then(function() {\n//           // extract dicom header from image and convert it to XML\n//           return self.dumpToXML(imageNameFS);\n//         })\n//         .then(function(xml) {\n//           // parse XML Header and build VJS objects\n//           var $dicomDom = $.parseXML(xml);\n//           //window.console.log($dicomDom);\n//           var image = self.domToImage($dicomDom, frameNameFS);\n//           //resolve(self.domToImage($dicomDom, frameNameFS));\n\n//           // Dom to image it!\n//           return image;\n//         });\n// };\n\n\n};\n\n// export the probePixel widget module\nmodule.exports = VJS.loaders.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Base frame object.\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n */\nVJS.models.frame = function() {\n    /**\n     * @member\n     * @type {string}\n     */\n    this._id = '-1';\n    /**\n     * @member\n     * @type {number}\n     */\n    this._stackID = -1;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._rows = 0;\n    /**\n     * @member\n     * @type {number}\n     */\n    this._columns = 0;\n    /**\n     * @member\n     * @type {Array.number}\n     */\n    this._dimensionIndexValues = [];\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} x\n     * @property {number} y\n     * @property {number} z\n     */\n    this._imagePositionPatient = {\n        'x': 0,\n        'y': 0,\n        'z': 0\n    };\n    /**\n     * @member\n     * @type {Object}\n     * @property {Object} row\n     * @property {number} row.x\n     * @property {number} row.y\n     * @property {number} row.z\n     * @property {Object} column\n     * @property {number} column.x\n     * @property {number} column.y\n     * @property {number} column.z\n     */\n    this._imageOrientationPatient = {\n        'row': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        },\n        'column': {\n            'x': 0,\n            'y': 0,\n            'z': 0\n        }\n    };\n    /**\n     * @member\n     * @type {number}\n     */\n    this._sliceThickness = 1;\n    /**\n     * @member\n     * @type {Object}\n     * @property {number} row\n     * @property {number} column\n     */\n    this._pixelSpacing = {\n        'row': 1,\n        'column': 1\n    };\n    this._spacingBetweenSlices = null;\n    /**\n     * @member\n     * @type {Array}\n     */\n    this._pixelData = null;\n\n    this._instanceNumber = null;\n\n    this._minMax = null;\n};\n\nVJS.models.frame.prototype.constructor = VJS.models.frame;\n\n// export the frame module\nmodule.exports = VJS.models.frame;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the series object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.series = function() {\n    this._id = -1; // Always good to have an ID\n    this._concatenationUID = -1;\n    this._seriesInstanceUID = -1;\n    this._seriesNumber = -1;\n    this._dimensionIndexSequence = [];\n\n    // should probably not be there\n    this._rows = 0;\n    this._columns = 0;\n    this._photometricInterpretation = '';\n\n    this._numberOfFrames = 0;\n    this._numberOfChannels = 1;\n    this._instanceNumber = 0;\n\n    this._stack = [];\n};\n\n// it is a helper!\nVJS.models.series.prototype.merge = function(series) {\n    // try to merge seriesHelper with current series.\n    // same series if same Series UID?\n    // could use concatenation if available, to already know if series is complete!\n    var sameSeriesUID = false;\n    if (this._seriesInstanceUID === series._seriesInstanceUID) {\n        window.console.log('stacks belong to same series!');\n        sameSeriesUID = true;\n\n        // Make sure series information is consisent?\n        // re-compute it?\n        var stack = series._stack;\n        // Merge Stacks (N against N)\n        // try to match all stack to current stacks, if not add it to stacks list!\n        for (var i = 0; i < stack.length; i++) {\n            // test stack against existing stack\n            for (var j = 0; j < this._stack.length; j++) {\n                window.console.log(this._stack[j], stack[i]);\n                if (this._stack[j].merge(stack[i])) {\n                    // merged successfully\n                    window.console.log('stacks merged successfully!');\n                    break;\n                } else if (j === this._stack.length - 1) {\n                    // last merge was not successful\n                    // this is a new stack\n                    window.console.log('stacks added to the list!');\n                    this._stack.push(stack[i]);\n                }\n            }\n\n        }\n    }\n\n    return sameSeriesUID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.series;","'use strict';\n\nvar VJS = VJS || {};\nVJS.models = VJS.models || {};\n\n/**\n * Define the stack object here\n *\n * @constructor\n * @class\n * @memberOf VJS.models\n * @public\n */\nVJS.models.stack = function() {\n  /**\n   * @member\n   * @type {string}\n   */\n  this._id = '-1';\n  /**\n   * @member\n   * @type {string}\n   */\n  this._uid = null; // first stack ID -> (0020, 9056)\n  /**\n   * @member\n   * @type {number}\n   */\n  this._stackID = -1;\n  /**\n   * @member\n   * @type {Array.<VJS.frame.model>}\n   */\n  this._frame = [];\n  /**\n   * @member\n   * @type {number}\n   */\n  this._rows = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._columns = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._numberOfFrames = 0;\n  /**\n   * @member\n   * @type {Object}\n   * @property {number} row\n   * @property {number} column\n   */\n  this._pixelSpacing = {\n    'row': 0,\n    'column': 0\n  };\n  this._spacingBetweenSlices = 0;\n  /**\n   * @member\n   * @type {number}\n   */\n  this._sliceThickness = 0;\n\n  // origin of the first slice of the stack!\n  this._origin = null;\n  this._halfDimensions = null;\n  this._orientation = null;\n\n  this._textureSize = 2048;\n  this._nbTextures = 16; // HIGH RES..\n  this._rawData = [];\n  // this._windowCenter = 0;\n  // this._windowWidth = 0;\n  this._windowLevel = [0, 0];\n  this._windowCenter = 0;\n  this._windowWidth = 0;\n  this._minMax = [65535, -32768];\n  this._invert = 0;\n\n  this._ijk2LPS = null;\n  this._lps2IJK = null;\n\n  // Slicer values\n  this._dimensions = null;\n  this._spacing = null;\n  this._origin = null;\n  this._direction = null;\n};\n\n/**\n * here me make sure eveything is ready for visualization.\n * might also have a switch to say what we can view and what we can not view with current stack\n *\n * @public\n */\nVJS.models.stack.prototype.prepare = function() {\n\n  // dimensions of the stack\n  this._numberOfFrames = this._frame.length;\n\n  window.console.log(this);\n  this.orderFrames();\n  var zSpacing = this.zSpacing();\n\n    // prepare the frame\n  if (this._frame[0]._pixelSpacing) {\n    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];\n    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];\n  } else if (this._frame[0]._pixelAspectRatio) {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];\n  } else {\n    this._pixelSpacing.row = 1.0;\n    this._pixelSpacing.column = 1.0;\n  }\n\n  if (!this._frame[0]._imagePosition) {\n    this._frame[0]._imagePosition = [0, 0, 0];\n  }\n\n  if (!this._frame[0]._imageOrientation) {\n    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];\n  }\n\n\n  this._rows = this._frame[0]._rows;\n  this._columns = this._frame[0]._columns;\n  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);\n\n  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;\n  this._sliceThickness = this._frame[0]._sliceThickness;\n\n  for (var i = 0; i < this._frame.length; i++) {\n\n    // check rows consistency\n    if (this._rows !== this._frame[i]._rows) {\n      // send an error message...\n      window.console.log('Numbers of rows in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._rows, ' rows');\n      window.console.log('Frame index: ', i, ' has: ', this._frame[i]._rows, ' rows.');\n    }\n\n    // check columns consitency\n    if (this._columns !== this._frame[i]._columns) {\n      // send an error message...\n      window.console.log('Numbers of columns in stack\\'s frames is not consistent.');\n      window.console.log(this);\n      window.console.log('First frame had: ', this._columns, ' columns.');\n      window.console.log('Frame index: ', i, ' has: ', this.frame[i]._columns, ' columns.');\n    }\n\n    // // check for spacing consistency\n    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {\n    //   // send an error message...\n    //   window.console.log('Spacing in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had : ', this._pixelSpacing.row, ' x ', this._pixelSpacing.column, ' spacing.');\n    //   window.console.log('Frame index : ', i, ' has: ', this._frame[i]._pixelSpacing[0], ' x ', this._frame[i]._pixelSpacing[1], ' spacing.');\n    // }\n\n    // // check slice spacing consitency\n    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {\n    //   // send an error message...\n    //   window.console.log('Spacing betwen slices in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._spacingBetweenSlices, ' spacing betwen slices.');\n    //   window.console.log('Frame index: ', i, ' has: ', this.frame[i]._spacingBetweenSlices, ' spacing betwen slices.');\n    // }\n\n    // // check for slice thickness consistency\n    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {\n    //   window.console.log('Slice thickness in stack\\'s frames is not consistent.');\n    //   window.console.log(this);\n    //   window.console.log('First frame had: ', this._sliceThickness, ' sliceThickness.');\n    //   window.console.log('Frame index: ', i, ' has: ', this._frame[i]._sliceThickness, ' sliceThickness.');\n    // }\n\n    // get min/max\n    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);\n    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);\n  }\n\n  // Origin\n  this._origin = new THREE.Vector3(\n      this._frame[0]._imagePosition[0],\n      this._frame[0]._imagePosition[1],\n      this._frame[0]._imagePosition[2]\n      );\n\n  // Direction\n  window.console.log('first frame value!');\n  window.console.log(this._frame[0]._imageOrientation[0]);\n  var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n  );\n  window.console.log(xCosine);\n\n  var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n  );\n  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n  this._direction = new THREE.Matrix4();\n  this._direction.set(\n      xCosine.x, yCosine.x, zCosine.x, 0,\n      xCosine.y, yCosine.y, zCosine.y, 0,\n      xCosine.z, yCosine.z, zCosine.z, 0,\n      0, 0, 0, 1);\n\n  window.console.log(this._direction);\n\n  this._spacing = new THREE.Vector3(\n      this._pixelSpacing.row,\n      this._pixelSpacing.column,\n      zSpacing);\n\n  window.console.log(this._spacing);\n\n  // half dimensions are useful for faster computations of intersection.\n  this._halfDimensions = new THREE.Vector3(\n      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);\n\n  // orientation needed to compute stack BBox interection against slice.\n  // always same, might want to remove it.\n  var baseX = new THREE.Vector3(1, 0, 0);\n  var baseY = new THREE.Vector3(0, 1, 0);\n  var baseZ = new THREE.Vector3(0, 0, 1);\n  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);\n\n  // IJK to LPS transform.\n  // and inverse.\n  this._ijk2LPS = new THREE.Matrix4();\n  this._ijk2LPS.set(\n      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,\n      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,\n      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,\n      0, 0, 0, 1);\n\n  this._lps2IJK = new THREE.Matrix4();\n  this._lps2IJK.getInverse(this._ijk2LPS);\n\n  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);\n\n  // only works with 1 channel for now...\n  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;\n  window.console.log(this._dimensions);\n\n  // create 16 rgb textures\n  for (var ii = 0; ii < this._nbTextures; ii++) {\n    // *3 because always create RGB\n    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 3));\n  }\n\n  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl\n\n  // Can not just use subarray because we have to normalize the values (Uint* 0<x<255)\n  //var prevFrame = -1;\n  //var prevTexture = -1;\n\n  var frameDimension = this._dimensions.x * this._dimensions.y;\n  var textureDimension = this._textureSize * this._textureSize;\n\n  console.time('arrangeDataForWebgl');\n\n  for (var jj = 0; jj < nbVoxels; jj++) {\n\n    var frameIndex = Math.floor(jj / frameDimension);\n    var inFrameIndex = jj % (frameDimension);\n\n    var textureIndex = Math.floor(jj / textureDimension);\n    var inTextureIndex = jj % (textureDimension);\n    if (this._numberOfChannels === 3) {\n\n      this._rawData[textureIndex][3 * inTextureIndex] = this._frame[frameIndex]._pixelData[3 * inFrameIndex];\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 1];\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[3 * inFrameIndex + 2];\n\n    } else {\n      //\n\n      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];\n\n      // get most significant (msb) and less significant (lsb) bytes\n      // deal with sign?\n      // deal with number of channels\n      // deal with image type (single/multi channel)\n      // >> or >>> ?\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift\n      var lsb = rawValue & 0xFF;\n      var msb = (rawValue >> 8) & 0xFF;\n\n      this._rawData[textureIndex][3 * inTextureIndex] = msb;\n      this._rawData[textureIndex][3 * inTextureIndex + 1] = lsb;\n      this._rawData[textureIndex][3 * inTextureIndex + 2] = frameIndex;\n\n    }\n\n  }\n\n  // default window level based on min/max for now...\n  var width = this._minMax[1] - this._minMax[0];\n  var center = this._minMax[0] + width / 2;\n\n  this._windowWidth = width;\n  this._windowCenter = center;\n  this._windowLevel = [center, width];\n\n  // need to pass min/max\n  this._bitsAllocated = this._frame[0]._bitsAllocated;\n\n  window.console.log('window level: ', this._windowLevel);\n};\n\n/**\n * Order frames based on theirs dimensionIndexValues\n */\nVJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {\n\n  if ('_dimensionIndexValues' in a && Object.prototype.toString.call(a._dimensionIndexValues) === '[object Array]' && '_dimensionIndexValues' in b && Object.prototype.toString.call(b._dimensionIndexValues) === '[object Array]') {\n    for (var i = 0; i < a._dimensionIndexValues.length; i++) {\n      if (parseInt(a._dimensionIndexValues[i]) > parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' > ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' > ' + typeof b._dimensionIndexValues[i]);\n        return 1;\n      }\n      if (parseInt(a._dimensionIndexValues[i]) < parseInt(b._dimensionIndexValues[i])) {\n        //window.console.log(a._dimensionIndexValues[i] + ' < ' + b._dimensionIndexValues[i]);\n        //window.console.log(typeof a._dimensionIndexValues[i] + ' < ' + typeof b._dimensionIndexValues[i]);\n        return -1;\n      }\n    }\n  } else {\n    window.console.log('One of the frames doesn\\'t have a _dimensionIndexValues array.');\n    window.console.log(a);\n    window.console.log(b);\n  }\n\n  return 0;\n};\n\nVJS.models.stack.prototype.orderFrames = function() {\n  // order the frames based on theirs dimension indices\n  // first index is the most important.\n  // 1,1,1,1 willl be first\n  // 1,1,2,1 will be next\n  // 1,1,2,3 will be next\n  // 1,1,3,1 wil be next\n  window.console.log(this);\n  if (this._frame[0]._dimensionIndexValues) {\n    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);\n  } else if (this._frame[0]._imagePosition && this._frame[0]._imageOrientation) {\n    // ORDERING BASED ON IMAGE POSITION\n    var xCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[0],\n      this._frame[0]._imageOrientation[1],\n      this._frame[0]._imageOrientation[2]\n      );\n\n    var yCosine = new THREE.Vector3(\n      this._frame[0]._imageOrientation[3],\n      this._frame[0]._imageOrientation[4],\n      this._frame[0]._imageOrientation[5]\n    );\n\n    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n    function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n    // // compute dist in this series\n    this._frame.map(computeDistance.bind(null, zCosine));\n    window.console.log(this._frame);\n    // // order by dist\n    this._frame.sort(function(a, b) {return a._dist - b._dist});\n    window.console.log(this._frame);\n\n  } else {\n    // else slice location\n    // image number\n    // ORDERING BASED ON instance number\n    // _ordering = 'instance_number';\n    // first_image.sort(function(a,b){return a[\"instance_number\"]-b[\"instance_number\"]});\n  }\n};\n\nVJS.models.stack.prototype.zSpacing = function() {\n  // Spacing\n  // can not be 0 if not matrix can not be inverted.\n  var zSpacing = 1;\n  window.console.log(this._frame[0]);\n\n  if (this._numberOfFrames > 1) {\n    if (this._spacingBetweenSlices) {\n      zSpacing = this._spacingBetweenSlices;\n    } else if (this._frame[0]._sliceThickness) {\n      zSpacing = this._frame[0]._sliceThickness;\n    } else {\n      var xCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[0],\n        this._frame[0]._imageOrientation[1],\n        this._frame[0]._imageOrientation[2]\n      );\n\n      var yCosine = new THREE.Vector3(\n        this._frame[0]._imageOrientation[3],\n        this._frame[0]._imageOrientation[4],\n        this._frame[0]._imageOrientation[5]\n      );\n\n      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();\n\n      function computeDistance(normal, frame) {\n      frame._dist = frame._imagePosition[0] * normal.x +\n        frame._imagePosition[1] * normal.y +\n        frame._imagePosition[2] * normal.z;\n      return frame;\n    }\n\n      // // compute dist in this series\n      this._frame.map(computeDistance.bind(null, zCosine));\n      window.console.log(this._frame);\n      // // order by dist\n      this._frame.sort(function(a, b) {return a._dist - b._dist});\n\n      zSpacing = this._frame[1]._dist - this._frame[0]._dist;\n    }\n  }\n\n  if (zSpacing === 0) {\n    zSpacing = 1;\n  }\n\n  return zSpacing;\n};\n\nVJS.models.stack.prototype.merge = function(stack) {\n  // try to merge imageHelper with current image.\n  // same image if same Series UID?\n  // could use concatenation if available, to already know if image is complete!\n  var sameStackID = false;\n  if (this._stackID === stack._stackID) {\n    sameStackID = true;\n\n    // Make sure image information is consisent?\n    // re-compute it?\n    var frame = stack._frame;\n    // Merge Stacks (N against N)\n    // try to match all stack to current stacks, if not add it to stacks list!\n    for (var i = 0; i < frame.length; i++) {\n      // test stack against existing stack\n      for (var j = 0; j < this._frame.length; j++) {\n        // test dimension\n        // dimension index value not defined!\n        if (\n          \n          // dimension index is unique\n          (this._frame[j]._dimensionIndexValues &&\n            frame[i]._dimensionIndexValues &&\n            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||\n          \n          // instance number is unique?\n          (this._frame[j]._instanceNumber &&\n            frame[i]._instanceNumber &&\n            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||\n          \n          // imagePosition + imageOrientation is unique\n          (this._frame[j]._imagePosition &&\n            frame[i]._imagePosition &&\n            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &&\n            this._frame[j]._imageOrientation &&\n            frame[i]._imageOrientation &&\n            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join()) //||\n\n          // _pixelData length is unique...? imageSOP?\n          // (this._frame[j]._pixelData &&\n          //   frame[i]._pixelData &&\n          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)\n\n          ) {\n\n          window.console.log('BREAKING!');\n          window.console.log(frame[i], this._frame[j]);\n          break;\n         \n        } else if (j === this._frame.length - 1) {\n\n          window.console.log('PUSHING FRAME TO STACK!');\n          this._frame.push(frame[i]);\n          break;\n\n        }\n\n      }\n\n    }\n  }\n\n  window.console.log(this);\n\n  return sameStackID;\n};\n\n// export the frame module\nmodule.exports = VJS.models.stack;\n\n// The Image Position (0020,0032) specifies the x, y, and z coordinates\n// of the upper left hand corner of the image; it is the center of the\n// first voxel transmitted. Image Orientation (0020,0037) specifies the\n// direction cosines of the first row and the first column with respect\n// to the patient. These Attributes shall be provide as a pair. Row value\n// for the x, y, and z axes respectively followed by the Column value for\n// the x, y, and z axes respectively.\n\n// The direction of the axes is defined fully by the patient's\n// orientation. The x-axis is increasing to the left hand side of the\n// patient. The y-axis is increasing to the posterior side of the\n// patient. The z-axis is increasing toward the head of the patient.\n\n// The patient based coordinate system is a right handed system, i.e. the\n// vector cross product of a unit vector along the positive x-axis and a\n// unit vector along the positive y-axis is equal to a unit vector along\n// the positive z-axis.\n// \"\n\n// (**)\n// http://www.itk.org/mailman/private/i...ry/007553.html\n// You need to be suscribed to the ML to have access to this post (sorry).\n\n// Reply With Quote Reply With Quote\n// 10-02-2007 10:05 AM #2\n// Re: Image Position (Patient) and Image Orientation (Patient)\n// Since it might be usefull for other people, I am copy/pasting the\n// answer from David Clunie here:\n\n// -------- Original Message --------\n// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate\n// system\n// Date: Wed, 18 Jan 2006 12:57:42 -0500\n// From: David Clunie <>\n// Reply-To:\n// To:\n\n// Hi all\n\n// Just to clarify a few things with respect to DICOM and what\n// vendors do, without knowing enough about ITK or gdcm to\n// answer the context of the concern. Please excuse me if I\n// restate the obvious.\n\n// As has been pointed out in previous posts there is absolutely\n// no ambiguity about the DICOM attributes in this respect, nor\n// whether the vendors interpret them differently (they do not).\n\n// Specifically:\n\n// - all DICOM references are relative to a specific \"frame of\n// reference\" identified by a UID - all images that share that\n// FoR share the same, completely arbitrary, origin; the origin\n// might be the isocenter of the magnet, which is constant, but\n// the patient position relative to it is not; this is the\n// context in which all other DICOM attributes related to the\n// \"patient coordinate system\" should be interpreted; the\n// corollary is that different FoRs means coordinates and vectors\n// are not comparable\n\n// - the center of the top left hand voxel of a slice is defined\n// relative to the FoR-specific origin by an x,y,z tuple that\n// represents a translation of that location in mm from the offset;\n// the x,y and z directions are patient (not gantry) relative,\n// and their order is consistent and defined (see the standard)\n\n// - the direction of the rows and columns are defined relative\n// to the patient by unit vectors (direction cosines), again\n// the details are in the standard.\n\n// - the Image Position (Patient) TLHC location (which defines\n// the offset from the FoR origin) is completely independent of\n// the Image Orientation (Patient) unit vectors, which define\n// the plane of the slice (only)\n\n// Again, the x,y,z translation from the origin of the TLHC is\n// in the nominal patient relative FoR, NOT the plane specified\n// by the unit vectors that define the orientation of the slice.\n\n// Note that the use of \"patient relative\" is relatively imprecise,\n// in the sense that if the operator does not line the patient's\n// head foot axis exactly down the center line of the gantry or\n// table, then though the direction of the Z axis will nominally\n// be along the head-foot axis, but reproducible only within the\n// same nominal FoR, and even then, only as long as the patient\n// doesn't move without the operator re-landmarking.\n\n// All the vendors interpret this the same way, with the one notable\n// exception being arguments over whether the TLHC is the center\n// of the voxel or one edge of it (the standard has been clarified\n// to specify the center, whereas previously it was unspecified,\n// hence older implementations vary in this respect).\n","/*global module*/\n\n\n//ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/\n\n'use strict';\n\n// imports\nvar dicomParser = require('dicom-parser');\n// var jpx = require('./jpx.js');\n\nvar VJS = VJS || {};\n\n// WE RETURN NULL INSTEAD OF GUESSING\n\n/**\n * parsers namespace\n * @namespace parsers\n * @memberOf VJS\n */\nVJS.parsers = VJS.parsers || {};\n\n/**\n * Dicom parser is a combination of utilities to get a VJS image from dicom files.\n *\n * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.\n *\n * @constructor\n * @class\n * @memberOf VJS.parsers\n * @public\n *\n * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which\n * VJS.parsers.dicom can pull the data from.\n */\nVJS.parsers.dicom = function(arrayBuffer, id) {\n  /**\n   * @member\n   * @type {arraybuffer}\n   */\n  this._id = id;\n  this._arrayBuffer = arrayBuffer;\n\n  var byteArray = new Uint8Array(arrayBuffer);\n  // window.console.log(byteArray.length);\n  this._dataSet = dicomParser.parseDicom(byteArray);\n\n  //window.console.log(dicomParser);\n  // window.console.log(this._dataSet);\n  // this.rescaleIntercept(0);\n};\n\nVJS.parsers.dicom.prototype.seriesInstanceUID =  function() {\n  return this._dataSet.string('x0020000e');\n};\n\nVJS.parsers.dicom.prototype.modality =  function() {\n  return this._dataSet.string('x00080060');\n};\n\n// image/frame specific\nVJS.parsers.dicom.prototype.sopInstanceUID =  function() {\n  return this._dataSet.string('x00200018');\n};\n\nVJS.parsers.dicom.prototype.transferSyntaxUID =  function() {\n  return this._dataSet.string('x00020010');\n};\n\nVJS.parsers.dicom.prototype.photometricInterpretation =  function() {\n  return this._dataSet.string('x00280004');\n};\n\nVJS.parsers.dicom.prototype.planarConfiguration =  function() {\n\n  var planarConfiguration = this._dataSet.uint16('x00280006');\n\n  if (typeof planarConfiguration === 'undefined') {\n    planarConfiguration = null;\n  }\n\n  return planarConfiguration;\n};\n\nVJS.parsers.dicom.prototype.samplesPerPixel =  function() {\n  return this._dataSet.uint16('x00280002');\n};\n\nVJS.parsers.dicom.prototype.numberOfFrames =  function() {\n  var numberOfFrames = this._dataSet.intString('x00280008');\n\n  // need something smarter!\n  if (typeof numberOfFrames === 'undefined') {\n    numberOfFrames = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfFrames;\n};\n\nVJS.parsers.dicom.prototype.numberOfChannels =  function() {\n  var numberOfChannels = 1;\n  var photometricInterpretation = this.photometricInterpretation();\n\n  if (photometricInterpretation === 'RGB' ||\n            photometricInterpretation === 'PALETTE COLOR' ||\n            photometricInterpretation === 'YBR_FULL' ||\n            photometricInterpretation === 'YBR_FULL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_422' ||\n            photometricInterpretation === 'YBR_PARTIAL_420' ||\n            photometricInterpretation === 'YBR_RCT') {\n    numberOfChannels = 3;\n  }\n\n  // make sure we return a number! (not a string!)\n  return numberOfChannels;\n};\n\nVJS.parsers.dicom.prototype.imageOrientation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var imageOrientation = this._dataSet.string('x00200037');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof imageOrientation === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00209116.items[0].dataSet;\n      imageOrientation = planeOrientationSequence.string('x00200037');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      imageOrientation = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imageOrientation) {\n    // make sure we return a number! (not a string!)\n    // might not need to split (floatString + index)\n    imageOrientation = imageOrientation.split('\\\\').map(Number);\n  }\n\n  return imageOrientation;\n};\n\nVJS.parsers.dicom.prototype.pixelAspectRatio =  function() {\n  var pixelAspectRatio = [\n    this._dataSet.intString('x00280034', 0),\n    this._dataSet.intString('x00280034', 1)\n    ];\n\n  // need something smarter!\n  if (typeof pixelAspectRatio[0] === 'undefined') {\n    pixelAspectRatio = null;\n  }\n\n  // make sure we return a number! (not a string!)\n  return pixelAspectRatio;\n};\n\nVJS.parsers.dicom.prototype.imagePosition =  function(frameIndex) {\n  var imagePosition = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    var planeOrientationSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209113.items[0].dataSet;\n    imagePosition = planeOrientationSequence.string('x00200032');\n  } else {\n    // should we default to undefined??\n    // default orientation\n    imagePosition = this._dataSet.string('x00200032');\n\n    if (typeof imagePosition === 'undefined') {\n      imagePosition = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  if (imagePosition) {\n    // make sure we return a number! (not a string!)\n    imagePosition = imagePosition.split('\\\\').map(Number);\n  }\n\n  return imagePosition;\n};\n\nVJS.parsers.dicom.prototype.instanceNumber =  function(frameIndex) {\n  var instanceNumber = null;\n  // first look for frame!\n  // per frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // plane orientation sequence for Nth element in the sequence\n    // PHILIPS HACK...\n    if (perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x2005140f) {\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;\n      instanceNumber = planeOrientationSequence.intString('x00200013');\n    } else {\n      instanceNumber = this._dataSet.intString('x00200013');\n\n      if (typeof instanceNumber === 'undefined') {\n        instanceNumber = null;\n      }\n    }\n\n  } else {\n    // should we default to undefined??\n    // default orientation\n    instanceNumber = this._dataSet.intString('x00200013');\n\n    if (typeof instanceNumber === 'undefined') {\n      instanceNumber = null;\n    }\n  }\n\n  return instanceNumber;\n};\n\nVJS.parsers.dicom.prototype.pixelSpacing =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelSpacing = this._dataSet.string('x00280030');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof pixelSpacing === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      pixelSpacing = planeOrientationSequence.string('x00280030');\n    } else {\n      // default orientation\n      pixelSpacing = null;\n    }\n  }\n\n  // format image orientation ('1\\0\\0\\0\\1\\0') to array containing 6 numbers\n  // should we default to undefined??\n  if (pixelSpacing) {\n\n    // make sure we return array of numbers! (not strings!)\n    pixelSpacing = pixelSpacing.split('\\\\').map(Number);\n  }\n  return pixelSpacing;\n};\n\nVJS.parsers.dicom.prototype.sopInstanceUID =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sopInstanceUID = this._dataSet.string('x00080018');\n  return sopInstanceUID;\n};\n\nVJS.parsers.dicom.prototype.sliceThickness =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var sliceThickness = this._dataSet.floatString('x00180050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof sliceThickness === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // plane orientation sequence for Nth element in the sequence\n      var planeOrientationSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289110.items[0].dataSet;\n      sliceThickness = planeOrientationSequence.floatString('x00180050');\n    } else {\n      // default orientation\n      // should we default to undefined??\n      // print warning at least...\n      sliceThickness = null;\n    }\n  }\n\n  return sliceThickness;\n};\n\nVJS.parsers.dicom.prototype.rows =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rows = this._dataSet.uint16('x00280010');\n\n  if (typeof rows === 'undefined') {\n    rows = null;\n    // print warning at least...\n  }\n\n  return rows;\n};\n\nVJS.parsers.dicom.prototype.columns =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var columns = this._dataSet.uint16('x00280011');\n\n  if (typeof columns === 'undefined') {\n    columns = null;\n    // print warning at least...\n  }\n\n  return columns;\n};\n\nVJS.parsers.dicom.prototype.pixelRepresentation =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var pixelRepresentation = this._dataSet.uint16('x00280103');\n  return pixelRepresentation;\n};\n\nVJS.parsers.dicom.prototype.bitsAllocated =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var bitsAllocated = this._dataSet.uint16('x00280100');\n  return bitsAllocated;\n};\n\nVJS.parsers.dicom.prototype.highBit =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var highBit = this._dataSet.uint16('x00280102');\n  return highBit;\n};\n\nVJS.parsers.dicom.prototype.rescaleIntercept =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleIntercept = this._dataSet.floatString('x00281052');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleIntercept === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleIntercept = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleIntercept\n      rescaleIntercept = null;\n    }\n  }\n\n  return rescaleIntercept;\n};\n\nVJS.parsers.dicom.prototype.rescaleSlope =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var rescaleSlope = this._dataSet.floatString('x00281053');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof rescaleSlope === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289145.items[0].dataSet;\n      rescaleSlope = philipsPrivateSequence.floatString('x00281052');\n    } else {\n      // default rescaleSlope\n      rescaleSlope = null;\n    }\n  }\n\n  return rescaleSlope;\n};\n\nVJS.parsers.dicom.prototype.windowCenter =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowCenter = this._dataSet.floatString('x00281050');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowCenter === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!.\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowCenter = philipsPrivateSequence.floatString('x00281050');\n    } else {\n      // default windowCenter\n      // print warning at least...\n      windowCenter = null;\n    }\n  }\n\n  return windowCenter;\n};\n\nVJS.parsers.dicom.prototype.windowWidth =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var windowWidth = this._dataSet.floatString('x00281051');\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group\n  if (typeof windowWidth === 'undefined') {\n    // per frame functionnal group sequence\n    var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n    if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n      // NOT A PHILIPS TRICK!\n      var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n        .items[frameIndex].dataSet.elements.x00289132.items[0].dataSet;\n      windowWidth = philipsPrivateSequence.floatString('x00281051');\n    } else {\n      // default windowWidth\n      // print warning at least...\n      windowWidth = null;\n    }\n  }\n  return windowWidth;\n};\n\nVJS.parsers.dicom.prototype.dimensionIndexValues =  function(frameIndex) {\n  var dimensionIndexValues = [];\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n    var element = philipsPrivateSequence.elements.x00209157;\n    // /4 because UL\n    var nbValues = element.length / 4;\n    for (var i = 0; i < nbValues; i++) {\n      dimensionIndexValues.push(philipsPrivateSequence.uint32('x00209157', i));\n    }\n  } else {\n    dimensionIndexValues = null;\n  }\n\n  return dimensionIndexValues;\n};\n\nVJS.parsers.dicom.prototype.inStackPositionNumber =  function(frameIndex) {\n  var inStackPositionNumber = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');\n  } else {\n    inStackPositionNumber = null;\n  }\n\n  return inStackPositionNumber;\n};\n\n\nVJS.parsers.dicom.prototype.stackID =  function(frameIndex) {\n  var stackID = null;\n\n  // try to get it from enhanced MR images\n  // per-frame functionnal group sequence\n  var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;\n\n  if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {\n    // NOT A PHILIPS TRICK!\n    var philipsPrivateSequence = perFrameFunctionnalGroupSequence\n      .items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;\n      stackID = philipsPrivateSequence.intString('x00209056');\n  } else {\n    stackID = null;\n  }\n\n  return stackID;\n};\n\nVJS.parsers.dicom.prototype.dPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var dPixelData = [];\n  // http://www.dicomlibrary.com/dicom/transfer-syntax/\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {  // JPEG 2000 lossy\n    //window.console.log('JPG2000 in action!');\n    // window.console.log(this._dataSet);\n    //window.console.log(dicomParser);\n    //window.console.log(this._dataSet.elements);\n    //var compressedPixelData = dicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);\n    var pixelDataElement = this._dataSet.elements.x7fe00010;\n    var pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);\n    // var jpxImage = new jpx();\n    // jpxImage.parse(pixelData);\n\n    // var j2kWidth = jpxImage.width;\n    // var j2kHeight = jpxImage.height;\n\n    // window.console.log(jpxImage);\n  }\n\n  return dPixelData;\n};\n\nVJS.parsers.dicom.prototype.extractPixelData =  function(frameIndex) {\n  // expect frame index to start at 0!\n  var ePixelData = null;\n\n  // if compressed..?\n  var transferSyntaxUID = this.transferSyntaxUID();\n\n  // find compression scheme\n  if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||  // JPEG 2000 lossless\n      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {\n    return ePixelData;\n  }\n\n  // else\n  // ned to guess pixel format to know if uint8, unit16 or int16\n  // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size\n  var pixelRepresentation = this.pixelRepresentation(frameIndex);\n  var bitsAllocated = this.bitsAllocated(frameIndex);\n  var pixelDataElement = this._dataSet.elements.x7fe00010;\n  var pixelDataOffset = pixelDataElement.dataOffset;\n  var numberOfChannels  = this.numberOfChannels();\n  var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;\n  var frameOffset = 0;\n\n  if (numberOfChannels === 1) {\n    if (pixelRepresentation === 0 && bitsAllocated === 8) {\n\n      // unsigned 8 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels;\n      ePixelData =  new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 0 && bitsAllocated === 16) {\n\n      // unsigned 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Uint16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    } else if (pixelRepresentation === 1 && bitsAllocated === 16) {\n\n      // signed 16 bit\n      frameOffset = pixelDataOffset + frameIndex * numPixels * 2;\n      ePixelData = new Int16Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n\n    }\n  } else {\n    // ASSUME RGB 8 BITS SIGNED!\n    frameOffset = pixelDataOffset + frameIndex * numPixels;\n    var encodedPixelData = new Uint8Array(this._dataSet.byteArray.buffer, frameOffset, numPixels);\n    var photometricInterpretation = this.photometricInterpretation();\n\n    if (photometricInterpretation === 'RGB') {\n      // ALL GOOD, ALREADY ORDERED\n      ePixelData = encodedPixelData;\n\n    } else if (photometricInterpretation === 'YBR_FULL') {\n      ePixelData = new Uint8Array(numPixels);\n      // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js\n      var nPixels = numPixels / 3;\n      var ybrIndex = 0;\n      var rgbaIndex = 0;\n      for (var i = 0; i < nPixels; i++) {\n        var y = encodedPixelData[ybrIndex++];\n        var cb = encodedPixelData[ybrIndex++];\n        var cr = encodedPixelData[ybrIndex++];\n        ePixelData[rgbaIndex++] = y + 1.40200 * (cr - 128);// red\n        ePixelData[rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green\n        ePixelData[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue\n        ePixelData[rgbaIndex++] = 255; //alpha\n      }\n    } else {\n      window.console.log('photometric interpolation not supported: ' + photometricInterpretation);\n    }\n\n  }\n\n  return ePixelData;\n};\n\nVJS.parsers.dicom.prototype.minMaxPixelData =  function(pixelData) {\n\n  var minMax = [65535, -32768];\n  var numPixels = pixelData.length;\n  for (var index = 0; index < numPixels; index++) {\n    var spv = pixelData[index];\n    // TODO: test to see if it is faster to use conditional here rather than calling min/max functions\n    minMax[0] = Math.min(minMax[0], spv);\n    minMax[1] = Math.max(minMax[1], spv);\n  }\n\n  return minMax;\n};\n\nVJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {\n  // try to access frame of reference UID through its DICOM tag\n  var seriesNumber = imageJqueryDom.find('[tag=\"00200052\"] Value').text();\n\n  // if not available, assume we only have 1 frame\n  if (seriesNumber === '') {\n    seriesNumber = 1;\n  }\n  return seriesNumber;\n};\n\n//\n// getFrame\n// getFrameSpacing\n// getFrame...\n// getStach\n// getStack...\n// image ...\n\n// merge!\n\n// export the probePixel widget module\nmodule.exports = VJS.parsers.dicom;\n","'use strict';\n\nvar VJS = VJS || {};\nVJS.shaders = VJS.shaders || {};\n\n/**\n *\n * Custom shader for the slice object. Should be a shader directory. We can add this shader to any object...\n * @member\n *\n */\n\nVJS.shaders.data = {\n\n    /* -------------------------------------------------------------------------\n    //  Slice shader\n    // features:\n    //\n     ------------------------------------------------------------------------- */\n\n    'parameters': {\n\n        uniforms: {\n            'uTextureSize': {\n                type: 'f',\n                value: 0.0\n            },\n            'uTextureContainer': {\n                type: 'tv',\n                value: null\n            },\n            'uDataDimensions': {\n                type: 'v3',\n                value: new THREE.Vector3()\n            },\n            'uWorldToData': {\n                type: 'm4',\n                value: new THREE.Matrix4()\n            },\n            'uWindowLevel': {\n                type: 'fv1',\n                value: [0.0,0.0]\n            },\n            'uNumberOfChannels': {\n                type: 'i',\n                value: 1\n            },\n            'uBitsAllocated': {\n                type: 'i',\n                value: 8\n            },\n            'uInvert': {\n                type: 'i',\n                value: 0\n            }\n        }\n\n    }\n\n};\n\nmodule.exports = VJS.shaders.data;\n","/*! dicom-parser - v1.0.2 - 2015-05-30 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */\n(function (root, factory) {\n\n    // node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        if(dicomParser === undefined) {\n            dicomParser = {};\n\n            // meteor\n            if (typeof Package !== 'undefined') {\n                root.dicomParser = dicomParser;\n            }\n        }\n        dicomParser = factory();\n    }\n}(this, function () {\n\n    /**\n     * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n     * argument is supplied and it contains the untilTag property, parsing will stop once that\n     * tag is encoutered.  This can be used to parse partial byte streams.\n     *\n     * @param byteArray the byte array\n     * @param options object to control parsing behavior (optional)\n     * @returns {DataSet}\n     * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n     *         elements successfully parsed before the error.\n     */\n     function parseDicom(byteArray, options) {\n\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.parseDicom: missing required parameter 'byteArray'\";\n        }\n\n        var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n\n        function readPrefix()\n        {\n            littleEndianByteStream.seek(128);\n            var prefix = littleEndianByteStream.readFixedString(4);\n            if(prefix !== \"DICM\")\n            {\n                throw \"dicomParser.parseDicom: DICM prefix not found at location 132\";\n            }\n        }\n\n        function readPart10Header()\n        {\n            // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n            // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n            readPrefix();\n\n            var warnings = [];\n            var elements = {};\n            while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n                var position = littleEndianByteStream.position;\n                var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);\n                if(element.tag > 'x0002ffff') {\n                    littleEndianByteStream.position = position;\n                    break;\n                }\n                // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n                // and this parser will be needed later if the meta header values are to be read.\n                element.parser = dicomParser.littleEndianByteArrayParser;\n                elements[element.tag] = element;\n            }\n            var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n            metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n            return metaHeaderDataSet;\n        }\n\n        function readTransferSyntax(metaHeaderDataSet) {\n            if(metaHeaderDataSet.elements.x00020010 === undefined) {\n                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';\n            }\n            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n            return dicomParser.readFixedString(littleEndianByteStream.byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n        }\n\n        function isExplicit(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian\n            {\n                return false;\n            }\n            // all other transfer syntaxes should be explicit\n            return true;\n        }\n\n        function getDataSetByteStream(transferSyntax) {\n            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian\n            {\n                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n            else\n            {\n                // all other transfer syntaxes are little endian; only the pixel encoding differs\n                // make a new stream so the metaheader warnings don't come along for the ride\n                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, littleEndianByteStream.position);\n            }\n        }\n\n        function mergeDataSets(metaHeaderDataSet, instanceDataSet)\n        {\n            for (var propertyName in metaHeaderDataSet.elements)\n            {\n                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))\n                {\n                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n                }\n            }\n            if (metaHeaderDataSet.warnings !== undefined) {\n                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n            }\n            return instanceDataSet;\n        }\n\n        function readDataSet(metaHeaderDataSet)\n        {\n            var transferSyntax = readTransferSyntax(metaHeaderDataSet);\n            var explicit = isExplicit(transferSyntax);\n            var dataSetByteStream = getDataSetByteStream(transferSyntax);\n\n            var elements = {};\n            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n            dataSet.warnings = dataSetByteStream.warnings;\n\n            try{\n                if(explicit) {\n                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n                else\n                {\n                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n                }\n            }\n            catch(e) {\n                var ex = {\n                    exception: e,\n                    dataSet: dataSet\n                };\n                throw ex;\n            }\n            return dataSet;\n        }\n\n        // main function here\n        function parseTheByteStream() {\n            var metaHeaderDataSet = readPart10Header();\n\n            var dataSet = readDataSet(metaHeaderDataSet);\n\n            return mergeDataSets(metaHeaderDataSet, dataSet);\n        }\n\n        // This is where we actually start parsing\n        return parseTheByteStream();\n    }\n\n    if(dicomParser === undefined) {\n        // this happens in the AMD case\n        return {\n            parseDicom: parseDicom\n        };\n    }\n    else {\n        // this is the browser global var case\n        dicomParser.parseDicom = parseDicom;\n        return dicomParser;\n    }\n}));\n\n/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.bigEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return (byteArray[position] << 8) + byteArray[position + 1];\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n        /**\n         * Parses an unsigned int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                              byteArray[position + 1]) +\n                                              byteArray[position + 2]) +\n                                              byteArray[position + 3]);\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = ((byteArray[position] << 24) +\n                         (byteArray[position + 1] << 16) +\n                         (byteArray[position + 2] << 8) +\n                          byteArray[position + 3]);\n\n            return int32;\n        },\n\n        /**\n         * Parses 32-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[3] = byteArray[position];\n            byteArrayForParsingFloat[2] = byteArray[position + 1];\n            byteArrayForParsingFloat[1] = byteArray[position + 2];\n            byteArrayForParsingFloat[0] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a big-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[7] = byteArray[position];\n            byteArrayForParsingFloat[6] = byteArray[position + 1];\n            byteArrayForParsingFloat[5] = byteArray[position + 2];\n            byteArrayForParsingFloat[4] = byteArray[position + 3];\n            byteArrayForParsingFloat[3] = byteArray[position + 4];\n            byteArrayForParsingFloat[2] = byteArray[position + 5];\n            byteArrayForParsingFloat[1] = byteArray[position + 6];\n            byteArrayForParsingFloat[0] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.  Trailing and leading\n     * spaces are preserved (not trimmed)\n     * @param byteArray the byteArray to read from\n     * @param position the position in the byte array to read from\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n    dicomParser.readFixedString = function(byteArray, position, length)\n    {\n        if(length < 0)\n        {\n            throw 'readFixedString - length cannot be less than 0';\n        }\n\n        if(position + length > byteArray.length) {\n            throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n        }\n\n        var result = \"\";\n        for(var i=0; i < length; i++)\n        {\n            var byte = byteArray[position + i];\n            if(byte === 0) {\n                position +=  length;\n                return result;\n            }\n            result += String.fromCharCode(byte);\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Constructor for ByteStream objects.\n     * @param byteArrayParser a parser for parsing the byte array\n     * @param byteArray a Uint8Array containing the byte stream\n     * @param position (optional) the position to start reading from.  0 if not specified\n     * @constructor\n     * @throws will throw an error if the byteArrayParser parameter is not present\n     * @throws will throw an error if the byteArray parameter is not present or invalid\n     * @throws will throw an error if the position parameter is not inside the byte array\n     */\n    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {\n        if(byteArrayParser === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n        }\n        if(byteArray === undefined)\n        {\n            throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n        }\n        if((byteArray instanceof Uint8Array) === false) {\n            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array';\n        }\n        if(position < 0)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n        }\n        if(position >= byteArray.length)\n        {\n            throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n\n        }\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.position = position ? position : 0;\n        this.warnings = []; // array of string warnings encountered while parsing\n    };\n\n    /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n    dicomParser.ByteStream.prototype.seek = function(offset)\n    {\n        if(this.position + offset < 0)\n        {\n            throw \"cannot seek to position < 0\";\n        }\n        this.position += offset;\n    };\n\n    /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)\n    {\n        if(this.position + numBytes > this.byteArray.length) {\n            throw 'readByteStream - buffer overread';\n        }\n        var byteArrayView = new Uint8Array(this.byteArray.buffer, this.position, numBytes);\n        this.position += numBytes;\n        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);\n    };\n\n    /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint16 = function()\n    {\n        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n        this.position += 2;\n        return result;\n    };\n\n    /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readUint32 = function()\n    {\n        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n        this.position += 4;\n        return result;\n    };\n\n    /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n    dicomParser.ByteStream.prototype.readFixedString = function(length)\n    {\n        var result = dicomParser.readFixedString(this.byteArray, this.position, length);\n        this.position += length;\n        return result;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getByteArrayParser(element, defaultParser)\n    {\n        return (element.parser !== undefined ? element.parser : defaultParser);\n    }\n\n    /**\n     * Constructs a new DataSet given byteArray and collection of elements\n     * @param byteArrayParser\n     * @param byteArray\n     * @param elements\n     * @constructor\n     */\n    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)\n    {\n        this.byteArrayParser = byteArrayParser;\n        this.byteArray = byteArray;\n        this.elements = elements;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int16 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.uint32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.int32 = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n    dicomParser.DataSet.prototype.float = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n        }\n        return undefined;\n    };\n\n    /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n    dicomParser.DataSet.prototype.double = function(tag, index)\n    {\n        var element = this.elements[tag];\n        index = (index !== undefined) ? index : 0;\n        if(element && element.length !== 0)\n        {\n            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n    dicomParser.DataSet.prototype.numStringValues = function(tag)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            var numMatching = fixedString.match(/\\\\/g);\n            if(numMatching === null)\n            {\n                return 1;\n            }\n            return numMatching.length + 1;\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.string = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                // trim trailing spaces\n                return values[index].trim();\n            }\n            else\n            {\n                // trim trailing spaces\n                return fixedString.trim();\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n    dicomParser.DataSet.prototype.text = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);\n            if(index >= 0)\n            {\n                var values = fixedString.split('\\\\');\n                return values[index].replace(/ +$/, '');\n            }\n            else\n            {\n                return fixedString.replace(/ +$/, '');\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.floatString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0)\n        {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseFloat(value);\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n    dicomParser.DataSet.prototype.intString = function(tag, index)\n    {\n        var element = this.elements[tag];\n        if(element && element.length > 0) {\n            index = (index !== undefined) ? index : 0;\n            var value = this.string(tag, index);\n            if(value !== undefined) {\n                return parseInt(value);\n            }\n        }\n        return undefined;\n    };\n\n    //dicomParser.DataSet = DataSet;\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads an encapsulated pixel data element and adds an array of fragments to the element\n     * containing the offset and length of each fragment and any offsets from the basic offset\n     * table\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n        }\n\n        element.encapsulatedPixelData = true;\n        element.basicOffsetTable = [];\n        element.fragments = [];\n        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);\n        if(basicOffsetTableItemTag !== 'xfffee000') {\n            throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n        }\n        var basicOffsetTableItemlength = byteStream.readUint32();\n        var numFragments = basicOffsetTableItemlength / 4;\n        for(var i =0; i < numFragments; i++) {\n            var offset = byteStream.readUint32();\n            element.basicOffsetTable.push(offset);\n        }\n        var baseOffset = byteStream.position;\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var tag = dicomParser.readTag(byteStream);\n            var length = byteStream.readUint32();\n            if(tag === 'xfffee0dd')\n            {\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n            else if(tag === 'xfffee000')\n            {\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n            }\n            else {\n                if(warnings) {\n                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');\n                }\n                if(length > byteStream.byteArray.length - byteStream.position)\n                {\n                    // fix length\n                    length = byteStream.byteArray.length - byteStream.position;\n                }\n                element.fragments.push({\n                    offset: byteStream.position - baseOffset - 8,\n                    position : byteStream.position,\n                    length : length\n                });\n                byteStream.seek(length);\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n\n            byteStream.seek(length);\n        }\n\n        if(warnings) {\n            warnings.push(\"pixel data element \" + element.tag + \" missing sequence delimiter tag xfffee0dd\");\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads from the byte stream until it finds the magic numbers for the item delimitation item\n     * and then sets the length of the element\n     * @param byteStream\n     * @param element\n     */\n    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var itemDelimitationItemLength = 8; // group, element, length\n        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n        while(byteStream.position <= maxPosition)\n        {\n            var groupNumber = byteStream.readUint16();\n            if(groupNumber === 0xfffe)\n            {\n                var elementNumber = byteStream.readUint16();\n                if(elementNumber === 0xe00d)\n                {\n                    // NOTE: It would be better to also check for the length to be 0 as part of the check above\n                    // but we will just log a warning for now\n                    var itemDelimiterLength = byteStream.readUint32(); // the length\n                    if(itemDelimiterLength !== 0) {\n                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + \" while reading element of undefined length with tag ' + element.tag\");\n                    }\n                    element.length = byteStream.position - element.dataOffset;\n                    return;\n\n                }\n            }\n        }\n\n        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n        element.length = byteStream.byteArray.length - element.dataOffset;\n        byteStream.seek(byteStream.byteArray.length - byteStream.position);\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.littleEndianByteArrayParser = {\n        /**\n         *\n         * Parses an unsigned int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n            }\n            return byteArray[position] + (byteArray[position + 1] * 256);\n        },\n\n        /**\n         *\n         * Parses a signed int 16 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed signed int 16\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt16: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n            }\n            if (position + 2 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n            }\n            var int16 = byteArray[position] + (byteArray[position + 1] << 8);\n            // fix sign\n            if (int16 & 0x8000) {\n                int16 = int16 - 0xFFFF - 1;\n            }\n            return int16;\n        },\n\n\n        /**\n         * Parses an unsigned int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readUint32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n            }\n\n            var uint32 = (byteArray[position] +\n            (byteArray[position + 1] * 256) +\n            (byteArray[position + 2] * 256 * 256) +\n            (byteArray[position + 3] * 256 * 256 * 256 ));\n\n            return uint32;\n        },\n\n        /**\n         * Parses a signed int 32 from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed unsigned int 32\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readInt32: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n            }\n\n            var int32 = (byteArray[position] +\n            (byteArray[position + 1] << 8) +\n            (byteArray[position + 2] << 16) +\n            (byteArray[position + 3] << 24));\n\n            return int32;\n\n        },\n\n        /**\n         * Parses 32-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 32-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readFloat: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n            }\n\n            if (position + 4 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(4);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        },\n\n        /**\n         * Parses 64-bit float from a little-endian byte array\n         *\n         * @param byteArray the byte array to read from\n         * @param position the position in the byte array to read from\n         * @returns {*} the parsed 64-bit float\n         * @throws error if buffer overread would occur\n         * @access private\n         */\n        readDouble: function (byteArray, position) {\n            if (position < 0) {\n                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n            }\n\n            if (position + 8 > byteArray.length) {\n                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n            }\n\n            // I am sure there is a better way than this but this should be safe\n            var byteArrayForParsingFloat = new Uint8Array(8);\n            byteArrayForParsingFloat[0] = byteArray[position];\n            byteArrayForParsingFloat[1] = byteArray[position + 1];\n            byteArrayForParsingFloat[2] = byteArray[position + 2];\n            byteArrayForParsingFloat[3] = byteArray[position + 3];\n            byteArrayForParsingFloat[4] = byteArray[position + 4];\n            byteArrayForParsingFloat[5] = byteArray[position + 5];\n            byteArrayForParsingFloat[6] = byteArray[position + 6];\n            byteArrayForParsingFloat[7] = byteArray[position + 7];\n            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n            return floatArray[0];\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * reads an explicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {\n\n        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'\";\n        }\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n        if(byteStream.position > maxPosition) {\n            throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n        }\n    };\n\n    /**\n     * reads an implicit data set\n     * @param byteStream the byte stream to read from\n     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n     */\n    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)\n    {\n        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;\n        options = options || {};\n\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n        }\n        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)\n        {\n            throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n        }\n\n        var elements = dataSet.elements;\n\n        while(byteStream.position < maxPosition)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag);\n            elements[element.tag] = element;\n            if(element.tag === options.untilTag) {\n                return;\n            }\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getDataLengthSizeInBytesForVR(vr)\n    {\n        if( vr === 'OB' ||\n            vr === 'OW' ||\n            vr === 'SQ' ||\n            vr === 'OF' ||\n            vr === 'UT' ||\n            vr === 'UN')\n        {\n            return 4;\n        }\n        else\n        {\n            return 2;\n        }\n    }\n\n    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            vr : byteStream.readFixedString(2)\n            // length set below based on VR\n            // dataOffset set below based on VR and size of length\n        };\n\n        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n        if(dataLengthSizeBytes === 2)\n        {\n            element.length = byteStream.readUint16();\n            element.dataOffset = byteStream.position;\n        }\n        else\n        {\n            byteStream.seek(2);\n            element.length = byteStream.readUint32();\n            element.dataOffset = byteStream.position;\n        }\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // if VR is SQ, parse the sequence items\n        if(element.vr === 'SQ')\n        {\n            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);\n            return element;\n        }\n        if(element.length === 4294967295)\n        {\n            if(element.tag === 'x7fe00010') {\n                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);\n                return element;\n            } else {\n                dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n                return element;\n            }\n        }\n\n        byteStream.seek(element.length);\n        return element;\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    dicomParser.readDicomElementImplicit = function(byteStream, untilTag)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length: byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        if(element.length === 4294967295)\n        {\n            element.hadUndefinedLength = true;\n        }\n\n        if(element.tag === untilTag) {\n            return element;\n        }\n\n        // peek ahead at the next tag to see if it looks like a sequence.  This is not 100%\n        // safe because a non sequence item could have data that has these bytes, but this\n        // is how to do it without a data dictionary.\n        if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n            var nextTag = dicomParser.readTag(byteStream);\n            byteStream.seek(-4);\n\n            if (nextTag === 'xfffee000') {\n                // parse the sequence\n                dicomParser.readSequenceItemsImplicit(byteStream, element);\n                //element.length = byteStream.byteArray.length - element.dataOffset;\n                return element;\n            }\n        }\n\n        // if element is not a sequence and has undefined length, we have to\n        // scan the data for a magic number to figure out when it ends.\n        if(element.length === 4294967295)\n        {\n            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);\n            return element;\n        }\n\n        // non sequence element with known length, skip over the data part\n        byteStream.seek(element.length);\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function getPixelDataFromFragments(byteStream, fragments, bufferSize)\n    {\n        // if there is only one fragment, return a view on this array to avoid copying\n        if(fragments.length === 1) {\n            return new Uint8Array(byteStream.byteArray.buffer, fragments[0].dataOffset, fragments[0].length);\n        }\n\n        // more than one fragment, combine all of the fragments into one buffer\n        var pixelData = new Uint8Array(bufferSize);\n        var pixelDataIndex = 0;\n        for(var i=0; i < fragments.length; i++) {\n            var fragmentOffset = fragments[i].dataOffset;\n            for(var j=0; j < fragments[i].length; j++) {\n                pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n            }\n        }\n\n        return pixelData;\n    }\n\n    function readFragmentsUntil(byteStream, endOfFrame) {\n        // Read fragments until we reach endOfFrame\n        var fragments = [];\n        var bufferSize = 0;\n        while(byteStream.position < endOfFrame && byteStream.position < byteStream.byteArray.length) {\n            var fragment = dicomParser.readSequenceItem(byteStream);\n            // NOTE: we only encounter this for the sequence delimiter tag when extracting the last frame\n            if(fragment.tag === 'xfffee0dd') {\n                break;\n            }\n            fragments.push(fragment);\n            byteStream.seek(fragment.length);\n            bufferSize += fragment.length;\n        }\n\n        // Convert the fragments into a single pixelData buffer\n        var pixelData = getPixelDataFromFragments(byteStream, fragments, bufferSize);\n        return pixelData;\n    }\n\n    function readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        //  validate that we have an offset for this frame\n        var numFrames = pixelDataElement.basicOffsetTable.length;\n        if(frame > numFrames) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter frame exceeds number of frames in basic offset table\";\n        }\n\n        // move to the start of this frame\n        var frameOffset = pixelDataElement.basicOffsetTable[frame];\n        byteStream.seek(frameOffset);\n\n        // Find the end of this frame\n        var endOfFrameOffset = pixelDataElement.basicOffsetTable[frame + 1];\n        if(endOfFrameOffset === undefined) { // special case for last frame\n            endOfFrameOffset = byteStream.position + pixelDataElement.length;\n        }\n\n        // read this frame\n        var pixelData = readFragmentsUntil(byteStream, endOfFrameOffset);\n        return pixelData;\n    }\n\n    function readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame) {\n        // if the basic offset table is empty, this is a single frame so make sure the requested\n        // frame is 0\n        if(frame !== 0) {\n            throw 'dicomParser.readEncapsulatedPixelData: non zero frame specified for single frame encapsulated pixel data';\n        }\n\n        // read this frame\n        var endOfFrame = byteStream.position + pixelDataElement.length;\n        var pixelData = readFragmentsUntil(byteStream, endOfFrame);\n        return pixelData;\n    }\n\n    /**\n     * Returns the pixel data for the specified frame in an encapsulated pixel data element\n     *\n     * @param dataSet - the dataSet containing the encapsulated pixel data\n     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n     * @param frame - the zero based frame index\n     * @returns Uint8Array with the encapsulated pixel data\n     */\n    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)\n    {\n        if(dataSet === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n        }\n        if(pixelDataElement === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n        }\n        if(frame === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n        }\n        if(pixelDataElement.tag !== 'x7fe00010') {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'\";\n        }\n        if(pixelDataElement.encapsulatedPixelData !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.hadUndefinedLength !== true) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.basicOffsetTable === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(pixelDataElement.fragments === undefined) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n        }\n        if(frame < 0) {\n            throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n        }\n\n        // seek past the basic offset table (no need to parse it again since we already have)\n        var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n        var basicOffsetTable = dicomParser.readSequenceItem(byteStream);\n        if(basicOffsetTable.tag !== 'xfffee000')\n        {\n            throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n        }\n        byteStream.seek(basicOffsetTable.length);\n\n        // If the basic offset table is empty (no entries), it is a single frame.  If it is not empty,\n        // it has at least one frame so use the basic offset table to find the bytes\n        if(pixelDataElement.basicOffsetTable.length !== 0)\n        {\n            return readEncapsulatedPixelDataWithBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n        else\n        {\n            return readEncapsulatedDataNoBasicOffsetTable(pixelDataElement, byteStream, frame);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n\n        }\n\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item while reading sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemExplicit(byteStream, warnings)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence element of undefined length with tag ' + element.tag);\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthExplicit(byteStream, element, warnings)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemExplicit(byteStream, warnings);\n            element.items.push(item);\n        }\n    }\n\n    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthExplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthExplicit(byteStream, element, warnings);\n        }\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    function readDicomDataSetImplicitUndefinedLength(byteStream)\n    {\n        var elements = {};\n\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var element = dicomParser.readDicomElementImplicit(byteStream);\n            elements[element.tag] = element;\n\n            // we hit an item delimiter tag, return the current offset to mark\n            // the end of this sequence item\n            if(element.tag === 'xfffee00d')\n            {\n                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n            }\n        }\n        // eof encountered - log a warning and return what we have for the element\n        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n\n    function readSequenceItemImplicit(byteStream)\n    {\n        var item = dicomParser.readSequenceItem(byteStream);\n\n        if(item.length === 4294967295)\n        {\n            item.hadUndefinedLength = true;\n            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream);\n            item.length = byteStream.position - item.dataOffset;\n        }\n        else\n        {\n            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length);\n        }\n        return item;\n    }\n\n    function readSQElementUndefinedLengthImplicit(byteStream, element)\n    {\n        while(byteStream.position < byteStream.byteArray.length)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n\n            // If this is the sequence delimitation item, return the offset of the next element\n            if(item.tag === 'xfffee0dd')\n            {\n                // sequence delimitation item, update attr data length and return\n                element.length = byteStream.position - element.dataOffset;\n                return;\n            }\n        }\n\n        // eof encountered - log a warning and set the length of the element based on the buffer size\n        byteStream.warnings.push('eof encountered before finding sequence delimitation item in sequence of undefined length');\n        element.length = byteStream.byteArray.length - element.dataOffset;\n    }\n\n    function readSQElementKnownLengthImplicit(byteStream, element)\n    {\n        var maxPosition = element.dataOffset + element.length;\n        while(byteStream.position < maxPosition)\n        {\n            var item = readSequenceItemImplicit(byteStream);\n            element.items.push(item);\n        }\n    }\n\n    /**\n     * Reads sequence items for an element in an implicit little endian byte stream\n     * @param byteStream the implicit little endian byte stream\n     * @param element the element to read the sequence items for\n     */\n    dicomParser.readSequenceItemsImplicit = function(byteStream, element)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n        }\n        if(element === undefined)\n        {\n            throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n        }\n\n        element.items = [];\n\n        if(element.length === 4294967295)\n        {\n            readSQElementUndefinedLengthImplicit(byteStream, element);\n        }\n        else\n        {\n            readSQElementKnownLengthImplicit(byteStream, element);\n        }\n    };\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads the tag and length of a sequence item and returns them as an object with the following properties\n     *  tag : string for the tag of this element in the format xggggeeee\n     *  length: the number of bytes in this item or 4294967295 if undefined\n     *  dataOffset: the offset into the byteStream of the data for this item\n     * @param byteStream the byte\n     * @returns {{tag: string, length: integer, dataOffset: integer}}\n     */\n    dicomParser.readSequenceItem = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n        }\n\n        var element = {\n            tag : dicomParser.readTag(byteStream),\n            length : byteStream.readUint32(),\n            dataOffset :  byteStream.position\n        };\n\n        return element;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    /**\n     * Reads a tag (group number and element number) from a byteStream\n     * @param byteStream the byte stream to read from\n     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n     * and eeee is the lower case hex value of the element number\n     */\n    dicomParser.readTag = function(byteStream)\n    {\n        if(byteStream === undefined)\n        {\n            throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n        }\n\n        var groupNumber =  byteStream.readUint16() * 256 * 256;\n        var elementNumber = byteStream.readUint16();\n        var tag = \"x\" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);\n        return tag;\n    };\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * converts an explicit dataSet to a javascript object\n     * @param dataSet\n     * @param options\n     */\n    dicomParser.explicitDataSetToJS = function (dataSet, options) {\n\n        if(dataSet === undefined) {\n            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n        }\n\n        options = options || {\n            omitPrivateAttibutes: true, // true if private elements should be omitted\n            maxElementLength : 128      // maximum element length to try and convert to string format\n        };\n\n        var result = {\n\n        };\n\n        for(var tag in dataSet.elements) {\n            var element = dataSet.elements[tag];\n\n            // skip this element if it a private element and our options specify that we should\n            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))\n            {\n                continue;\n            }\n\n            if(element.items) {\n                // handle sequences\n                var sequenceItems = [];\n                for(var i=0; i < element.items.length; i++) {\n                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));\n                }\n                result[tag] = sequenceItems;\n            } else {\n                var asString;\n                asString = undefined;\n                if(element.length < options.maxElementLength) {\n                    asString = dicomParser.explicitElementToString(dataSet, element);\n                }\n\n                if(asString !== undefined) {\n                    result[tag] = asString;\n                }  else {\n                    result[tag] = {\n                        dataOffset: element.dataOffset,\n                        length : element.length\n                    };\n                }\n            }\n        }\n\n        return result;\n    };\n\n\n    return dicomParser;\n}(dicomParser));\nvar dicomParser = (function (dicomParser) {\n    \"use strict\";\n\n    if (dicomParser === undefined) {\n        dicomParser = {};\n    }\n\n    /**\n     * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n     * Throws an error if an implicit element is supplied\n     * @param dataSet\n     * @param element\n     * @returns {*}\n     */\n    dicomParser.explicitElementToString = function(dataSet, element)\n    {\n        if(dataSet === undefined || element === undefined) {\n            throw 'dicomParser.explicitElementToString: missing required parameters';\n        }\n        if(element.vr === undefined) {\n            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n        }\n        var vr = element.vr;\n        var tag = element.tag;\n\n        var textResult;\n\n        function multiElementToString(numItems, func) {\n            var result = \"\";\n            for(var i=0; i < numItems; i++) {\n                if(i !== 0) {\n                    result += '/';\n                }\n                result += func.call(dataSet, tag).toString();\n            }\n            return result;\n        }\n\n        if(dicomParser.isStringVr(vr) === true)\n        {\n            textResult = dataSet.string(tag);\n        }\n        else if (vr == 'AT') {\n            var num = dataSet.uint32(tag);\n            if(num === undefined) {\n                return undefined;\n            }\n            if (num < 0)\n            {\n                num = 0xFFFFFFFF + num + 1;\n            }\n\n            return 'x' + num.toString(16).toUpperCase();\n        }\n        else if (vr == 'US')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.uint16);\n        }\n        else if(vr === 'SS')\n        {\n            textResult = multiElementToString(element.length / 2, dataSet.int16);\n        }\n        else if (vr == 'UL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.uint32);\n        }\n        else if(vr === 'SL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.int32);\n        }\n        else if(vr == 'FD')\n        {\n            textResult = multiElementToString(element.length / 8, dataSet.int32);\n        }\n        else if(vr == 'FL')\n        {\n            textResult = multiElementToString(element.length / 4, dataSet.float);\n        }\n\n        return textResult;\n    };\n    return dicomParser;\n}(dicomParser));\n/**\n * Utility functions for dealing with DICOM\n */\n\nvar dicomParser = (function (dicomParser)\n{\n    \"use strict\";\n\n    if(dicomParser === undefined)\n    {\n        dicomParser = {};\n    }\n\n    var stringVrs = {\n        AE: true,\n        AS: true,\n        AT: false,\n        CS: true,\n        DA: true,\n        DS: true,\n        DT: true,\n        FL: false,\n        FD: false,\n        IS: true,\n        LO: true,\n        LT: true,\n        OB: false,\n        OD: false,\n        OF: false,\n        OW: false,\n        PN: true,\n        SH: true,\n        SL: false,\n        SQ: false,\n        SS: false,\n        ST: true,\n        TM: true,\n        UI: true,\n        UL: false,\n        UN: undefined, // dunno\n        UR: true,\n        US: false,\n        UT: true\n    };\n\n    /**\n     * Tests to see if vr is a string or not.\n     * @param vr\n     * @returns true if string, false it not string, undefined if unknown vr or UN type\n     */\n    dicomParser.isStringVr = function(vr)\n    {\n        return stringVrs[vr];\n    };\n\n    /**\n     * Tests to see if a given tag in the format xggggeeee is a private tag or not\n     * @param tag\n     * @returns {boolean}\n     */\n    dicomParser.isPrivateTag = function(tag)\n    {\n        var lastGroupDigit = parseInt(tag[4]);\n        var groupIsOdd = (lastGroupDigit % 2) === 1;\n        return groupIsOdd;\n    };\n\n    /**\n     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n     * @param personName a string in the PN VR format\n     * @param index\n     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n     */\n    dicomParser.parsePN = function(personName) {\n        if(personName === undefined) {\n            return undefined;\n        }\n        var stringValues = personName.split('^');\n        return {\n            familyName: stringValues[0],\n            givenName: stringValues[1],\n            middleName: stringValues[2],\n            prefix: stringValues[3],\n            suffix: stringValues[4]\n        };\n    };\n\n    /**\n     * Parses a DA formatted string into a Javascript object\n     * @param date a string in the DA VR format\n     * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n     */\n    dicomParser.parseDA = function(date)\n    {\n        if(date && date.length === 8)\n        {\n            var yyyy = parseInt(date.substring(0, 4), 10);\n            var mm = parseInt(date.substring(4, 6), 10);\n            var dd = parseInt(date.substring(6, 8), 10);\n\n            return {\n                year: yyyy,\n                month: mm,\n                day: dd\n            };\n        }\n        return undefined;\n    };\n\n    /**\n     * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n     * @param time a string in the TM VR format\n     * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n     */\n    dicomParser.parseTM = function(time) {\n\n        if (time.length >= 2) // must at least have HH\n        {\n            // 0123456789\n            // HHMMSS.FFFFFF\n            var hh = parseInt(time.substring(0, 2), 10);\n            var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n            var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n            var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;\n\n            return {\n                hours: hh,\n                minutes: mm,\n                seconds: ss,\n                fractionalSeconds: ffffff\n            };\n        }\n        return undefined;\n    };\n\n    return dicomParser;\n}(dicomParser));"],"sourceRoot":"/source/"}