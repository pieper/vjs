<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: deprecated/modules/slice/Slice.View.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: deprecated/modules/slice/Slice.View.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};
VJS.slice = VJS.slice || {};

/**
 * View class of slice component. Provides method to generate and interact all
 * slice related visualization.
 *
 * It includes the slice, the border of the slice, the slice normal, the
 * intersection between the slice, the slice center of mass, the data bouding
 * box, etc.
 *
 * Doesn&#x27;t hold any slice-related generic logic.
 *
 * @constructor
 * @class
 *
 * @param {VJS.slice.core} sliceCore - Core slice instance.
 *
 */
VJS.slice.view = function(sliceCore) {
    this._sliceCore = sliceCore;
};

/**
 * Get a threeJS object that represents a slice.
 * It is fully configured and just have to be added to the renderer.
 * !!!! Make sure to call slice.core.slice() before. (should be hidden)
 * Object is displayed in RAS space. This should be an option somewhere...
 *
 * @return THREE.Object
 *
 */
VJS.slice.view.prototype.RASSlice = function() {
    //
    // create material from target Volume
    // setup uniforms
    var shaderSlice = VJS.slice.shader;
    var uniforms = shaderSlice.slice.uniforms;
    uniforms.uTextureSize.value = this._sliceCore._volumeCore._textureSize;
    var textures = this._sliceCore._volumeCore._textures;
    // 4 textures...
    uniforms.t00.value = textures[0];
    uniforms.t01.value = textures[1];
    uniforms.t02.value = textures[2];
    uniforms.t03.value = textures[3];
    uniforms.uIJKDims.value = this._sliceCore._volumeCore._ijk.dimensions;
    uniforms.uRASToIJK.value = this._sliceCore._volumeCore._transforms.ras2ijk;

    var mat = new THREE.ShaderMaterial({
        // &#x27;wireframe&#x27;: true,
        &#x27;side&#x27;: THREE.DoubleSide,
        &#x27;transparency&#x27;: true,
        &#x27;uniforms&#x27;: uniforms,
        &#x27;vertexShader&#x27;: shaderSlice.slice.vertexShader,
        &#x27;fragmentShader&#x27;: shaderSlice.slice.fragmentShader,
    });

    // create geometry
    var vGeometry = this.sliceGeometry();
    // ... and mesh
    var plane = new THREE.Mesh(vGeometry, mat);

    // should it be separate...?
    // create the border!
    var material = new THREE.LineBasicMaterial({
        color: 0x0000ff,
polygonOffset: true,
polygonOffsetFactor: -0.1
    });
    var geometry = new THREE.Geometry();
    for (var i = 0; i &amp;lt; this._sliceCore._intersections.length; i++) {
        geometry.vertices.push(this._sliceCore._intersections[i]);
    }
    geometry.vertices.push(this._sliceCore._intersections);
    var line = new THREE.Line(geometry, material);


    var group = new THREE.Object3D();
    group.add(plane);
    group.add(line);

    return group;
};

VJS.slice.view.prototype.updateRASSlice = function(plane) {
    // Should get all information from there or from the Core...!
    plane.geometry = this.sliceGeometry();
};

VJS.slice.view.prototype.sliceGeometry = function() {

    var sliceGeom = null;

    var sliceShape = new THREE.Shape();
    // move to first point!
    sliceShape.moveTo(this._sliceCore._intersectionsXY[0].x, this._sliceCore._intersectionsXY[0].y);


    // loop through all points!
    for (var i = 1; i &amp;lt; this._sliceCore._intersectionsXY.length; i++) {
        // project each on plane!
        sliceShape.lineTo(this._sliceCore._intersectionsXY[i].x, this._sliceCore._intersectionsXY[i].y);
    }

    // close the shape!
    sliceShape.lineTo(this._sliceCore._intersectionsXY[0].x, this._sliceCore._intersectionsXY[0].y);

    // Generate Geomotry. (all we care about is triangulation!)
    sliceGeom = new THREE.ShapeGeometry(sliceShape);

    // update real position of each vertex!
    sliceGeom.vertices = this._sliceCore._intersections;
    sliceGeom.verticesNeedUpdate = true;

    return sliceGeom;
};

// COM
// CORNERS
// BORDER?
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on June 18, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>