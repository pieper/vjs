<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.2">
  <meta charset="utf-8">
  <title>Source: models/models.stack.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: models/models.stack.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};
VJS.models = VJS.models || {};

/**
 * Define the stack object here
 *
 * @constructor
 * @class
 * @memberOf VJS.models
 * @public
 */
VJS.models.stack = function() {
  /**
   * @member
   * @type {string}
   */
  this._id = &#x27;-1&#x27;;
  /**
   * @member
   * @type {string}
   */
  this._uid = null; // first stack ID -&gt; (0020, 9056)
  /**
   * @member
   * @type {number}
   */
  this._stackID = -1;
  /**
   * @member
   * @type {Array.&amp;lt;VJS.frame.model&gt;}
   */
  this._frame = [];
  /**
   * @member
   * @type {number}
   */
  this._rows = 0;
  /**
   * @member
   * @type {number}
   */
  this._columns = 0;
  /**
   * @member
   * @type {number}
   */
  this._numberOfFrames = 0;
  /**
   * @member
   * @type {Object}
   * @property {number} row
   * @property {number} column
   */
  this._pixelSpacing = {
    &#x27;row&#x27;: 0,
    &#x27;column&#x27;: 0
  };
  this._spacingBetweenSlices = 0;
  /**
   * @member
   * @type {number}
   */
  this._sliceThickness = 0;

  // origin of the first slice of the stack!
  this._origin = null;
  this._halfDimensions = null;
  this._orientation = null;

  this._textureSize = 4096;
  this._nbTextures = 7; // HIGH RES..
  this._rawData = [];
  // this._windowCenter = 0;
  // this._windowWidth = 0;
  this._windowLevel = [0, 0];
  this._windowCenter = 0;
  this._windowWidth = 0;
  this._minMax = [65535, -32768];
  this._invert = 0;

  this._ijk2LPS = null;
  this._lps2IJK = null;

  // Slicer values
  this._dimensions = null;
  this._spacing = null;
  this._origin = null;
  this._direction = null;
};

/**
 * here me make sure eveything is ready for visualization.
 * might also have a switch to say what we can view and what we can not view with current stack
 *
 * @public
 */
VJS.models.stack.prototype.prepare = function() {

  // dimensions of the stack
  this._numberOfFrames = this._frame.length;

  window.console.log(this);
  this.orderFrames();
  var zSpacing = this.zSpacing();

  // prepare the frame
  if (this._frame[0]._pixelSpacing) {
    this._pixelSpacing.row = this._frame[0]._pixelSpacing[0];
    this._pixelSpacing.column = this._frame[0]._pixelSpacing[1];
  } else if (this._frame[0]._pixelAspectRatio) {
    this._pixelSpacing.row = 1.0;
    this._pixelSpacing.column = 1.0 * this._frame[0]._pixelAspectRatio[1] / this._frame[0]._pixelAspectRatio[0];
  } else {
    this._pixelSpacing.row = 1.0;
    this._pixelSpacing.column = 1.0;
  }

  if (!this._frame[0]._imagePosition) {
    this._frame[0]._imagePosition = [0, 0, 0];
  }

  if (!this._frame[0]._imageOrientation) {
    this._frame[0]._imageOrientation = [1, 0, 0, 0, 1, 0];
  }

  this._rows = this._frame[0]._rows;
  this._columns = this._frame[0]._columns;
  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);

  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;
  this._sliceThickness = this._frame[0]._sliceThickness;

  for (var i = 0; i &amp;lt; this._frame.length; i++) {

    // check rows consistency
    if (this._rows !== this._frame[i]._rows) {
      // send an error message...
      window.console.log(&#x27;Numbers of rows in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._rows, &#x27; rows&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._rows, &#x27; rows.&#x27;);
    }

    // check columns consitency
    if (this._columns !== this._frame[i]._columns) {
      // send an error message...
      window.console.log(&#x27;Numbers of columns in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._columns, &#x27; columns.&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this.frame[i]._columns, &#x27; columns.&#x27;);
    }

    // // check for spacing consistency
    // if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing[0] || this._pixelSpacing.column !== this._frame[i]._pixelSpacing[1]) {
    //   // send an error message...
    //   window.console.log(&#x27;Spacing in stack\&#x27;s frames is not consistent.&#x27;);
    //   window.console.log(this);
    //   window.console.log(&#x27;First frame had : &#x27;, this._pixelSpacing.row, &#x27; x &#x27;, this._pixelSpacing.column, &#x27; spacing.&#x27;);
    //   window.console.log(&#x27;Frame index : &#x27;, i, &#x27; has: &#x27;, this._frame[i]._pixelSpacing[0], &#x27; x &#x27;, this._frame[i]._pixelSpacing[1], &#x27; spacing.&#x27;);
    // }

    // // check slice spacing consitency
    // if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {
    //   // send an error message...
    //   window.console.log(&#x27;Spacing betwen slices in stack\&#x27;s frames is not consistent.&#x27;);
    //   window.console.log(this);
    //   window.console.log(&#x27;First frame had: &#x27;, this._spacingBetweenSlices, &#x27; spacing betwen slices.&#x27;);
    //   window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this.frame[i]._spacingBetweenSlices, &#x27; spacing betwen slices.&#x27;);
    // }

    // // check for slice thickness consistency
    // if (this._sliceThickness !== this._frame[i]._sliceThickness) {
    //   window.console.log(&#x27;Slice thickness in stack\&#x27;s frames is not consistent.&#x27;);
    //   window.console.log(this);
    //   window.console.log(&#x27;First frame had: &#x27;, this._sliceThickness, &#x27; sliceThickness.&#x27;);
    //   window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._sliceThickness, &#x27; sliceThickness.&#x27;);
    // }

    // get min/max
    this._minMax[0] = Math.min(this._minMax[0], this._frame[i]._minMax[0]);
    this._minMax[1] = Math.max(this._minMax[1], this._frame[i]._minMax[1]);
  }

  // Origin
  this._origin = new THREE.Vector3(
      this._frame[0]._imagePosition[0],
      this._frame[0]._imagePosition[1],
      this._frame[0]._imagePosition[2]
      );

  // Direction
  window.console.log(&#x27;first frame value!&#x27;);
  window.console.log(this._frame[0]._imageOrientation[0]);
  var xCosine = new THREE.Vector3(
      this._frame[0]._imageOrientation[0],
      this._frame[0]._imageOrientation[1],
      this._frame[0]._imageOrientation[2]
  );
  window.console.log(xCosine);

  var yCosine = new THREE.Vector3(
      this._frame[0]._imageOrientation[3],
      this._frame[0]._imageOrientation[4],
      this._frame[0]._imageOrientation[5]
  );
  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();
  this._direction = new THREE.Matrix4();
  this._direction.set(
      xCosine.x, yCosine.x, zCosine.x, 0,
      xCosine.y, yCosine.y, zCosine.y, 0,
      xCosine.z, yCosine.z, zCosine.z, 0,
      0, 0, 0, 1);

  window.console.log(this._direction);

  this._spacing = new THREE.Vector3(
      this._pixelSpacing.row,
      this._pixelSpacing.column,
      zSpacing);

  window.console.log(this._spacing);

  // half dimensions are useful for faster computations of intersection.
  this._halfDimensions = new THREE.Vector3(
      this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);

  // orientation needed to compute stack BBox interection against slice.
  // always same, might want to remove it.
  var baseX = new THREE.Vector3(1, 0, 0);
  var baseY = new THREE.Vector3(0, 1, 0);
  var baseZ = new THREE.Vector3(0, 0, 1);
  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);

  // IJK to LPS transform.
  // and inverse.
  this._ijk2LPS = new THREE.Matrix4();
  this._ijk2LPS.set(
      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,
      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,
      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,
      0, 0, 0, 1);

  this._lps2IJK = new THREE.Matrix4();
  this._lps2IJK.getInverse(this._ijk2LPS);

  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);

  // only works with 1 channel for now...
  var nbVoxels = this._dimensions.x * this._dimensions.y * this._dimensions.z;
  window.console.log(this._dimensions);

  // create 16 rgba textures
  for (var ii = 0; ii &amp;lt; this._nbTextures; ii++) {
    // *3 because always create RGB
    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * 4));
  }

  // http://stackoverflow.com/questions/6413744/looking-to-access-16-bit-image-data-in-javascript-webgl

  // Can not just use subarray because we have to normalize the values (Uint* 0&amp;lt;x&amp;lt;255)
  //var prevFrame = -1;
  //var prevTexture = -1;

  // ADD WARNING IF DATA TO BIG TO FIT IN MEMORY...!

  var frameDimension = this._dimensions.x * this._dimensions.y;
  var textureDimension = this._textureSize * this._textureSize;

  console.time(&#x27;arrangeDataForWebgl&#x27;);

  for (var jj = 0; jj &amp;lt; nbVoxels; jj++) {

    var frameIndex = Math.floor(jj / frameDimension);
    var inFrameIndex = jj % (frameDimension);

    var textureIndex = Math.floor(jj / textureDimension);
    var inTextureIndex = jj % (textureDimension);
    if (this._numberOfChannels === 3) {

      this._rawData[textureIndex][4 * inTextureIndex] = this._frame[frameIndex]._pixelData[4 * inFrameIndex];
      this._rawData[textureIndex][4 * inTextureIndex + 1] = this._frame[frameIndex]._pixelData[4 * inFrameIndex + 1];
      this._rawData[textureIndex][4 * inTextureIndex + 2] = this._frame[frameIndex]._pixelData[4 * inFrameIndex + 2];
      this._rawData[textureIndex][4 * inTextureIndex + 3] = this._frame[frameIndex]._pixelData[4 * inFrameIndex + 3];

    } else {
      //

      var rawValue = this._frame[frameIndex]._pixelData[inFrameIndex];

      // get most significant (msb) and less significant (lsb) bytes
      // deal with sign?
      // deal with number of channels
      // deal with image type (single/multi channel)
      // &gt;&gt; or &gt;&gt;&gt; ?
      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift

      /*jshint bitwise: false*/
      var lsb = rawValue &amp;amp; 0xFF;
      var msb = (rawValue &gt;&gt; 8) &amp;amp; 0xFF;

      // add 
      this._rawData[textureIndex][4 * inTextureIndex] = msb;
      this._rawData[textureIndex][4 * inTextureIndex + 1] = lsb;

      // can we add next msb/lsb to b/a - yes!
      // or just forbid it?

      this._rawData[textureIndex][4 * inTextureIndex + 2] = frameIndex;
      this._rawData[textureIndex][4 * inTextureIndex + 3] = frameIndex;

    }

  }

  // default window level based on min/max for now...
  var width = this._minMax[1] - this._minMax[0];
  var center = this._minMax[0] + width / 2;

  this._windowWidth = width;
  this._windowCenter = center;
  this._windowLevel = [center, width];

  // need to pass min/max
  this._bitsAllocated = this._frame[0]._bitsAllocated;

  window.console.log(&#x27;window level: &#x27;, this._windowLevel);
};

/**
 * Order frames based on theirs dimensionIndexValues
 */
VJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {

  if (&#x27;_dimensionIndexValues&#x27; in a &amp;amp;&amp;amp; Object.prototype.toString.call(a._dimensionIndexValues) === &#x27;[object Array]&#x27; &amp;amp;&amp;amp; &#x27;_dimensionIndexValues&#x27; in b &amp;amp;&amp;amp; Object.prototype.toString.call(b._dimensionIndexValues) === &#x27;[object Array]&#x27;) {
    for (var i = 0; i &amp;lt; a._dimensionIndexValues.length; i++) {
      if (parseInt(a._dimensionIndexValues[i]) &gt; parseInt(b._dimensionIndexValues[i])) {
        //window.console.log(a._dimensionIndexValues[i] + &#x27; &gt; &#x27; + b._dimensionIndexValues[i]);
        //window.console.log(typeof a._dimensionIndexValues[i] + &#x27; &gt; &#x27; + typeof b._dimensionIndexValues[i]);
        return 1;
      }
      if (parseInt(a._dimensionIndexValues[i]) &amp;lt; parseInt(b._dimensionIndexValues[i])) {
        //window.console.log(a._dimensionIndexValues[i] + &#x27; &amp;lt; &#x27; + b._dimensionIndexValues[i]);
        //window.console.log(typeof a._dimensionIndexValues[i] + &#x27; &amp;lt; &#x27; + typeof b._dimensionIndexValues[i]);
        return -1;
      }
    }
  } else {
    window.console.log(&#x27;One of the frames doesn\&#x27;t have a _dimensionIndexValues array.&#x27;);
    window.console.log(a);
    window.console.log(b);
  }

  return 0;
};

VJS.models.stack.prototype.orderFrames = function() {
  // order the frames based on theirs dimension indices
  // first index is the most important.
  // 1,1,1,1 willl be first
  // 1,1,2,1 will be next
  // 1,1,2,3 will be next
  // 1,1,3,1 wil be next
  window.console.log(this);
  if (this._frame[0]._dimensionIndexValues) {
    this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);
  } else if (this._frame[0]._imagePosition &amp;amp;&amp;amp; this._frame[0]._imageOrientation) {
    // ORDERING BASED ON IMAGE POSITION
    var xCosine = new THREE.Vector3(
      this._frame[0]._imageOrientation[0],
      this._frame[0]._imageOrientation[1],
      this._frame[0]._imageOrientation[2]
      );

    var yCosine = new THREE.Vector3(
      this._frame[0]._imageOrientation[3],
      this._frame[0]._imageOrientation[4],
      this._frame[0]._imageOrientation[5]
    );

    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();

    // compute and sort by dist in this series
    this._frame.map(this._computeDistance.bind(null, zCosine));
    this._frame.sort(this._sortDistance);

  } else {
    // else slice location
    // image number
    // ORDERING BASED ON instance number
    // _ordering = &#x27;instance_number&#x27;;
    // first_image.sort(function(a,b){return a[&quot;instance_number&quot;]-b[&quot;instance_number&quot;]});
  }
};

VJS.models.stack.prototype._computeDistance = function(normal, frame) {
  frame._dist = frame._imagePosition[0] * normal.x +
  frame._imagePosition[1] * normal.y +
  frame._imagePosition[2] * normal.z;
  return frame;
};

VJS.models.stack.prototype._sortDistance = function(a, b) {return a._dist - b._dist;};

VJS.models.stack.prototype.zSpacing = function() {
  // Spacing
  // can not be 0 if not matrix can not be inverted.
  var zSpacing = 1;
  window.console.log(this._frame[0]);

  if (this._numberOfFrames &gt; 1) {
    if (this._spacingBetweenSlices) {
      zSpacing = this._spacingBetweenSlices;
    } else if (this._frame[0]._sliceThickness) {
      zSpacing = this._frame[0]._sliceThickness;
    } else {
      var xCosine = new THREE.Vector3(
        this._frame[0]._imageOrientation[0],
        this._frame[0]._imageOrientation[1],
        this._frame[0]._imageOrientation[2]
      );

      var yCosine = new THREE.Vector3(
        this._frame[0]._imageOrientation[3],
        this._frame[0]._imageOrientation[4],
        this._frame[0]._imageOrientation[5]
      );

      var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();

      // compute and sort by dist in this series
      this._frame.map(this._computeDistance.bind(null, zCosine));
      this._frame.sort(this._sortDistance);

      zSpacing = this._frame[1]._dist - this._frame[0]._dist;
    }
  }

  if (zSpacing === 0) {
    zSpacing = 1;
  }

  return zSpacing;
};

VJS.models.stack.prototype.merge = function(stack) {
  // try to merge imageHelper with current image.
  // same image if same Series UID?
  // could use concatenation if available, to already know if image is complete!
  var sameStackID = false;
  if (this._stackID === stack._stackID) {
    sameStackID = true;

    // Make sure image information is consisent?
    // re-compute it?
    var frame = stack._frame;
    // Merge Stacks (N against N)
    // try to match all stack to current stacks, if not add it to stacks list!
    for (var i = 0; i &amp;lt; frame.length; i++) {
      // test stack against existing stack
      for (var j = 0; j &amp;lt; this._frame.length; j++) {
        // test dimension
        // dimension index value not defined!
        if (
          
          // dimension index is unique
          (this._frame[j]._dimensionIndexValues &amp;amp;&amp;amp;
            frame[i]._dimensionIndexValues &amp;amp;&amp;amp;
            this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) ||
          
          // instance number is unique?
          (this._frame[j]._instanceNumber &amp;amp;&amp;amp;
            frame[i]._instanceNumber &amp;amp;&amp;amp;
            this._frame[j]._instanceNumber === frame[i]._instanceNumber) ||
          
          // imagePosition + imageOrientation is unique
          (this._frame[j]._imagePosition &amp;amp;&amp;amp;
            frame[i]._imagePosition &amp;amp;&amp;amp;
            this._frame[j]._imagePosition.join() === frame[i]._imagePosition.join() &amp;amp;&amp;amp;
            this._frame[j]._imageOrientation &amp;amp;&amp;amp;
            frame[i]._imageOrientation &amp;amp;&amp;amp;
            this._frame[j]._imageOrientation.join() === frame[i]._imageOrientation.join() &amp;amp;&amp;amp;
            // FOR DIFFUSION.. same position but different instance numbers...
            this._frame[j]._instanceNumber &amp;amp;&amp;amp;
            frame[i]._instanceNumber &amp;amp;&amp;amp;
            this._frame[j]._instanceNumber === frame[i]._instanceNumber) //||

          // _pixelData length is unique...? imageSOP?
          // (this._frame[j]._pixelData &amp;amp;&amp;amp;
          //   frame[i]._pixelData &amp;amp;&amp;amp;
          //   this._frame[j]._pixelData.length === frame[i]._pixelData.length)

          ) {

          window.console.log(&#x27;BREAKING!&#x27;);
          window.console.log(frame[i], this._frame[j]);
          break;
         
        } else if (j === this._frame.length - 1) {

          window.console.log(&#x27;PUSHING FRAME TO STACK!&#x27;);
          this._frame.push(frame[i]);
          break;

        }

      }

    }
  }

  window.console.log(this);

  return sameStackID;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== &#x27;undefined&#x27;) &amp;amp;&amp;amp; module.exports) {
    module.exports = VJS.models.stack;
}
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.2 on July 23, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>