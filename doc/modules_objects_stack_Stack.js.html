<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: modules/objects/stack/Stack.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: modules/objects/stack/Stack.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};

/**
 * stack namespace
 * @namespace stack
 * @memberOf VJS
 */
VJS.stack = VJS.stack || {};

/**
 * Define the model of a stack here
 *
 * @constructor
 * @class
 * @memberOf VJS.stack
 * @public
 */
VJS.stack.model = function() {
    /**
     * @member
     * @type {string}
     */
    this._id = &#x27;-1&#x27;;
    /**
     * @member
     * @type {string}
     */
    this._uid = null; // first stack ID -&gt; (0020, 9056)
    /**
     * @member
     * @type {number}
     */
    this._stackID = -1;
    /**
     * @member
     * @type {Array.&amp;lt;VJS.frame.model&gt;}
     */
    this._frame = [];
    /**
     * @member
     * @type {number}
     */
    this._rows = 0;
    /**
     * @member
     * @type {number}
     */
    this._columns = 0;
    /**
     * @member
     * @type {number}
     */
    this._nbFrames = 0;
    /**
     * @member
     * @type {Object}
     * @property {number} row
     * @property {number} column
     */
    this._pixelSpacing = {
        &#x27;row&#x27;: 0,
        &#x27;column&#x27;: 0
    };
    /**
     * @member
     * @type {number}
     */
    this._sliceThickness = 0;


    // origin of the first slice of the stack!
    this._origin = null;
    this._halfDimensions = null;
    this._orientation = null;

    this._textureSize = 2048;
    this._nbTextures = 16; // HIGH RES..
    this._rawData = [];

    this._ijk2LPS = null;
    this._lps2IJK = null;
};

/**
 * here me make sure eveything is ready for visualization.
 * might also have a switch to say what we can view and what we can not view with current stack
 *
 * @public
 */
VJS.stack.model.prototype.prepare = function() {
    // order the frames based on theirs dimension indices
    // first index is the most important.
    // 1,1,1,1 willl be first
    // 1,1,2,1 will be next
    // 1,1,2,3 will be next
    // 1,1,3,1 wil be next
    window.console.log(this);
    this._frame.sort(VJS.stack.model.prototype.orderFrameOnDimensionIndices);
    // get height of the stack (i.e. number of frames)
    this._nbFrames = this._frame.length;
    // can we calculate that? might have to parse all frames to make sure it is consistent...
    this._rows = this._frame[0]._rows;
    this._columns = this._frame[0]._columns;
    this._pixelSpacing.row = this._frame[0]._pixelSpacing.row;
    this._pixelSpacing.column = this._frame[0]._pixelSpacing.column;
    this._sliceThickness = this._frame[0]._sliceThickness;

    for (var i = 0; i &amp;lt; this._frame.length; i++) {

        // check rows consistency
        if (this._rows !== this._frame[i]._rows) {
            // send an error message...
            window.console.log(&#x27;Numbers of rows in stack\&#x27;s frames is not consistent.&#x27;);
            window.console.log(this);
            window.console.log(&#x27;First frame had: &#x27;, this._rows, &#x27; rows&#x27;);
            window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._rows, &#x27; rows.&#x27;);
        }

        // check columns consitency
        if (this._columns !== this._frame[i]._columns) {
            // send an error message...
            window.console.log(&#x27;Numbers of columns in stack\&#x27;s frames is not consistent.&#x27;);
            window.console.log(this);
            window.console.log(&#x27;First frame had: &#x27;, this._columns, &#x27; columns.&#x27;);
            window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this.frame[i]._columns, &#x27; columns.&#x27;);
        }

        // check for spacing consistency
        if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing.row || this._pixelSpacing.column !== this._frame[i]._pixelSpacing.column) {
            // send an error message...
            window.console.log(&#x27;Spacing in stack\&#x27;s frames is not consistent.&#x27;);
            window.console.log(this);
            window.console.log(&#x27;First frame had : &#x27;, this._pixelSpacing.row, &#x27; x &#x27;, this._pixelSpacing.column, &#x27; spacing.&#x27;);
            window.console.log(&#x27;Frame index : &#x27;, i, &#x27; has: &#x27;, this._frame[i]._pixelSpacing.row, &#x27; x &#x27;, this._frame[i]._pixelSpacing.column, &#x27; spacing.&#x27;);
        }

        // check for slice thickness consistency
        if (this._sliceThickness !== this._frame[i]._sliceThickness) {
            window.console.log(&#x27;Slice thickness in stack\&#x27;s frames is not consistent.&#x27;);
            window.console.log(this);
            window.console.log(&#x27;First frame had: &#x27;, this._sliceThickness, &#x27; sliceThickness.&#x27;);
            window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._sliceThickness, &#x27; sliceThickness.&#x27;);
        }
    }

    // half dimensions are useful for faster computations of intersection.
    this._halfDimensions = new THREE.Vector3(this._rows / 2, this._columns / 2, this._nbFrames / 2);

    // orientation needed to compute stack BBox interection against slice.
    var baseX = new THREE.Vector3(1, 0, 0);
    var baseY = new THREE.Vector3(0, 1, 0);
    var baseZ = new THREE.Vector3(0, 0, 1);
    this._orientation = new THREE.Vector3(baseX, baseY, baseZ);

    // IJK to LPS transform.
    // and inverse.
    this._origin = this._frame[0]._imagePositionPatient;

    var xCosine = new THREE.Vector3(
        this._frame[0]._imageOrientationPatient.row.x,
        this._frame[0]._imageOrientationPatient.row.y,
        this._frame[0]._imageOrientationPatient.row.z
    );
    var yCosine = new THREE.Vector3(
        this._frame[0]._imageOrientationPatient.column.x,
        this._frame[0]._imageOrientationPatient.column.y,
        this._frame[0]._imageOrientationPatient.column.z
    );
    var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();

    this._ijk2LPS = new THREE.Matrix4();
    this._ijk2LPS.set(
        xCosine.x * this._pixelSpacing.row, yCosine.x * this._pixelSpacing.column, zCosine.x * this._sliceThickness, this._origin.x,
        xCosine.y * this._pixelSpacing.row, yCosine.y * this._pixelSpacing.column, zCosine.y * this._sliceThickness, this._origin.y,
        xCosine.z * this._pixelSpacing.row, yCosine.z * this._pixelSpacing.column, zCosine.z * this._sliceThickness, this._origin.z,
        0, 0, 0, 1);


    this._lps2IJK = new THREE.Matrix4();
    this._lps2IJK.getInverse(this._ijk2LPS);

    window.console.log(this._lps2IJK, this._ijk2LPS);

    // only works with 1 channel for now...
    var requiredPixels = this._rows * this._columns * this._nbFrames;

    var nbChannels = 1;
    for (var ii = 0; ii &amp;lt; this._nbTextures; ii++) {
        this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * nbChannels));
    }

    // Can not just use subarray because we have to normalize the values (Uint* 0&amp;lt;x&amp;lt;255)
    for (var jj = 0; jj &amp;lt; requiredPixels; jj++) {

        var frameIndex = Math.floor(jj / (this._rows * this._columns));
        var inFrameIndex = jj % (this._rows * this._columns);
        var textureIndex = Math.floor(jj / (this._textureSize * this._textureSize));
        var inTextureIndex = jj % (this._textureSize * this._textureSize);

        // window.console.log(textureIndex, inTextureIndex);
        // different ways to itereate if 1 or N channels!!
        // just 1 for now!
        // NORMAALIZE IN THE SHADERS!
        // could track min/max here...?

        this._rawData[textureIndex][inTextureIndex] = this._frame[frameIndex]._pixelData[inFrameIndex]; //Math.floor( Math.random() * 255 );

        // // normalize value
        // var normalizedValue = 255 * ((this._data[j] - this._min) / (this._max - this._min));

        // // RGB
        // rawData[textureIndex][4 * inTextureIndex] = normalizedValue;

        // if (inTextureIndex &gt;= requiredPixels) {
        //     break;
        // }
    }

    // LPS to World.
    // and inverse.

    // all IJK coords + transform for origin and normal to be in same space!

    //     var obb = {
    //     &#x27;halfDimensions&#x27;: this._volumeCore._halfDimensions,
    //     &#x27;orientation&#x27;: this._volumeCore._orientation,
    //     &#x27;center&#x27;: this._volumeCore._halfDimensions, //this._volumeCore._RAS.center,
    //     &#x27;toOBBSpace&#x27;: this._volumeCore._transforms.ras2ijk,
    //     &#x27;toOBBSpaceInvert&#x27;: this._volumeCore._transforms.ijk2ras,
    // };

    // var plane = {
    //     &#x27;origin&#x27;: this._origin,
    //     &#x27;normal&#x27;: this._normal
    // };

    // SWITCH TO DECIDE WHAT WE CAN VIEW OR NOT FROM HERE!
};

/**
 * Order frames based on theirs dimensionIndexValues
 */
VJS.stack.model.prototype.orderFrameOnDimensionIndices = function(a, b) {

    if (&#x27;_dimensionIndexValues&#x27; in a &amp;amp;&amp;amp; Object.prototype.toString.call(a._dimensionIndexValues) === &#x27;[object Array]&#x27; &amp;amp;&amp;amp; &#x27;_dimensionIndexValues&#x27; in b &amp;amp;&amp;amp; Object.prototype.toString.call(b._dimensionIndexValues) === &#x27;[object Array]&#x27;) {
        for (var i = 0; i &amp;lt; a._dimensionIndexValues.length; i++) {
            if (a._dimensionIndexValues[i] &gt; b._dimensionIndexValues[i]) {
                return false;
            }
        }
    } else {
        window.console.log(&#x27;One of the frames doesn\&#x27;t have a _dimensionIndexValues array.&#x27;);
        window.console.log(a);
        window.console.log(b);

        // return what?
        return true;
    }
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on May 14, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>