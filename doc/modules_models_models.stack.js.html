<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: modules/models/models.stack.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: modules/models/models.stack.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};
VJS.models = VJS.models || {};

/**
 * Define the stack object here
 *
 * @constructor
 * @class
 * @memberOf VJS.models
 * @public
 */
VJS.models.stack = function() {
  /**
   * @member
   * @type {string}
   */
  this._id = &#x27;-1&#x27;;
  /**
   * @member
   * @type {string}
   */
  this._uid = null; // first stack ID -&gt; (0020, 9056)
  /**
   * @member
   * @type {number}
   */
  this._stackID = -1;
  /**
   * @member
   * @type {Array.&amp;lt;VJS.frame.model&gt;}
   */
  this._frame = [];
  /**
   * @member
   * @type {number}
   */
  this._rows = 0;
  /**
   * @member
   * @type {number}
   */
  this._columns = 0;
  /**
   * @member
   * @type {number}
   */
  this._nbFrames = 0;
  /**
   * @member
   * @type {Object}
   * @property {number} row
   * @property {number} column
   */
  this._pixelSpacing = {
    &#x27;row&#x27;: 0,
    &#x27;column&#x27;: 0
  };
  this._spacingBetweenSlices = 0;
  /**
   * @member
   * @type {number}
   */
  this._sliceThickness = 0;

  // origin of the first slice of the stack!
  this._origin = null;
  this._halfDimensions = null;
  this._orientation = null;

  this._textureSize = 2048;
  this._nbTextures = 16; // HIGH RES..
  this._rawData = [];

  this._ijk2LPS = null;
  this._lps2IJK = null;

  // Slicer values
  this._dimensions = null;
  this._spacing = null;
  this._origin = null;
  this._direction = null;
};

/**
 * here me make sure eveything is ready for visualization.
 * might also have a switch to say what we can view and what we can not view with current stack
 *
 * @public
 */
VJS.models.stack.prototype.prepare = function() {
  // order the frames based on theirs dimension indices
  // first index is the most important.
  // 1,1,1,1 willl be first
  // 1,1,2,1 will be next
  // 1,1,2,3 will be next
  // 1,1,3,1 wil be next
  this._frame.sort(VJS.models.stack.prototype.orderFrameOnDimensionIndices);
  // if no dimension, order by instaceNumber
  // if no instance nuber, order by position?

  // dimensions of the stack
  this._nbFrames = this._frame.length;
  this._rows = this._frame[0]._rows;
  this._columns = this._frame[0]._columns;
  this._dimensions = new THREE.Vector3(this._columns, this._rows, this._nbFrames);

  // extra
  this._pixelSpacing.row = this._frame[0]._pixelSpacing.row;
  this._pixelSpacing.column = this._frame[0]._pixelSpacing.column;
  this._spacingBetweenSlices = this._frame[0]._spacingBetweenSlices;
  this._sliceThickness = this._frame[0]._sliceThickness;

  for (var i = 0; i &amp;lt; this._frame.length; i++) {

    // check rows consistency
    if (this._rows !== this._frame[i]._rows) {
      // send an error message...
      window.console.log(&#x27;Numbers of rows in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._rows, &#x27; rows&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._rows, &#x27; rows.&#x27;);
    }

    // check columns consitency
    if (this._columns !== this._frame[i]._columns) {
      // send an error message...
      window.console.log(&#x27;Numbers of columns in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._columns, &#x27; columns.&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this.frame[i]._columns, &#x27; columns.&#x27;);
    }

    // check for spacing consistency
    if (this._pixelSpacing.row !== this._frame[i]._pixelSpacing.row || this._pixelSpacing.column !== this._frame[i]._pixelSpacing.column) {
      // send an error message...
      window.console.log(&#x27;Spacing in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had : &#x27;, this._pixelSpacing.row, &#x27; x &#x27;, this._pixelSpacing.column, &#x27; spacing.&#x27;);
      window.console.log(&#x27;Frame index : &#x27;, i, &#x27; has: &#x27;, this._frame[i]._pixelSpacing.row, &#x27; x &#x27;, this._frame[i]._pixelSpacing.column, &#x27; spacing.&#x27;);
    }

    // check slice spacing consitency
    if (this._spacingBetweenSlices !== this._frame[i]._spacingBetweenSlices) {
      // send an error message...
      window.console.log(&#x27;Spacing betwen slices in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._spacingBetweenSlices, &#x27; spacing betwen slices.&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this.frame[i]._spacingBetweenSlices, &#x27; spacing betwen slices.&#x27;);
    }

    // check for slice thickness consistency
    if (this._sliceThickness !== this._frame[i]._sliceThickness) {
      window.console.log(&#x27;Slice thickness in stack\&#x27;s frames is not consistent.&#x27;);
      window.console.log(this);
      window.console.log(&#x27;First frame had: &#x27;, this._sliceThickness, &#x27; sliceThickness.&#x27;);
      window.console.log(&#x27;Frame index: &#x27;, i, &#x27; has: &#x27;, this._frame[i]._sliceThickness, &#x27; sliceThickness.&#x27;);
    }
  }

  // Origin
  this._origin = this._frame[0]._imagePositionPatient;

  // Direction
    window.console.log(&#x27;first frame value!&#x27;);
  window.console.log(this._frame[0]._imageOrientationPatient.row.x);
  var xCosine = new THREE.Vector3(
      this._frame[0]._imageOrientationPatient.row.x,
      this._frame[0]._imageOrientationPatient.row.y,
      this._frame[0]._imageOrientationPatient.row.z
  );
  window.console.log(xCosine);

  var yCosine = new THREE.Vector3(
      this._frame[0]._imageOrientationPatient.column.x,
      this._frame[0]._imageOrientationPatient.column.y,
      this._frame[0]._imageOrientationPatient.column.z
  );
  var zCosine = new THREE.Vector3(0, 0, 0).crossVectors(xCosine, yCosine).normalize();
  this._direction = new THREE.Matrix4();
  this._direction.set(
      xCosine.x, yCosine.x, zCosine.x, 0,
      xCosine.y, yCosine.y, zCosine.y, 0,
      xCosine.z, yCosine.z, zCosine.z, 0,
      0, 0, 0, 1);

  window.console.log(this._direction);

  // Spacing
  // can not be 0 if not matrix can not be inverted.
  var zSpacing = 1;
  if (this._nbFrames &gt; 1) {
    if (this._spacingBetweenSlices) {
      zSpacing = this._spacingBetweenSlices;
    } else {
      // we got to compute it...!
      window.console.log(&#x27;NEED TO COMPUTE SPACING BETWEEN THE FRAMES!&#x27;);
      // It is always better to compute the distance between a pair of
      // slices along a normal to the plane of the image specified by
      // the Image Orientation (Patient) attribute, by projecting the
      // top left hand corner position specified by the Image Position
      // (Patient) attribute onto that normal. These attributes are
      // always sent and much more often &quot;right&quot; than is (0018,0088).
    }
  }

  this._spacing = new THREE.Vector3(
      this._pixelSpacing.row,
      this._pixelSpacing.column,
      zSpacing);

  // half dimensions are useful for faster computations of intersection.
  this._halfDimensions = new THREE.Vector3(
    this._dimensions.x / 2, this._dimensions.y / 2, this._dimensions.z / 2);

  // orientation needed to compute stack BBox interection against slice.
  // always same, might want to remove it.
  var baseX = new THREE.Vector3(1, 0, 0);
  var baseY = new THREE.Vector3(0, 1, 0);
  var baseZ = new THREE.Vector3(0, 0, 1);
  this._orientation = new THREE.Vector3(baseX, baseY, baseZ);

  // IJK to LPS transform.
  // and inverse.
  this._ijk2LPS = new THREE.Matrix4();
  this._ijk2LPS.set(
      xCosine.x * this._spacing.x, yCosine.x * this._spacing.y, zCosine.x * this._spacing.z, this._origin.x,
      xCosine.y * this._spacing.x, yCosine.y * this._spacing.y, zCosine.y * this._spacing.z, this._origin.y,
      xCosine.z * this._spacing.x, yCosine.z * this._spacing.y, zCosine.z * this._spacing.z, this._origin.z,
      0, 0, 0, 1);

  this._lps2IJK = new THREE.Matrix4();
  this._lps2IJK.getInverse(this._ijk2LPS);

  window.console.log(this._lps2IJK, this._ijk2LPS, this._direction);

  // only works with 1 channel for now...
  var requiredPixels = this._dimensions.x * this._dimensions.y * this._dimensions.z;

  var nbChannels = 1;
  for (var ii = 0; ii &amp;lt; this._nbTextures; ii++) {
    this._rawData.push(new Uint8Array(this._textureSize * this._textureSize * nbChannels));
  }

  // if required pixels &gt; this._textureSize * this._textureSize * nbChannels ?
  // window.console.log(requiredPixels);
  // window.console.log(this._rows);
  // window.console.log(this._columns);
  // window.console.log(this._rows * this._columns);
  // window.console.log(this._textureSize);

  // Can not just use subarray because we have to normalize the values (Uint* 0&amp;lt;x&amp;lt;255)
  //var prevFrame = -1;
  //var prevTexture = -1;
  var frameDimension = this._dimensions.x * this._dimensions.y;
  var textureDimension = this._textureSize * this._textureSize;
  for (var jj = 0; jj &amp;lt; requiredPixels; jj++) {

    var frameIndex = Math.floor(jj / frameDimension);
    var inFrameIndex = jj % (frameDimension);
    var textureIndex = Math.floor(jj / textureDimension);
    var inTextureIndex = jj % (textureDimension);

    // window.console.log(textureIndex, inTextureIndex);
    // different ways to itereate if 1 or N channels!!
    // just 1 for now!
    // NORMAALIZE IN THE SHADERS!
    // could track min/max here...?

    //window.console.log(textureIndex,frameIndex);

    // if(prevFrame !== frameIndex){
    //   window.console.log(&#x27;frameIndex&#x27;, frameIndex);
    //   prevFrame = frameIndex;
    // }
    // if(prevTexture !== textureIndex){
    //   window.console.log(&#x27;textureIndex&#x27;, textureIndex);
    //   prevTexture = textureIndex;
    // }

    // if(frameIndex &amp;lt; 100 &amp;amp;&amp;amp; frameIndex &gt; 58){
    this._rawData[textureIndex][inTextureIndex] = this._frame[frameIndex]._pixelData[inFrameIndex]; //Math.floor( Math.random() * 255 );

    // }

    // // normalize value
    // var normalizedValue = 255 * ((this._data[j] - this._min) / (this._max - this._min));

    // // RGB
    // rawData[textureIndex][4 * inTextureIndex] = normalizedValue;

    // if (inTextureIndex &gt;= requiredPixels) {
    //     break;
    // }
  }

  // LPS to World.
  // and inverse.

  // all IJK coords + transform for origin and normal to be in same space!

  //     var obb = {
  //     &#x27;halfDimensions&#x27;: this._volumeCore._halfDimensions,
  //     &#x27;orientation&#x27;: this._volumeCore._orientation,
  //     &#x27;center&#x27;: this._volumeCore._halfDimensions, //this._volumeCore._RAS.center,
  //     &#x27;toOBBSpace&#x27;: this._volumeCore._transforms.ras2ijk,
  //     &#x27;toOBBSpaceInvert&#x27;: this._volumeCore._transforms.ijk2ras,
  // };

  // var plane = {
  //     &#x27;origin&#x27;: this._origin,
  //     &#x27;normal&#x27;: this._normal
  // };

  // SWITCH TO DECIDE WHAT WE CAN VIEW OR NOT FROM HERE!
};

/**
 * Order frames based on theirs dimensionIndexValues
 */
VJS.models.stack.prototype.orderFrameOnDimensionIndices = function(a, b) {

  if (&#x27;_dimensionIndexValues&#x27; in a &amp;amp;&amp;amp; Object.prototype.toString.call(a._dimensionIndexValues) === &#x27;[object Array]&#x27; &amp;amp;&amp;amp; &#x27;_dimensionIndexValues&#x27; in b &amp;amp;&amp;amp; Object.prototype.toString.call(b._dimensionIndexValues) === &#x27;[object Array]&#x27;) {
    for (var i = 0; i &amp;lt; a._dimensionIndexValues.length; i++) {
      if (parseInt(a._dimensionIndexValues[i]) &gt; parseInt(b._dimensionIndexValues[i])) {
        //window.console.log(a._dimensionIndexValues[i] + &#x27; &gt; &#x27; + b._dimensionIndexValues[i]);
        //window.console.log(typeof a._dimensionIndexValues[i] + &#x27; &gt; &#x27; + typeof b._dimensionIndexValues[i]);
        return 1;
      }
      if (parseInt(a._dimensionIndexValues[i]) &amp;lt; parseInt(b._dimensionIndexValues[i])) {
        //window.console.log(a._dimensionIndexValues[i] + &#x27; &amp;lt; &#x27; + b._dimensionIndexValues[i]);
        //window.console.log(typeof a._dimensionIndexValues[i] + &#x27; &amp;lt; &#x27; + typeof b._dimensionIndexValues[i]);
        return -1;
      }
    }
  } else {
    window.console.log(&#x27;One of the frames doesn\&#x27;t have a _dimensionIndexValues array.&#x27;);
    window.console.log(a);
    window.console.log(b);
  }

  return 0;
};

VJS.models.stack.prototype.merge = function(stack) {
  // try to merge imageHelper with current image.
  // same image if same Series UID?
  // could use concatenation if available, to already know if image is complete!
  var sameStackID = false;
  if (this._stackID === stack._stackID) {
    sameStackID = true;

    // Make sure image information is consisent?
    // re-compute it?
    var frame = stack._frame;
    // Merge Stacks (N against N)
    // try to match all stack to current stacks, if not add it to stacks list!
    for (var i = 0; i &amp;lt; frame.length; i++) {
      // test stack against existing stack
      for (var j = 0; j &amp;lt; this._frame.length; j++) {
        // test dimension
        if (this._frame[j]._dimensionIndexValues.length &gt; 0) {
          if (this._frame[j]._dimensionIndexValues.join() === frame[i]._dimensionIndexValues.join()) {
            // frame alread there!
            break;
          } else if (j === this._frame.length - 1) {
            this._frame.push(frame[i]);
          }
        }
        // test instance number
        else if (this._frame[j]._instanceNumber &gt;= 0) {
          if (this._frame[j]._instanceNumber === frame[i]._instanceNumber) {
            // frame already there!
            break;
          } else if (j === this._frame.length - 1) {
            this._frame.push(frame[i]);
          }
        }
        // test image position patient
        // else if(){

        // }
        // do not know how to merge stacks
        else if (j === this._frame.length - 1) {
          window.console.log(&#x27;stacks could not be merged&#x27;);
          window.console.log(this._frame);
          window.console.log(stack._frame);
        }

        // else, test instance number?

        // else, test image position patient?
      }
       
    }
  }
  
  return sameStackID;
};

// The Image Position (0020,0032) specifies the x, y, and z coordinates
// of the upper left hand corner of the image; it is the center of the
// first voxel transmitted. Image Orientation (0020,0037) specifies the
// direction cosines of the first row and the first column with respect
// to the patient. These Attributes shall be provide as a pair. Row value
// for the x, y, and z axes respectively followed by the Column value for
// the x, y, and z axes respectively.

// The direction of the axes is defined fully by the patient&#x27;s
// orientation. The x-axis is increasing to the left hand side of the
// patient. The y-axis is increasing to the posterior side of the
// patient. The z-axis is increasing toward the head of the patient.

// The patient based coordinate system is a right handed system, i.e. the
// vector cross product of a unit vector along the positive x-axis and a
// unit vector along the positive y-axis is equal to a unit vector along
// the positive z-axis.
// &quot;

// (**)
// http://www.itk.org/mailman/private/i...ry/007553.html
// You need to be suscribed to the ML to have access to this post (sorry).

// Reply With Quote Reply With Quote
// 10-02-2007 10:05 AM #2
// Re: Image Position (Patient) and Image Orientation (Patient)
// Since it might be usefull for other people, I am copy/pasting the
// answer from David Clunie here:

// -------- Original Message --------
// Subject: Re: [Insight-developers] [GDCM] ITK Origin and coordinate
// system
// Date: Wed, 18 Jan 2006 12:57:42 -0500
// From: David Clunie &amp;lt;&gt;
// Reply-To:
// To:

// Hi all

// Just to clarify a few things with respect to DICOM and what
// vendors do, without knowing enough about ITK or gdcm to
// answer the context of the concern. Please excuse me if I
// restate the obvious.

// As has been pointed out in previous posts there is absolutely
// no ambiguity about the DICOM attributes in this respect, nor
// whether the vendors interpret them differently (they do not).

// Specifically:

// - all DICOM references are relative to a specific &quot;frame of
// reference&quot; identified by a UID - all images that share that
// FoR share the same, completely arbitrary, origin; the origin
// might be the isocenter of the magnet, which is constant, but
// the patient position relative to it is not; this is the
// context in which all other DICOM attributes related to the
// &quot;patient coordinate system&quot; should be interpreted; the
// corollary is that different FoRs means coordinates and vectors
// are not comparable

// - the center of the top left hand voxel of a slice is defined
// relative to the FoR-specific origin by an x,y,z tuple that
// represents a translation of that location in mm from the offset;
// the x,y and z directions are patient (not gantry) relative,
// and their order is consistent and defined (see the standard)

// - the direction of the rows and columns are defined relative
// to the patient by unit vectors (direction cosines), again
// the details are in the standard.

// - the Image Position (Patient) TLHC location (which defines
// the offset from the FoR origin) is completely independent of
// the Image Orientation (Patient) unit vectors, which define
// the plane of the slice (only)

// Again, the x,y,z translation from the origin of the TLHC is
// in the nominal patient relative FoR, NOT the plane specified
// by the unit vectors that define the orientation of the slice.

// Note that the use of &quot;patient relative&quot; is relatively imprecise,
// in the sense that if the operator does not line the patient&#x27;s
// head foot axis exactly down the center line of the gantry or
// table, then though the direction of the Z axis will nominally
// be along the head-foot axis, but reproducible only within the
// same nominal FoR, and even then, only as long as the patient
// doesn&#x27;t move without the operator re-landmarking.

// All the vendors interpret this the same way, with the one notable
// exception being arguments over whether the TLHC is the center
// of the voxel or one edge of it (the standard has been clarified
// to specify the center, whereas previously it was unspecified,
// hence older implementations vary in this respect).
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on June 19, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>