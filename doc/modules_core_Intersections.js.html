<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.2">
  <meta charset="utf-8">
  <title>Source: modules/core/Intersections.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: modules/core/Intersections.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};

/**
 * intersections namespace
 * @namespace intersections
 * @memberOf VJS
 */
VJS.intersections = VJS.intersections || {};


/**
 * Compute intersection between oriented bounding box and a plane.
 * Returns intersection in plane&#x27;s space (toOBBSpaceInvert applied).
 * Should return at least 3 intersections. If not, the plane and the box do not
 * intersect.
 *
 * @memberOf VJS.intersections
 * @public
 *
 * @param {Object} obb - Oriented Bounding Box representation.
 * @param {THREE.Vector3} obb.halfDimensions - Half dimensions of the box.
 * @param {THREE.Vector3&amp;lt;THREE.Vector3&gt;} obb.orientation - Orientation of the edges of the box.
 * @param {THREE.Vector3} obb.center - Center of the box.
 * @param {THREE.Matrix4} obb.toOBBSpace - Transform to go from plane space to box space.
 * @param {THREE.Matrix4} obb.toOBBSpaceInvert - Transform to go from box space to plane space.
 * @param {Object} plane - Plane representation
 * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
 * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
 *
 * @returns {Array&amp;lt;THREE.Vector3&gt;} List of all intersections, in plane&#x27;s space.
 *
 * @todo toOBBSpace and toOBBSpaceInvert might be redundent.
 * @todo find best way to deal with different spaces.
 */

VJS.intersections.obbPlane = function(obb, plane) {

    //
    // obb = { halfDimensions, orientation, center, toOBBSpace }
    // plane = { position, direction }
    //
    //
    // LOGIC:
    //
    // Test intersection of each edge of the Oriented Bounding Box with the Plane
    // 
    // ALL EDGES 
    //
    //      .+-------+  
    //    .&#x27; |     .&#x27;|  
    //   +---+---+&#x27;  |  
    //   |   |   |   |  
    //   |  ,+---+---+  
    //   |.&#x27;     | .&#x27;   
    //   +-------+&#x27;     
    //
    // SPACE ORIENTATION
    //
    //       +
    //     j |
    //       |
    //       |   i 
    //   k  ,+-------+  
    //    .&#x27;
    //   +
    //
    //
    // 1- Move Plane position and orientation in IJK space
    // 2- Test Edges/ IJK Plane intersections
    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

    var intersections = [];

    var t1 = plane.direction.clone().applyMatrix4(obb.toOBBSpace);
    var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(obb.toOBBSpace);

    var planeOBB = {
        position: plane.position.clone().applyMatrix4(obb.toOBBSpace),
        direction: new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()
    };

    var bboxMin = new THREE.Vector3(
        obb.center.x - obb.halfDimensions.x,
        obb.center.y - obb.halfDimensions.y,
        obb.center.z - obb.halfDimensions.z);
    var bboxMax = new THREE.Vector3(
        obb.center.x + obb.halfDimensions.x,
        obb.center.y + obb.halfDimensions.y,
        obb.center.z + obb.halfDimensions.z);

    // 12 edges (i.e. ray)/plane intersection tests

    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
    //
    //       +
    //       |
    //       |
    //       | 
    //      ,+---+---+
    //    .&#x27;   
    //   +   

    var ray = {
        &#x27;position&#x27;: new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),
        &#x27;direction&#x27;: obb.orientation.x
    };

    var intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.y;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.z;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    // RAYS STARTING FROM THE LAST CORNER
    //
    //               +
    //             .&#x27;
    //   +-------+&#x27;
    //           |
    //           |
    //           |
    //           +
    //

    ray = {
        &#x27;position&#x27;: new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),
        &#x27;direction&#x27;: obb.orientation.x
    };

    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.y;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.z;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    // RAYS STARTING FROM THE SECOND CORNER
    //
    //               +
    //               |
    //               |
    //               |
    //               +
    //             .&#x27;
    //           +&#x27;

    ray = {
        &#x27;position&#x27;: new THREE.Vector3(obb.center.x + obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),
        &#x27;direction&#x27;: obb.orientation.y
    };

    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.z;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    // RAYS STARTING FROM THE THIRD CORNER
    //
    //      .+-------+  
    //    .&#x27;
    //   +
    //   
    //   
    //   
    //   

    ray = {
        &#x27;position&#x27;: new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y + obb.halfDimensions.y, obb.center.z - obb.halfDimensions.z),
        &#x27;direction&#x27;: obb.orientation.x
    };

    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.z;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    // RAYS STARTING FROM THE FOURTH CORNER
    //
    //   
    //   
    //   +
    //   |
    //   |  
    //   |
    //   +-------+

    ray = {
        &#x27;position&#x27;: new THREE.Vector3(obb.center.x - obb.halfDimensions.x, obb.center.y - obb.halfDimensions.y, obb.center.z + obb.halfDimensions.z),
        &#x27;direction&#x27;: obb.orientation.x
    };

    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    ray.direction = obb.orientation.y;
    intersection = this.rayPlane(ray, planeOBB);
    if (intersection &amp;amp;&amp;amp;
        intersection.x &gt;= bboxMin.x &amp;amp;&amp;amp; intersection.y &gt;= bboxMin.y &amp;amp;&amp;amp; intersection.z &gt;= bboxMin.z &amp;amp;&amp;amp;
        intersection.x &amp;lt;= bboxMax.x &amp;amp;&amp;amp; intersection.y &amp;lt;= bboxMax.y &amp;amp;&amp;amp; intersection.z &amp;lt;= bboxMax.z) {
        intersections.push(intersection.applyMatrix4(obb.toOBBSpaceInvert));
    }

    return intersections;
};

/**
 * Compute intersection between a ray and a plane.
 *
 * @memberOf VJS.intersections
 * @public
 *
 * @param {Object} ray - Ray representation.
 * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
 * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
 * @param {Object} plane - Plane representation
 * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
 * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
 *
 * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
 */
VJS.intersections.rayPlane = function(ray, plane) {
    // ray: {position, direction}
    // plane: {position, direction}

    if (ray.direction.dot(plane.direction) !== 0) {
        //
        // not parallel, move forward
        //
        // LOGIC:
        //
        // Ray equation: P = P0 + tV
        // P = &amp;lt;Px, Py, Pz&gt;
        // P0 = &amp;lt;ray.position.x, ray.position.y, ray.position.z&gt;
        // V = &amp;lt;ray.direction.x, ray.direction.y, ray.direction.z&gt;
        //
        // Therefore:
        // Px = ray.position.x + t*ray.direction.x
        // Py = ray.position.y + t*ray.direction.y
        // Pz = ray.position.z + t*ray.direction.z
        //
        //
        //
        // Plane equation: ax + by + cz + d = 0
        // a = plane.direction.x
        // b = plane.direction.y
        // c = plane.direction.z
        // d = -( plane.direction.x*plane.position.x +
        //        plane.direction.y*plane.position.y +
        //        plane.direction.z*plane.position.z )
        //
        //
        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
        // 2- find t
        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
        //
        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /
            (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

        var intersection = new THREE.Vector3(
            ray.position.x + t * ray.direction.x,
            ray.position.y + t * ray.direction.y,
            ray.position.z + t * ray.direction.z);

        return intersection;

    }

    return null;

};

// export the frame module
module.exports = VJS.intersections;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.2 on July 16, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>