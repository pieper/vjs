<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: modules/helpers/helpers.image.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: modules/helpers/helpers.image.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};

/**
 * helpers namespace
 * @namespace helpers
 * @memberOf VJS
 * @public
 */
VJS.helpers = VJS.helpers || {};

//
// https://en.wikipedia.org/wiki/Immediately-invoked_function_expression
VJS.helpers.image = function() {

  THREE.Object3D.call(this);

  // ...
  this._image = null;
  //this._stacks = [];

};

VJS.helpers.image.prototype = Object.create(THREE.Object3D.prototype);

VJS.helpers.image.prototype.constructor = VJS.helpers.image;

VJS.helpers.image.prototype.merge = function(imageHelper) {
  return this._image.merge(imageHelper._image);
};

VJS.helpers.image.prototype.addImage = function(image) {
  this._image = image;
};

VJS.helpers.image.prototype.getStack = function(stackIndex) {
  return stackIndex;
};

VJS.helpers.image.prototype.prepare = function() {
  // try to merge image to current image...
  // cleanup previous state...

  window.console.log(&#x27;helpers Image Prepare!!!&#x27;);
  if (this._image) {

    // get first stack!
    var stack = this._image._stack[0];
    stack.prepare();
    window.console.log(stack);

    // Convenience function
    var dimensions = stack._dimensions;
    var halfDimensions = stack._halfDimensions;

    // voxel offset
    var offset = new THREE.Vector3(-0.5, -0.5, -0.5);

    // Bounding Box
    var geometry = new THREE.BoxGeometry(
      dimensions.x, dimensions.y, dimensions.z);
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(
      halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));
    geometry.applyMatrix(stack._ijk2LPS);
    var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      color: 0x61F2F3
    });
    var cube = new THREE.Mesh(geometry, material);
    this.add(cube);

    // Slice
    // Geometry
    //

    // Define the bouding box used to generate the slice geometry
    // center
    // orientation
    // and half-dimensions
    var center = new THREE.Vector3(0, 0, 0);
    var orientation = new THREE.Vector3(
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(0, 0, 1));

    var position = new THREE.Vector3(0, 0, 0);
    // we want to center the slice on a voxel (not at the limit between 2 voxels)
    // precision issue if at limit (pixels intensity flickers between voxels)
    if(dimensions.x%2 === 0 ){
      position.x = -0.5;
    }
    if(dimensions.y%2 === 0 ){
      position.y = -0.5;
    }
    if(dimensions.z%2 === 0 ){
      position.z = -0.5;
    }

    var direction = new THREE.Vector3(0, 0, 1);

    var sliceGeometry = new VJS.geometries.slice(
      halfDimensions, center, orientation,
      position, direction);
    sliceGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(
      halfDimensions.x  + offset.x, halfDimensions.y  + offset.y, halfDimensions.z  + offset.z));
    sliceGeometry.applyMatrix(stack._ijk2LPS);

    // Slice
    // Material
    var textures = [];
    for (var m = 0; m &amp;lt; stack._nbTextures; m++) {
      var tex = new THREE.DataTexture(stack._rawData[m], stack._textureSize, stack._textureSize, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
      tex.needsUpdate = true;
      textures.push(tex);
    }

    var sliceMaterial = new THREE.ShaderMaterial({
      // &#x27;wireframe&#x27;: true,
      &#x27;side&#x27;: THREE.DoubleSide,
      &#x27;transparency&#x27;: true,
      &#x27;uniforms&#x27;: VJS.shaders.data.parameters.uniforms,
      &#x27;vertexShader&#x27;: VJS.shaders.data.parameters.vertexShader,
      &#x27;fragmentShader&#x27;: VJS.shaders.data.parameters.fragmentShader,
    });

    // important so uniforms are not overwritten!
    // clone it!
    var mySliceMaterial = sliceMaterial.clone();
    var uniforms = mySliceMaterial.uniforms;
    uniforms.uTextureSize.value = stack._textureSize;
    uniforms.uTextureContainer.value = textures;
    // texture dimensions
    uniforms.uDataDimensions.value = stack._dimensions;
    // world to model
    uniforms.uWorldToData.value = stack._lps2IJK;

    var slice = new THREE.Mesh(sliceGeometry, mySliceMaterial);
    this.add(slice);

    // Border of the slice
    var borderMaterial = new THREE.LineBasicMaterial({
      color: 0xff0000,
      polygonOffset: true,
      polygonOffsetFactor: -0.1
    });
    var borderGeometry = new THREE.Geometry();
    for (var i = 0; i &amp;lt; sliceGeometry.vertices.length; i++) {
      borderGeometry.vertices.push(sliceGeometry.vertices[i]);
    }
    borderGeometry.vertices.push(sliceGeometry.vertices[0]);

    // borderGeometry.vertices = sliceGeometry.vertices;
    var borderLine = new THREE.Line(borderGeometry, borderMaterial);
    this.add(borderLine);

  } else {
    window.console.log(&#x27;no image to be prepared...&#x27;);
    //this._image.merge(image);
  }
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on June 19, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>