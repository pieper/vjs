<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: modules/geometries/slice.geometry.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: modules/geometries/slice.geometry.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var VJS = VJS || {};

/**
 * slice namespace
 * @namespace slice
 * @memberOf VJS
 * @public
 */
VJS.slice = VJS.slice || {};

/**
 * Create a slice geometry given a box and the cut-plane
 *
 * @constructor
 * @class
 * @memberOf VJS.slice
 * @public
 *
 * @example
 * // Define box to be sliced
 * var halfDimensions = new THREE.Vector(123, 45, 67);
 * var center = new THREE.Vector3(0, 0, 0);
 * var orientation = new THREE.Vector3(
 *   new THREE.Vector3(1, 0, 0),
 *   new THREE.Vector3(0, 1, 0),
 *   new THREE.Vector3(0, 0, 1)
 * );
 *
 * // Define slice plane
 * var position = center.clone();
 * var direction = new THREE.Vector3(-0.2, 0.5, 0.3);
 *
 * // Create the slice geometry &amp;amp; materials
 * var sliceGeometry = new VJS.slice.geometry(halfDimensions, center, orientation, position, direction);
 * var sliceMaterial = new THREE.MeshBasicMaterial({
 *   &#x27;side&#x27;: THREE.DoubleSide,
 *   &#x27;color&#x27;: 0xFF5722
 * });
 *
 *  // Create mesh and add it to the scene
 *  var slice = new THREE.Mesh(sliceGeometry, sliceMaterial);
 *  scene.add(slice);
 */

VJS.slice.geometry = function(halfDimensions, center, orientation, position, direction) {

    //
    // prepare data for the shape!
    //
    var obb = {
        &#x27;halfDimensions&#x27;: halfDimensions,
        &#x27;center&#x27;: center,
        &#x27;orientation&#x27;: orientation,
        &#x27;toOBBSpace&#x27;: new THREE.Matrix4(), // not necessary
        &#x27;toOBBSpaceInvert&#x27;: new THREE.Matrix4() // not necessary
    };

    var plane = {
        &#x27;position&#x27;: position,
        &#x27;direction&#x27;: direction
    };

    // BOOM!
    var intersections = VJS.intersections.obbPlane(obb, plane);

    if (intersections.length &amp;lt; 3) {
        window.console.log(&#x27;WARNING: Less than 3 intersections between OBB and Plane.&#x27;);
        window.console.log(&#x27;OBB&#x27;);
        window.console.log(obb);
        window.console.log(&#x27;Plane&#x27;);
        window.console.log(plane);
        window.console.log(&#x27;exiting...&#x27;);
    }

    var centerOfMass = this.centerOfMass(intersections);
    var orderedIntersections = this.orderIntersections(intersections, centerOfMass, direction);

    // split for convenience
    var formatIntersections = [];
    var formatIntersectionsXY = [];
    for (var k = 0; k &amp;lt; orderedIntersections.length; k++) {
        formatIntersections.push(orderedIntersections[k].point);
        formatIntersectionsXY.push(orderedIntersections[k].xy);
    }


    //
    // Create Shape
    //
    var sliceShape = new THREE.Shape();
    // move to first point!
    sliceShape.moveTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);


    // loop through all points!
    for (var l = 1; l &amp;lt; formatIntersectionsXY.length; l++) {
        // project each on plane!
        sliceShape.lineTo(formatIntersectionsXY[l].x, formatIntersectionsXY[l].y);
    }

    // close the shape!
    sliceShape.lineTo(formatIntersectionsXY[0].x, formatIntersectionsXY[0].y);


    //
    // Generate Geometry from shape
    // It does triangulation for us!
    // 
    THREE.ShapeGeometry.call(this, sliceShape);
    this.type = &#x27;SliceGeometry&#x27;;

    // update real position of each vertex! (not in 2d)
    this.vertices = formatIntersections;
    this.verticesNeedUpdate = true;
};

VJS.slice.geometry.prototype = Object.create(THREE.ShapeGeometry.prototype);
VJS.slice.geometry.prototype.constructor = VJS.slice.geometry;

VJS.slice.geometry.prototype.centerOfMass = function(intersections) {
    var centerOfMass = new THREE.Vector3(0, 0, 0);
    for (var i = 0; i &amp;lt; intersections.length; i++) {
        centerOfMass.x += intersections[i].x;
        centerOfMass.y += intersections[i].y;
        centerOfMass.z += intersections[i].z;
    }
    centerOfMass.divideScalar(intersections.length);

    return centerOfMass;
};

VJS.slice.geometry.prototype.orderIntersections = function(intersections, centerOfMass, direction) {
    var a0 = intersections[0].x;
    var b0 = intersections[0].y;
    var c0 = intersections[0].z;
    var x0 = intersections[0].x - centerOfMass.x;
    var y0 = intersections[0].y - centerOfMass.y;
    var z0 = intersections[0].z - centerOfMass.z;
    var l0 = {
        origin: new THREE.Vector3(a0, b0, c0),
        direction: new THREE.Vector3(x0, y0, z0).normalize()
    };

    var base = new THREE.Vector3(0, 0, 0).crossVectors(l0.direction, direction).normalize();

    var orderedIntersections = [];

    // other lines // if inter, return location + angle
    for (var j = 0; j &amp;lt; intersections.length; j++) {

        var a1 = intersections[j].x;
        var b1 = intersections[j].y;
        var c1 = intersections[j].z;
        var x1 = intersections[j].x - centerOfMass.x;
        var y1 = intersections[j].y - centerOfMass.y;
        var z1 = intersections[j].z - centerOfMass.z;

        var l1 = {
            origin: new THREE.Vector3(a1, b1, c1),
            direction: new THREE.Vector3(x1, y1, z1).normalize()
        };

        var x = l0.direction.dot(l1.direction);
        var y = base.dot(l1.direction);

        var thetaAngle = Math.atan2(y, x);
        var theta = thetaAngle * (180 / Math.PI);
        orderedIntersections.push({
            &#x27;angle&#x27;: theta,
            &#x27;point&#x27;: l1.origin,
            &#x27;xy&#x27;: {
                &#x27;x&#x27;: x,
                &#x27;y&#x27;: y
            }
        });
    }

    orderedIntersections.sort(function(a, b) {
        return a.angle - b.angle;
    });

    return orderedIntersections;
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on May 15, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>